diff --git a/cmd/frontend/internal/agentapi/classifier_test.go b/cmd/frontend/internal/agentapi/classifier_test.go
index d022aa035a6f..22d76b939bc8 100644
--- a/cmd/frontend/internal/agentapi/classifier_test.go
+++ b/cmd/frontend/internal/agentapi/classifier_test.go
@@ -73,8 +73,8 @@ func TestClassifyFeedbackFromChangeset(t *testing.T) {
 				// Setup classifier mock for reaction
 				classifier.ClassifyReactionFunc.SetDefaultReturn(
 					core.Some(goapi.ReviewDiagnosticFeedback{
-						HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelStronglyAgree),
-						ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive),
+						HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelStronglyAgree),
+						ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelTruePositive),
 						DiagnosticId:     pointers.Ptr(int32(1)),
 						ReviewId:         pointers.Ptr(int32(1)),
 						MessageId:        pointers.Ptr(int32(1)),
@@ -89,8 +89,8 @@ func TestClassifyFeedbackFromChangeset(t *testing.T) {
 				// Setup classifier mock for message
 				classifier.ClassifyMessageFunc.SetDefaultReturn(
 					core.Some(goapi.ReviewDiagnosticFeedback{
-						HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelAgree),
-						ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive),
+						HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelAgree),
+						ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelTruePositive),
 						DiagnosticId:     pointers.Ptr(int32(1)),
 						ReviewId:         pointers.Ptr(int32(1)),
 						MessageId:        pointers.Ptr(int32(2)),
@@ -117,8 +117,8 @@ func TestClassifyFeedbackFromChangeset(t *testing.T) {
 			},
 			wantFeedbacks: []goapi.ReviewDiagnosticFeedback{
 				{
-					HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelStronglyAgree),
-					ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive),
+					HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelStronglyAgree),
+					ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelTruePositive),
 					DiagnosticId:     pointers.Ptr(int32(1)),
 					ReviewId:         pointers.Ptr(int32(1)),
 					MessageId:        pointers.Ptr(int32(1)),
@@ -128,8 +128,8 @@ func TestClassifyFeedbackFromChangeset(t *testing.T) {
 					},
 				},
 				{
-					HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelAgree),
-					ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive),
+					HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelAgree),
+					ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelTruePositive),
 					DiagnosticId:     pointers.Ptr(int32(1)),
 					ReviewId:         pointers.Ptr(int32(1)),
 					MessageId:        pointers.Ptr(int32(2)),
@@ -294,8 +294,8 @@ func TestClassifyFeedbackFromPullRequest_Pagination(t *testing.T) {
 				Type:     "llm_judge",
 				LlmJudge: pointers.Ptr("haiku"),
 			},
-			HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelStronglyAgree),
-			ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive),
+			HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelStronglyAgree),
+			ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelTruePositive),
 			Comment:          m.Content.Text,
 		}), nil
 	})
@@ -308,8 +308,8 @@ func TestClassifyFeedbackFromPullRequest_Pagination(t *testing.T) {
 				Type:     "llm_judge",
 				LlmJudge: pointers.Ptr("haiku"),
 			},
-			HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelAgree),
-			ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive),
+			HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelAgree),
+			ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelTruePositive),
 			Comment:          pointers.Ptr(r.Content),
 		}), nil
 	})
diff --git a/cmd/frontend/internal/agentapi/conversations.go b/cmd/frontend/internal/agentapi/conversations.go
index 1fb6646c57d4..eafb4019dbb2 100644
--- a/cmd/frontend/internal/agentapi/conversations.go
+++ b/cmd/frontend/internal/agentapi/conversations.go
@@ -118,16 +118,18 @@ func toConversation(fk commentForeignKeys, comment GithubComment, botID int64) g
 		}
 
 		conv.Location = &goapi.Location{
-			Repo:  string(fk.repoName),
-			Path:  comment.Path,
-			Oid:   comment.CommitID,
-			Ref:   ref,
-			Range: &rng,
+			Repo:   string(fk.repoName),
+			RepoId: pointers.Ptr(int32(fk.repoID)),
+			Path:   comment.Path,
+			Oid:    comment.CommitID,
+			Ref:    ref,
+			Range:  &rng,
 		}
 	} else {
 		// For issue comments, we only set the repo
 		conv.Location = &goapi.Location{
-			Repo: pointers.Deref(comment.Repo.Name, ""),
+			Repo:   pointers.Deref(comment.Repo.Name, ""),
+			RepoId: pointers.Ptr(int32(fk.repoID)),
 		}
 	}
 
diff --git a/cmd/frontend/internal/agentapi/handler_agent_test.go b/cmd/frontend/internal/agentapi/handler_agent_test.go
index e93cc0c7c9f8..8fe37cd29569 100644
--- a/cmd/frontend/internal/agentapi/handler_agent_test.go
+++ b/cmd/frontend/internal/agentapi/handler_agent_test.go
@@ -153,7 +153,8 @@ func TestAgentHandler(t *testing.T) {
 		Id:   1,
 		Kind: goapi.ConversationKindPullRequest,
 		Location: &goapi.Location{
-			Repo: "test-repo",
+			Repo:   "test-repo",
+			RepoId: pointers.Ptr(int32(1)),
 		},
 		ReviewId: pointers.Ptr(int32(testingReview1.ReviewId)),
 	}
@@ -161,7 +162,8 @@ func TestAgentHandler(t *testing.T) {
 		Id:   2,
 		Kind: goapi.ConversationKindPullRequest,
 		Location: &goapi.Location{
-			Repo: "test-repo",
+			Repo:   "test-repo",
+			RepoId: pointers.Ptr(int32(1)),
 		},
 		ReviewId: pointers.Ptr(int32(testingReview2.ReviewId)),
 	}
diff --git a/cmd/frontend/internal/agentapi/handler_webhook_github_app_test.go b/cmd/frontend/internal/agentapi/handler_webhook_github_app_test.go
index cd2001d950e7..8d970c964af2 100644
--- a/cmd/frontend/internal/agentapi/handler_webhook_github_app_test.go
+++ b/cmd/frontend/internal/agentapi/handler_webhook_github_app_test.go
@@ -831,6 +831,7 @@ func newMockReviewService(t *testing.T, db database.DB) *MockReviewService {
 					},
 					// Explicitly mark as added line so it passes the diff location filter.
 					DiffLocation: pointers.Ptr(goapi.DiffLocationAdded),
+					Quality:      pointers.Ptr(goapi.DiagnosticQualityAccepted),
 				},
 				{
 					Message:  "this file does not exist",
diff --git a/cmd/frontend/internal/agentapi/init.go b/cmd/frontend/internal/agentapi/init.go
index da1d0f33d016..896ed4d52544 100644
--- a/cmd/frontend/internal/agentapi/init.go
+++ b/cmd/frontend/internal/agentapi/init.go
@@ -51,7 +51,7 @@ func Init(
 		db:         db,
 		logger:     logger,
 
-		reviewService:        review.NewService(reviewLogger, gitserverClient, llm, db, ruleService, nil, grader.NewGrader(llm, gitserverClient, db, grader.CodeWindowSizeMedium)),
+		reviewService:        review.NewService(reviewLogger, gitserverClient, llm, db, ruleService, nil, grader.NewGrader(llm, grader.CodeWindowSizeMedium)),
 		llm:                  llm,
 		githubAppClientsCtor: CreateGithubAppClients,
 
diff --git a/cmd/frontend/internal/agentapi/reviews.go b/cmd/frontend/internal/agentapi/reviews.go
index 45664166daec..b6817d7d2d2e 100644
--- a/cmd/frontend/internal/agentapi/reviews.go
+++ b/cmd/frontend/internal/agentapi/reviews.go
@@ -330,6 +330,11 @@ func (h *reviewChangesetHandler) doReview(
 			continue
 		}
 
+		// if the diagnostic was rejected by the grader, we don't post it
+		if !diagnostic.IsAcceptedQuality() {
+			continue
+		}
+
 		if !diagnostic.IsValidDiffLocation(diffLocations, diagnostic.DiffLocation) {
 			continue
 		}
diff --git a/cmd/frontend/internal/httpapi/httpapi.go b/cmd/frontend/internal/httpapi/httpapi.go
index 8374eeb577ec..718c7c9bc12a 100644
--- a/cmd/frontend/internal/httpapi/httpapi.go
+++ b/cmd/frontend/internal/httpapi/httpapi.go
@@ -457,7 +457,7 @@ func NewHandler(
 	}))
 
 	reviewLogger := logger.Scoped("review")
-	reviewService := review.NewService(reviewLogger, gitserverClient, llmChatClient, db, ruleService, nil, grader.NewGrader(llmChatClient, gitserverClient, db, grader.CodeWindowSizeMedium))
+	reviewService := review.NewService(reviewLogger, gitserverClient, llmChatClient, db, ruleService, nil, grader.NewGrader(llmChatClient, grader.CodeWindowSizeMedium))
 	reviewapi.RegisterHandlers(reviews, db, reviewService, gitserverClient)
 
 	conversations := m.PathPrefix("/conversations").Subrouter()
diff --git a/cmd/frontend/internal/reviewapi/handler_review_feedback_test.go b/cmd/frontend/internal/reviewapi/handler_review_feedback_test.go
index 45dc4be8a3ca..1bedcb1d53a5 100644
--- a/cmd/frontend/internal/reviewapi/handler_review_feedback_test.go
+++ b/cmd/frontend/internal/reviewapi/handler_review_feedback_test.go
@@ -31,8 +31,8 @@ func TestHandleListDiagnosticsFeedback(t *testing.T) {
 		ReviewId:         &review.ReviewId,
 		DiagnosticId:     &diagnosticId,
 		Comment:          pointers.Ptr("Test feedback"),
-		HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelAgree),
-		ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive),
+		HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelAgree),
+		ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelTruePositive),
 	}
 
 	// Mock the review store to return predetermined responses for ListFeedback
diff --git a/cmd/frontend/internal/reviewapi/handler_review_test.go b/cmd/frontend/internal/reviewapi/handler_review_test.go
index 729eb236840e..59ba4d95968e 100644
--- a/cmd/frontend/internal/reviewapi/handler_review_test.go
+++ b/cmd/frontend/internal/reviewapi/handler_review_test.go
@@ -236,8 +236,8 @@ func TestHandleCreateFeedback(t *testing.T) {
 	router := setup(db, reviewService)
 
 	feedback := goapi.ReviewDiagnosticFeedback{
-		HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelAgree),
-		ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive),
+		HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelAgree),
+		ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelTruePositive),
 	}
 	// If an ID is provided, setup initial review with diagnostic
 	request := goapi.ReviewRequest{
@@ -397,6 +397,7 @@ func TestHandleListDiagnostics(t *testing.T) {
 			Message:  "This is a test diagnostic message",
 			Rule:     &styleRefR1,
 			Severity: goapi.SeverityInfo,
+			Quality:  pointers.Ptr(goapi.DiagnosticQualityAccepted),
 		},
 	}))
 
diff --git a/internal/database/dbtesting/test_reviews.go b/internal/database/dbtesting/test_reviews.go
index a345f7e89b17..4a7b1cb5b40a 100644
--- a/internal/database/dbtesting/test_reviews.go
+++ b/internal/database/dbtesting/test_reviews.go
@@ -345,8 +345,8 @@ func RunTestReviews(t *testing.T, info TestDBInfo) {
 		feedback := goapi.ReviewDiagnosticFeedback{
 			ReviewId:         &fixture.ReviewId,
 			DiagnosticId:     pointers.Ptr(diagnosticId),
-			ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive),
-			HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelStronglyAgree),
+			ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelTruePositive),
+			HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelStronglyAgree),
 			Author: &goapi.ReviewDiagnosticEvaluationAuthor{
 				Type:   "user",
 				UserId: &user.ID,
@@ -550,6 +550,36 @@ func RunTestReviews(t *testing.T, info TestDBInfo) {
 			require.Len(t, got.Nodes, 2)
 		})
 
+		t.Run("List diagnostics with DiagnosticQuality filter", func(t *testing.T) {
+			// Create diagnostics with different quality levels
+			diagnosticsWithQuality := []goapi.ReviewDiagnostic{
+				{
+					Rule:     &securityRuleV1Ref,
+					Severity: goapi.SeverityWarning,
+					Message:  "Rejected diagnostic",
+					Quality:  pointers.Ptr(goapi.DiagnosticQualityRejected),
+				},
+				{
+					Rule:     &securityRuleV1Ref,
+					Severity: goapi.SeverityWarning,
+					Message:  "Accepted diagnostic",
+					Quality:  pointers.Ptr(goapi.DiagnosticQualityAccepted),
+				},
+			}
+			review := createReviewFixture(t, db, repo, withDiagnostics(diagnosticsWithQuality))
+
+			t.Run("specific quality filter", func(t *testing.T) {
+				got, err := db.Reviews().ListDiagnostics(ctx, database.DiagnosticListOptions{
+					IncludeRejectedDiagnostics: true,
+					ReviewId:                   core.Some(review.ReviewId),
+				})
+				require.NoError(t, err)
+				require.Len(t, got.Nodes, 2)
+				require.Equal(t, goapi.DiagnosticQualityRejected, *got.Nodes[0].Quality)
+				require.Equal(t, goapi.DiagnosticQualityAccepted, *got.Nodes[1].Quality)
+			})
+		})
+
 		t.Run("List diagnostics with non-existent rule", func(t *testing.T) {
 			got, err := db.Reviews().ListDiagnostics(ctx, database.DiagnosticListOptions{
 				RuleRef: core.Some(goapi.RuleRef{
@@ -576,42 +606,23 @@ func RunTestReviews(t *testing.T, info TestDBInfo) {
 			user, err := db.Users().Create(ctx, database.NewUser{Username: "testuser"})
 			require.NoError(t, err)
 
-			// Create a diagnostic with feedback
-			diagnostic := goapi.ReviewDiagnostic{
-				Rule:     &securityRuleV3Ref,
-				Severity: goapi.SeverityWarning,
-				Message:  "Test diagnostic",
-				Location: goapi.Location{
-					Repo: "github.com/sourcegraph/sourcegraph",
-					Path: "test.go",
-				},
-			}
-			review := createReviewFixture(t, db, repo, withDiagnostics([]goapi.ReviewDiagnostic{diagnostic}))
-			diagnosticId := (*review.Diagnostics)[0].DiagnosticId
-
 			// Create multiple feedback entries
 			feedback1 := goapi.ReviewDiagnosticFeedback{
-				ReviewId:     &review.ReviewId,
-				DiagnosticId: &diagnosticId,
-				Comment:      pointers.Ptr("First feedback"),
+				Comment: pointers.Ptr("First feedback"),
 				Author: &goapi.ReviewDiagnosticEvaluationAuthor{
 					Type:   "user",
 					UserId: &user.ID,
 				},
 			}
 			feedback2 := goapi.ReviewDiagnosticFeedback{
-				ReviewId:     &review.ReviewId,
-				DiagnosticId: &diagnosticId,
-				Comment:      pointers.Ptr("Second feedback"),
+				Comment: pointers.Ptr("Second feedback"),
 				Author: &goapi.ReviewDiagnosticEvaluationAuthor{
 					Type:   "user",
 					UserId: &user.ID,
 				},
 			}
 			feedback3 := goapi.ReviewDiagnosticFeedback{
-				ReviewId:     &review.ReviewId,
-				DiagnosticId: &diagnosticId,
-				Comment:      pointers.Ptr("Third feedback"),
+				Comment: pointers.Ptr("Third feedback"),
 				Author: &goapi.ReviewDiagnosticEvaluationAuthor{
 					Type:     "llm_judge",
 					LlmJudge: pointers.Ptr("gpt-4"),
@@ -619,8 +630,29 @@ func RunTestReviews(t *testing.T, info TestDBInfo) {
 			}
 			require.NoError(t, err)
 
-			_, err = db.Reviews().BulkCreateFeedback(ctx, []goapi.ReviewDiagnosticFeedback{feedback1, feedback2, feedback3})
-			require.NoError(t, err)
+			// Create a diagnostic with feedback
+			diagnostic := goapi.ReviewDiagnostic{
+				Rule:     &securityRuleV3Ref,
+				Severity: goapi.SeverityWarning,
+				Message:  "Test diagnostic",
+				Location: goapi.Location{
+					Repo:   "github.com/sourcegraph/sourcegraph",
+					RepoId: pointers.Ptr(int32(1)),
+					Path:   "test.go",
+				},
+				Feedback: &[]goapi.ReviewDiagnosticFeedback{feedback1, feedback2, feedback3},
+			}
+			review := createReviewFixture(t, db, repo, withDiagnostics([]goapi.ReviewDiagnostic{diagnostic}))
+
+			t.Run("should return all feedback for the review", func(t *testing.T) {
+				got, err := db.Reviews().ListDiagnostics(ctx, database.DiagnosticListOptions{
+					ReviewId: core.Some(review.ReviewId),
+				})
+				require.NoError(t, err)
+				require.Len(t, got.Nodes, 1)
+				require.NotNil(t, got.Nodes[0].Feedback)
+				require.Len(t, *got.Nodes[0].Feedback, 3)
+			})
 
 			t.Run("should return all feedback when limit is greater than feedback count", func(t *testing.T) {
 				got, err := db.Reviews().ListDiagnostics(ctx, database.DiagnosticListOptions{
@@ -843,10 +875,11 @@ func mkFixture(opts ...fixtureOption) goapi.Review {
 		Diagnostics: &[]goapi.ReviewDiagnostic{{
 			Severity: goapi.SeverityWarning,
 			Location: goapi.Location{
-				Repo: "github.com/sourcegraph/sourcegraph",
-				Path: "internal/database/reviews.go",
-				Oid:  "a1b2c3d4e5f6g7h8i9j0",
-				Ref:  pointers.Ptr("refs/heads/main"),
+				Repo:   "github.com/sourcegraph/sourcegraph",
+				RepoId: pointers.Ptr(int32(1)),
+				Path:   "internal/database/reviews.go",
+				Oid:    "a1b2c3d4e5f6g7h8i9j0",
+				Ref:    pointers.Ptr("refs/heads/main"),
 				Range: &goapi.Range{
 					Start: &goapi.Position{
 						Line:      42,
diff --git a/internal/database/dbtesting/test_rules.go b/internal/database/dbtesting/test_rules.go
index 31eb44abd47b..255909585291 100644
--- a/internal/database/dbtesting/test_rules.go
+++ b/internal/database/dbtesting/test_rules.go
@@ -328,10 +328,10 @@ func RunTestRules(t *testing.T, info TestDBInfo) {
 				require.Len(t, diagnosticIDs, 3)
 
 				// Insert feedback with different confusion labels
-				for i, label := range []goapi.ReviewDiagnosticFeedbackConfusionLabel{
-					goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive,
-					goapi.ReviewDiagnosticFeedbackConfusionLabelFalsePositive,
-					goapi.ReviewDiagnosticFeedbackConfusionLabelFalseNegative,
+				for i, label := range []goapi.ConfusionLabel{
+					goapi.ConfusionLabelTruePositive,
+					goapi.ConfusionLabelFalsePositive,
+					goapi.ConfusionLabelFalseNegative,
 				} {
 					_, err = db.Reviews().BulkCreateFeedback(ctx, []goapi.ReviewDiagnosticFeedback{
 						{
diff --git a/internal/database/fakedb/reviews.go b/internal/database/fakedb/reviews.go
index a5199f853013..3f03827ab2e5 100644
--- a/internal/database/fakedb/reviews.go
+++ b/internal/database/fakedb/reviews.go
@@ -101,7 +101,28 @@ func (s *Reviews) Create(ctx context.Context, request goapi.Review) (goapi.Revie
 		dCopy := d
 		dCopy.DiagnosticId = diagID
 		dCopy.ReviewId = id
+
+		// Store the diagnostic first so it exists when creating feedback
 		s.diagnostics[diagID] = dCopy
+
+		// Handle feedback if present
+		var createdFeedback []goapi.ReviewDiagnosticFeedback
+		if dCopy.Feedback != nil {
+			for i := range *dCopy.Feedback {
+				feedback := (*dCopy.Feedback)[i]
+				feedback.DiagnosticId = pointers.Ptr(diagID)
+				feedback.ReviewId = pointers.Ptr(id)
+				created, err := s.createFeedback(feedback)
+				if err != nil {
+					return goapi.Review{}, err
+				}
+				createdFeedback = append(createdFeedback, created)
+			}
+			dCopy.Feedback = &createdFeedback
+			// Update the diagnostic with the feedback
+			s.diagnostics[diagID] = dCopy
+		}
+
 		createdDiagnostics = append(createdDiagnostics, dCopy)
 	}
 
@@ -367,6 +388,19 @@ func (s *Reviews) ListDiagnostics(ctx context.Context, opts database.DiagnosticL
 				continue
 			}
 		}
+
+		if reviewId, ok := opts.ReviewId.Get(); ok {
+			if d.ReviewId != reviewId {
+				continue
+			}
+		}
+
+		if !opts.IncludeRejectedDiagnostics {
+			if d.Quality != nil && *d.Quality == goapi.DiagnosticQualityRejected {
+				continue
+			}
+		}
+
 		if severities, ok := opts.Severities.Get(); ok {
 			if !slices.Contains(severities, string(d.Severity)) {
 				continue
diff --git a/internal/database/reviews.go b/internal/database/reviews.go
index c2ebf7b7903b..933f0a8e609f 100644
--- a/internal/database/reviews.go
+++ b/internal/database/reviews.go
@@ -80,16 +80,17 @@ type DiagnosticListOptions struct {
 	ChangesetAuthorExternalUsername  core.Option[string]
 	ChangesetAuthorExternalUsernames core.Option[[]string]
 	// NOTE: severity is not an enum because queryparams parser doesn't support it.
-	Severity      core.Option[string]
-	Severities    core.Option[[]string]
-	RepoId        core.Option[int32]
-	RepoIds       core.Option[[]int32]
-	ReviewId      core.Option[int32]
-	ReviewIds     core.Option[[]int32]
-	DiagnosticIds core.Option[[]int32]
-	Diagnostics   PaginationArgs
-	Feedback      core.Option[FeedbackListOptions]
-	AgentId       core.Option[int32]
+	Severity                   core.Option[string]
+	Severities                 core.Option[[]string]
+	RepoId                     core.Option[int32]
+	RepoIds                    core.Option[[]int32]
+	ReviewId                   core.Option[int32]
+	ReviewIds                  core.Option[[]int32]
+	DiagnosticIds              core.Option[[]int32]
+	Diagnostics                PaginationArgs
+	Feedback                   core.Option[FeedbackListOptions]
+	AgentId                    core.Option[int32]
+	IncludeRejectedDiagnostics bool
 }
 
 type FeedbackListOptions struct {
@@ -171,7 +172,7 @@ func (s *reviewStore) Create(ctx context.Context, request goapi.Review) (goapi.R
 			return err
 		}
 
-		if err = createDiagnostics(ctx, tx, review.ReviewId, diagnosticPtrs); err != nil {
+		if err = createDiagnosticsWithFeedback(ctx, tx, review.ReviewId, diagnosticPtrs); err != nil {
 			return err
 		}
 
@@ -416,7 +417,7 @@ var diagnosticColumns = []string{
 	"created_at",
 }
 
-func createDiagnostics(ctx context.Context, tx *basestore.Store, reviewID int32, diagnostics []*goapi.ReviewDiagnostic) error {
+func createDiagnosticsWithFeedback(ctx context.Context, tx *basestore.Store, reviewID int32, diagnostics []*goapi.ReviewDiagnostic) error {
 	if len(diagnostics) == 0 {
 		return nil
 	}
@@ -426,7 +427,7 @@ func createDiagnostics(ctx context.Context, tx *basestore.Store, reviewID int32,
 	}
 
 	i := -1
-	return batch.WithInserterWithReturn(
+	err := batch.WithInserterWithReturn(
 		ctx,
 		tx.Handle(),
 		"agent_review_diagnostics",
@@ -440,6 +441,47 @@ func createDiagnostics(ctx context.Context, tx *basestore.Store, reviewID int32,
 		},
 		jsonInserter(ctx, diagnostics, "diagnostics"),
 	)
+	if err != nil {
+		return err
+	}
+
+	// Handle feedback for each diagnostic
+	for _, diagnostic := range diagnostics {
+		if diagnostic.Feedback != nil {
+			for i := range *diagnostic.Feedback {
+				(*diagnostic.Feedback)[i].DiagnosticId = pointers.Ptr(diagnostic.DiagnosticId)
+			}
+
+			if err := upsertFeedback(ctx, tx, *diagnostic.Feedback); err != nil {
+				return err
+			}
+		}
+	}
+
+	return nil
+}
+
+// upsertFeedback creates feedback entries for a diagnostic
+func upsertFeedback(ctx context.Context, tx *basestore.Store, feedback []goapi.ReviewDiagnosticFeedback) error {
+	if len(feedback) == 0 {
+		return nil
+	}
+
+	i := -1
+	return batch.WithInserterWithReturn(
+		ctx,
+		tx.Handle(),
+		"agent_review_diagnostic_feedback",
+		batch.MaxNumPostgresParameters,
+		[]string{"data"},
+		"",
+		feedbackColumns,
+		func(sc dbutil.Scanner) error {
+			i++
+			return scanReviewDiagnosticFeedbackInto(sc, &feedback[i], 0)
+		},
+		jsonInserter(ctx, feedback, "feedback"),
+	)
 }
 
 func (s *reviewStore) UpdateDiagnostic(ctx context.Context, diagnostic goapi.ReviewDiagnostic) (goapi.ReviewDiagnostic, error) {
@@ -581,6 +623,12 @@ func buildDiagnosticListConds(ctx context.Context, store *reviewStore, opts Diag
 		  FROM agent_runs WHERE agent_id = %s)`, agentId))
 	}
 
+	// Weird special case for rejected diagnostics so that the default doesn't include them
+	// TODO: we should default to including everything and not special casing this
+	if !opts.IncludeRejectedDiagnostics {
+		conds = append(conds, sqlf.Sprintf("(ard.quality != 'rejected' or ard.quality is null)"))
+	}
+
 	return conds, nil
 }
 
@@ -672,8 +720,8 @@ func (s *reviewStore) ListDiagnosticsSummary(ctx context.Context, opts Diagnosti
 
 	// 2. Severities query
 	severitiesQuery := sqlf.Sprintf(`
-		SELECT 
-			severity, 
+		SELECT
+			severity,
 			COUNT(*) as count
 		FROM agent_review_diagnostics ard
 		JOIN agent_reviews ar ON ard.review_id = ar.id
@@ -686,14 +734,14 @@ func (s *reviewStore) ListDiagnosticsSummary(ctx context.Context, opts Diagnosti
 	// 3. Rules query
 	rulesQuery := sqlf.Sprintf(`
 		WITH rule_names AS (
-			SELECT DISTINCT ON (rule_id) 
+			SELECT DISTINCT ON (rule_id)
 				rule_id,
 				data->>'display_name' as display_name
 			FROM agent_rule_revisions
 			WHERE data->>'display_name' IS NOT NULL AND data->>'display_name' != ''
 			ORDER BY rule_id, id DESC
 		)
-		SELECT 
+		SELECT
 			ard.rule_id,
 			rn.display_name,
 			COUNT(*) as count
@@ -708,8 +756,8 @@ func (s *reviewStore) ListDiagnosticsSummary(ctx context.Context, opts Diagnosti
 
 	// 4. Repositories query
 	repositoriesQuery := sqlf.Sprintf(`
-		SELECT 
-			ar.repo_id, 
+		SELECT
+			ar.repo_id,
 			COUNT(*) as count
 		FROM agent_review_diagnostics ard
 		JOIN agent_reviews ar ON ard.review_id = ar.id
@@ -721,7 +769,7 @@ func (s *reviewStore) ListDiagnosticsSummary(ctx context.Context, opts Diagnosti
 
 	// 5. Changeset authors query
 	authorsQuery := sqlf.Sprintf(`
-		SELECT 
+		SELECT
 			ac.data->'author'->>'external_username' as external_username,
 			ac.data->'author'->>'external_user_avatar_url' as external_user_avatar_url,
 			COUNT(*) as count
@@ -823,8 +871,8 @@ func (s *reviewStore) ListDiagnosticsSummary(ctx context.Context, opts Diagnosti
 		}
 
 		repoNamesQuery := sqlf.Sprintf(`
-			SELECT id, name 
-			FROM repo 
+			SELECT id, name
+			FROM repo
 			WHERE id = ANY(%s)
 		`, pq.Array(repoIds))
 
@@ -1073,23 +1121,10 @@ func (s *reviewStore) BulkCreateFeedback(ctx context.Context, feedback []goapi.R
 			return nil, errors.New("feedback id must be empty when creating a new feedback")
 		}
 	}
-	// Create all reactions in bulk using batch inserter
-	i := -1
-	err := batch.WithInserterWithReturn(
-		ctx,
-		s.Handle(),
-		"agent_review_diagnostic_feedback",
-		batch.MaxNumPostgresParameters,
-		[]string{"data"},
-		"",
-		feedbackColumns,
-		func(sc dbutil.Scanner) error {
-			i++
-			return scanReviewDiagnosticFeedbackInto(sc, &feedback[i], 0)
-		},
-		jsonInserter(ctx, feedback, "feedback"),
-	)
-
+	// Create all feedback in bulk using batch inserter
+	err := s.WithTransact(ctx, func(tx *basestore.Store) error {
+		return upsertFeedback(ctx, tx, feedback)
+	})
 	if err != nil {
 		return nil, err
 	}
diff --git a/internal/database/schema.json b/internal/database/schema.json
index 6924bc1e15c6..f91ce61309e3 100644
--- a/internal/database/schema.json
+++ b/internal/database/schema.json
@@ -4318,6 +4318,19 @@
           "GenerationExpression": "",
           "Comment": ""
         },
+        {
+          "Name": "quality",
+          "Index": 11,
+          "TypeName": "text",
+          "IsNullable": true,
+          "Default": "",
+          "CharacterMaximumLength": 0,
+          "IsIdentity": false,
+          "IdentityGeneration": "",
+          "IsGenerated": "ALWAYS",
+          "GenerationExpression": "(data -\u003e\u003e 'quality'::text)",
+          "Comment": ""
+        },
         {
           "Name": "review_id",
           "Index": 6,
@@ -4428,6 +4441,16 @@
           "ConstraintType": "",
           "ConstraintDefinition": ""
         },
+        {
+          "Name": "idx_agent_review_diagnostics_quality",
+          "IsPrimaryKey": false,
+          "IsUnique": false,
+          "IsExclusion": false,
+          "IsDeferrable": false,
+          "IndexDefinition": "CREATE INDEX idx_agent_review_diagnostics_quality ON agent_review_diagnostics USING btree (quality)",
+          "ConstraintType": "",
+          "ConstraintDefinition": ""
+        },
         {
           "Name": "idx_agent_review_diagnostics_rule_id",
           "IsPrimaryKey": false,
diff --git a/internal/database/schema.md b/internal/database/schema.md
index 310058ec512e..9363864ccc5c 100644
--- a/internal/database/schema.md
+++ b/internal/database/schema.md
@@ -373,10 +373,12 @@ Policies:
  rule_revision_id | integer                  |           |          | generated always as ((((data -> 'rule'::text) ->> 'revision_id'::text))::integer) stored
  rule_uri         | text                     |           |          | generated always as (((data -> 'rule'::text) ->> 'uri'::text)) stored
  severity         | text                     |           |          | generated always as ((data ->> 'severity'::text)) stored
+ quality          | text                     |           |          | generated always as ((data ->> 'quality'::text)) stored
 Indexes:
     "agent_review_diagnostics_pkey" PRIMARY KEY, btree (id)
     "agent_review_diagnostics_review_id" btree (review_id)
     "idx_agent_review_diagnostics_created_at" btree (created_at)
+    "idx_agent_review_diagnostics_quality" btree (quality)
     "idx_agent_review_diagnostics_rule_id" btree (rule_id)
     "idx_agent_review_diagnostics_severity" btree (severity)
 Foreign-key constraints:
diff --git a/internal/openapi/api/openapi.SourcegraphInternal.Latest.yaml b/internal/openapi/api/openapi.SourcegraphInternal.Latest.yaml
index f9a636a5e98b..5fdf8a7b1f29 100644
--- a/internal/openapi/api/openapi.SourcegraphInternal.Latest.yaml
+++ b/internal/openapi/api/openapi.SourcegraphInternal.Latest.yaml
@@ -3098,6 +3098,13 @@ components:
             Breakdown of tokens used in the prompt.
             Docs: https://platform.openai.com/docs/api-reference/chat/create
       description: Usage statistics for the completion request.
+    ConfusionLabel:
+      type: string
+      enum:
+        - true-positive
+        - false-positive
+        - true-negative
+        - false-negative
     ContextWindow:
       type: object
       required:
@@ -3818,6 +3825,12 @@ components:
           type: string
         codeCompletion:
           type: string
+    DiagnosticQuality:
+      type: string
+      enum:
+        - accepted
+        - rejected
+      description: Represents the quality assessment of a diagnostic based on feedback.
     DiffLocation:
       type: string
       enum:
@@ -4227,6 +4240,14 @@ components:
             - url
       allOf:
         - $ref: '#/components/schemas/MessageContentPart'
+    LikertLabel:
+      type: string
+      enum:
+        - strongly-agree
+        - agree
+        - neutral
+        - disagree
+        - strongly-disagree
     Links:
       type: object
       properties:
@@ -4291,7 +4312,11 @@ components:
       properties:
         repo:
           type: string
-          description: The Sourcegraph repository name. For example, 'github.com/sourcegraph/cody'.
+        repo_id:
+          type: integer
+          format: int32
+          nullable: true
+          description: The Sourcegraph repository ID. For example, '1'.
         path:
           type: string
           description: The path relative to the git root.
@@ -4318,7 +4343,11 @@ components:
       properties:
         repo:
           type: string
-          description: The Sourcegraph repository name. For example, 'github.com/sourcegraph/cody'.
+        repo_id:
+          type: integer
+          format: int32
+          nullable: true
+          description: The Sourcegraph repository ID. For example, '1'.
         path:
           type: string
           description: The path relative to the git root.
@@ -4873,6 +4902,11 @@ components:
         message:
           type: string
           description: The main message of the review comment.
+        quality:
+          allOf:
+            - $ref: '#/components/schemas/DiagnosticQuality'
+          nullable: true
+          description: (optional) The quality assessment of the diagnostic.
         feedback:
           type: array
           items:
@@ -4933,21 +4967,12 @@ components:
           format: int32
           nullable: true
         confusion_label:
-          type: string
-          enum:
-            - true-positive
-            - false-positive
-            - true-negative
-            - false-negative
+          allOf:
+            - $ref: '#/components/schemas/ConfusionLabel'
           nullable: true
         helpfulness_label:
-          type: string
-          enum:
-            - strongly-agree
-            - agree
-            - neutral
-            - disagree
-            - strongly-disagree
+          allOf:
+            - $ref: '#/components/schemas/LikertLabel'
           nullable: true
         comment:
           type: string
diff --git a/internal/openapi/goapi/BUILD.bazel b/internal/openapi/goapi/BUILD.bazel
index c460a6d37758..7d3a57d89eda 100644
--- a/internal/openapi/goapi/BUILD.bazel
+++ b/internal/openapi/goapi/BUILD.bazel
@@ -45,6 +45,7 @@ go_library(
         "model_completion_response.go",
         "model_completion_response_customization.go",
         "model_completion_usage.go",
+        "model_confusion_label.go",
         "model_context_window.go",
         "model_conversation.go",
         "model_conversation_message.go",
@@ -57,6 +58,7 @@ go_library(
         "model_create_chat_completions_stream_events.go",
         "model_created_at_fields.go",
         "model_default_models.go",
+        "model_diagnostic_quality.go",
         "model_diff_location.go",
         "model_error.go",
         "model_external_label.go",
@@ -73,6 +75,7 @@ go_library(
         "model_github_pull_request_review.go",
         "model_glob_filters.go",
         "model_glob_filters_customization.go",
+        "model_likert_label.go",
         "model_links.go",
         "model_list_agent_tasks_response.go",
         "model_list_external_repo_response.go",
@@ -108,6 +111,7 @@ go_library(
         "model_review_diagnostic.go",
         "model_review_diagnostic_customization.go",
         "model_review_diagnostic_evaluation_author.go",
+        "model_review_diagnostic_extensions.go",
         "model_review_diagnostic_feedback.go",
         "model_review_diagnostic_feedback_extensions.go",
         "model_review_diagnostic_feedback_page.go",
diff --git a/internal/openapi/goapi/compare.go b/internal/openapi/goapi/compare.go
index 08c086a57991..c76c43c52937 100644
--- a/internal/openapi/goapi/compare.go
+++ b/internal/openapi/goapi/compare.go
@@ -32,10 +32,18 @@ func (p *Location) Compare(other *Location) int {
 	if p == nil || other == nil {
 		return 0
 	}
-	byRepo := strings.Compare(p.Repo, other.Repo)
-	if byRepo != 0 {
-		return byRepo
+	if p.RepoId != nil && other.RepoId != nil {
+		byRepo := int(*p.RepoId - *other.RepoId)
+		if byRepo != 0 {
+			return byRepo
+		}
+	}
+
+	byRepoName := strings.Compare(p.Repo, other.Repo)
+	if byRepoName != 0 {
+		return byRepoName
 	}
+
 	byOID := strings.Compare(p.Oid, other.Oid)
 	if byOID != 0 {
 		return byOID
diff --git a/internal/openapi/goapi/model_confusion_label.go b/internal/openapi/goapi/model_confusion_label.go
new file mode 100644
index 000000000000..a88fadf0d466
--- /dev/null
+++ b/internal/openapi/goapi/model_confusion_label.go
@@ -0,0 +1,43 @@
+package goapi
+
+import (
+	"encoding/json"
+	"strconv"
+
+	"github.com/sourcegraph/sourcegraph/lib/errors"
+)
+
+type ConfusionLabel string
+
+const (
+	ConfusionLabelTruePositive  ConfusionLabel = "true-positive"
+	ConfusionLabelFalsePositive ConfusionLabel = "false-positive"
+	ConfusionLabelTrueNegative  ConfusionLabel = "true-negative"
+	ConfusionLabelFalseNegative ConfusionLabel = "false-negative"
+)
+
+// MarshalJSON marshals the enum as a quoted json string
+func (s ConfusionLabel) MarshalJSON() ([]byte, error) {
+	return []byte(strconv.Quote(string(s))), nil
+}
+
+func (s *ConfusionLabel) UnmarshalJSON(b []byte) error {
+	var j string
+	err := json.Unmarshal(b, &j)
+	if err != nil {
+		return err
+	}
+	switch j {
+	case "true-positive":
+		fallthrough
+	case "false-positive":
+		fallthrough
+	case "true-negative":
+		fallthrough
+	case "false-negative":
+		*s = ConfusionLabel(j)
+	default:
+		return errors.Newf("invalid ConfusionLabel: %s. Allowed values are true-positive, false-positive, true-negative, false-negative", j)
+	}
+	return nil
+}
diff --git a/internal/openapi/goapi/model_diagnostic_quality.go b/internal/openapi/goapi/model_diagnostic_quality.go
new file mode 100644
index 000000000000..e6e87383a13e
--- /dev/null
+++ b/internal/openapi/goapi/model_diagnostic_quality.go
@@ -0,0 +1,39 @@
+package goapi
+
+import (
+	"encoding/json"
+	"strconv"
+
+	"github.com/sourcegraph/sourcegraph/lib/errors"
+)
+
+// Represents the quality assessment of a diagnostic based on feedback.
+
+type DiagnosticQuality string
+
+const (
+	DiagnosticQualityAccepted DiagnosticQuality = "accepted"
+	DiagnosticQualityRejected DiagnosticQuality = "rejected"
+)
+
+// MarshalJSON marshals the enum as a quoted json string
+func (s DiagnosticQuality) MarshalJSON() ([]byte, error) {
+	return []byte(strconv.Quote(string(s))), nil
+}
+
+func (s *DiagnosticQuality) UnmarshalJSON(b []byte) error {
+	var j string
+	err := json.Unmarshal(b, &j)
+	if err != nil {
+		return err
+	}
+	switch j {
+	case "accepted":
+		fallthrough
+	case "rejected":
+		*s = DiagnosticQuality(j)
+	default:
+		return errors.Newf("invalid DiagnosticQuality: %s. Allowed values are accepted, rejected", j)
+	}
+	return nil
+}
diff --git a/internal/openapi/goapi/model_likert_label.go b/internal/openapi/goapi/model_likert_label.go
new file mode 100644
index 000000000000..2149ddb984f4
--- /dev/null
+++ b/internal/openapi/goapi/model_likert_label.go
@@ -0,0 +1,46 @@
+package goapi
+
+import (
+	"encoding/json"
+	"strconv"
+
+	"github.com/sourcegraph/sourcegraph/lib/errors"
+)
+
+type LikertLabel string
+
+const (
+	LikertLabelStronglyAgree    LikertLabel = "strongly-agree"
+	LikertLabelAgree            LikertLabel = "agree"
+	LikertLabelNeutral          LikertLabel = "neutral"
+	LikertLabelDisagree         LikertLabel = "disagree"
+	LikertLabelStronglyDisagree LikertLabel = "strongly-disagree"
+)
+
+// MarshalJSON marshals the enum as a quoted json string
+func (s LikertLabel) MarshalJSON() ([]byte, error) {
+	return []byte(strconv.Quote(string(s))), nil
+}
+
+func (s *LikertLabel) UnmarshalJSON(b []byte) error {
+	var j string
+	err := json.Unmarshal(b, &j)
+	if err != nil {
+		return err
+	}
+	switch j {
+	case "strongly-agree":
+		fallthrough
+	case "agree":
+		fallthrough
+	case "neutral":
+		fallthrough
+	case "disagree":
+		fallthrough
+	case "strongly-disagree":
+		*s = LikertLabel(j)
+	default:
+		return errors.Newf("invalid LikertLabel: %s. Allowed values are strongly-agree, agree, neutral, disagree, strongly-disagree", j)
+	}
+	return nil
+}
diff --git a/internal/openapi/goapi/model_location.go b/internal/openapi/goapi/model_location.go
index 9d7c10a647f2..2f4a73268553 100644
--- a/internal/openapi/goapi/model_location.go
+++ b/internal/openapi/goapi/model_location.go
@@ -4,10 +4,11 @@ package goapi
 // A location in a source file.
 
 type Location struct {
-
-	// The Sourcegraph repository name. For example, 'github.com/sourcegraph/cody'.
 	Repo string `json:"repo"`
 
+	// The Sourcegraph repository ID. For example, '1'.
+	RepoId *int32 `json:"repo_id,omitempty"`
+
 	// The path relative to the git root.
 	Path string `json:"path"`
 
diff --git a/internal/openapi/goapi/model_review_diagnostic.go b/internal/openapi/goapi/model_review_diagnostic.go
index 9f0d7d3aeee4..3003dd7ed87f 100644
--- a/internal/openapi/goapi/model_review_diagnostic.go
+++ b/internal/openapi/goapi/model_review_diagnostic.go
@@ -26,6 +26,9 @@ type ReviewDiagnostic struct {
 	// The main message of the review comment.
 	Message string `json:"message"`
 
+	// (optional) The quality assessment of the diagnostic.
+	Quality *DiagnosticQuality `json:"quality,omitempty"`
+
 	// (optional) The accumulated feedback for this diagnostic.
 	Feedback *[]ReviewDiagnosticFeedback `json:"feedback,omitempty"`
 
diff --git a/internal/openapi/goapi/model_review_diagnostic_extensions.go b/internal/openapi/goapi/model_review_diagnostic_extensions.go
new file mode 100644
index 000000000000..ac71d44ba09c
--- /dev/null
+++ b/internal/openapi/goapi/model_review_diagnostic_extensions.go
@@ -0,0 +1,27 @@
+package goapi
+
+type diagQuality int
+
+const (
+	diagQualityRejected diagQuality = iota
+	diagQualityUnclear
+	diagQualityAccepted
+)
+
+func fromQualityLabel(label *DiagnosticQuality) diagQuality {
+	if label == nil {
+		return diagQualityUnclear
+	}
+	switch *label {
+	case DiagnosticQualityAccepted:
+		return diagQualityAccepted
+	case DiagnosticQualityRejected:
+		return diagQualityRejected
+	default:
+		return diagQualityUnclear
+	}
+}
+
+func (d *ReviewDiagnostic) IsAcceptedQuality() bool {
+	return fromQualityLabel(d.Quality) >= diagQualityAccepted
+}
diff --git a/internal/openapi/goapi/model_review_diagnostic_feedback.go b/internal/openapi/goapi/model_review_diagnostic_feedback.go
index 3fca4cb7911d..afcefbf03209 100644
--- a/internal/openapi/goapi/model_review_diagnostic_feedback.go
+++ b/internal/openapi/goapi/model_review_diagnostic_feedback.go
@@ -1,13 +1,6 @@
 // Code generated by @sourcegraph/typespec-golang; DO NOT EDIT.
 package goapi
 
-import (
-	"encoding/json"
-	"strconv"
-
-	"github.com/sourcegraph/sourcegraph/lib/errors"
-)
-
 type ReviewDiagnosticFeedback struct {
 	Id *int32 `json:"id,omitempty"`
 
@@ -21,9 +14,9 @@ type ReviewDiagnosticFeedback struct {
 
 	ReactionId *int32 `json:"reaction_id,omitempty"`
 
-	ConfusionLabel *ReviewDiagnosticFeedbackConfusionLabel `json:"confusion_label,omitempty"`
+	ConfusionLabel *ConfusionLabel `json:"confusion_label,omitempty"`
 
-	HelpfulnessLabel *ReviewDiagnosticFeedbackHelpfulnessLabel `json:"helpfulness_label,omitempty"`
+	HelpfulnessLabel *LikertLabel `json:"helpfulness_label,omitempty"`
 
 	Comment *string `json:"comment,omitempty"`
 
@@ -35,76 +28,3 @@ type ReviewDiagnosticFeedback struct {
 	// ISO 8601 formatted DateTime.
 	UpdatedAt string `json:"updated_at"`
 }
-
-type ReviewDiagnosticFeedbackConfusionLabel string
-
-const (
-	ReviewDiagnosticFeedbackConfusionLabelTruePositive  ReviewDiagnosticFeedbackConfusionLabel = "true-positive"
-	ReviewDiagnosticFeedbackConfusionLabelFalsePositive ReviewDiagnosticFeedbackConfusionLabel = "false-positive"
-	ReviewDiagnosticFeedbackConfusionLabelTrueNegative  ReviewDiagnosticFeedbackConfusionLabel = "true-negative"
-	ReviewDiagnosticFeedbackConfusionLabelFalseNegative ReviewDiagnosticFeedbackConfusionLabel = "false-negative"
-)
-
-// MarshalJSON marshals the enum as a quoted json string
-func (s ReviewDiagnosticFeedbackConfusionLabel) MarshalJSON() ([]byte, error) {
-	return []byte(strconv.Quote(string(s))), nil
-}
-
-func (s *ReviewDiagnosticFeedbackConfusionLabel) UnmarshalJSON(b []byte) error {
-	var j string
-	err := json.Unmarshal(b, &j)
-	if err != nil {
-		return err
-	}
-	switch j {
-	case "true-positive":
-		fallthrough
-	case "false-positive":
-		fallthrough
-	case "true-negative":
-		fallthrough
-	case "false-negative":
-		*s = ReviewDiagnosticFeedbackConfusionLabel(j)
-	default:
-		return errors.Newf("invalid ReviewDiagnosticFeedbackConfusionLabel: %s. Allowed values are true-positive, false-positive, true-negative, false-negative", j)
-	}
-	return nil
-}
-
-type ReviewDiagnosticFeedbackHelpfulnessLabel string
-
-const (
-	ReviewDiagnosticFeedbackHelpfulnessLabelStronglyAgree    ReviewDiagnosticFeedbackHelpfulnessLabel = "strongly-agree"
-	ReviewDiagnosticFeedbackHelpfulnessLabelAgree            ReviewDiagnosticFeedbackHelpfulnessLabel = "agree"
-	ReviewDiagnosticFeedbackHelpfulnessLabelNeutral          ReviewDiagnosticFeedbackHelpfulnessLabel = "neutral"
-	ReviewDiagnosticFeedbackHelpfulnessLabelDisagree         ReviewDiagnosticFeedbackHelpfulnessLabel = "disagree"
-	ReviewDiagnosticFeedbackHelpfulnessLabelStronglyDisagree ReviewDiagnosticFeedbackHelpfulnessLabel = "strongly-disagree"
-)
-
-// MarshalJSON marshals the enum as a quoted json string
-func (s ReviewDiagnosticFeedbackHelpfulnessLabel) MarshalJSON() ([]byte, error) {
-	return []byte(strconv.Quote(string(s))), nil
-}
-
-func (s *ReviewDiagnosticFeedbackHelpfulnessLabel) UnmarshalJSON(b []byte) error {
-	var j string
-	err := json.Unmarshal(b, &j)
-	if err != nil {
-		return err
-	}
-	switch j {
-	case "strongly-agree":
-		fallthrough
-	case "agree":
-		fallthrough
-	case "neutral":
-		fallthrough
-	case "disagree":
-		fallthrough
-	case "strongly-disagree":
-		*s = ReviewDiagnosticFeedbackHelpfulnessLabel(j)
-	default:
-		return errors.Newf("invalid ReviewDiagnosticFeedbackHelpfulnessLabel: %s. Allowed values are strongly-agree, agree, neutral, disagree, strongly-disagree", j)
-	}
-	return nil
-}
diff --git a/internal/openapi/goapi/model_review_diagnostic_feedback_extensions.go b/internal/openapi/goapi/model_review_diagnostic_feedback_extensions.go
index 0c7e9ac4b3d5..800637f85f29 100644
--- a/internal/openapi/goapi/model_review_diagnostic_feedback_extensions.go
+++ b/internal/openapi/goapi/model_review_diagnostic_feedback_extensions.go
@@ -10,24 +10,24 @@ const (
 	reviewHelpfulnessStronglyAgree
 )
 
-func fromLabel(label ReviewDiagnosticFeedbackHelpfulnessLabel) reviewHelpfulness {
+func fromLabel(label LikertLabel) reviewHelpfulness {
 	switch label {
-	case ReviewDiagnosticFeedbackHelpfulnessLabelStronglyDisagree:
+	case LikertLabelStronglyDisagree:
 		return reviewHelpfulnessStronglyDisagree
-	case ReviewDiagnosticFeedbackHelpfulnessLabelDisagree:
+	case LikertLabelDisagree:
 		return reviewHelpfulnessDisagree
-	case ReviewDiagnosticFeedbackHelpfulnessLabelNeutral:
+	case LikertLabelNeutral:
 		return reviewHelpfulnessNeutral
-	case ReviewDiagnosticFeedbackHelpfulnessLabelAgree:
+	case LikertLabelAgree:
 		return reviewHelpfulnessAgree
-	case ReviewDiagnosticFeedbackHelpfulnessLabelStronglyAgree:
+	case LikertLabelStronglyAgree:
 		return reviewHelpfulnessStronglyAgree
 	default:
 		return reviewHelpfulnessNeutral
 	}
 }
 
-func (f *ReviewDiagnosticFeedback) HelpfulnessScoreExceeds(bar ReviewDiagnosticFeedbackHelpfulnessLabel) bool {
+func (f *ReviewDiagnosticFeedback) HelpfulnessScoreExceeds(bar LikertLabel) bool {
 	if f.HelpfulnessLabel == nil {
 		return false
 	}
diff --git a/internal/openapi/review.tsp b/internal/openapi/review.tsp
index 978a771f4fba..8c34bab42e5d 100644
--- a/internal/openapi/review.tsp
+++ b/internal/openapi/review.tsp
@@ -415,6 +415,11 @@ model ReviewDiagnostic {
      */
     message: string;
 
+    /**
+     * (optional) The quality assessment of the diagnostic.
+     */
+    quality?: DiagnosticQuality | null;
+
     /**
      * (optional) The accumulated feedback for this diagnostic.
      */
@@ -423,8 +428,35 @@ model ReviewDiagnostic {
     ...TimestampFields;
 }
 
-alias ConfusionLabel = "true-positive" | "false-positive" | "true-negative" | "false-negative";
-alias LikertLabel = "strongly-agree" | "agree" | "neutral" | "disagree" | "strongly-disagree";
+/**
+ * Represents the quality assessment of a diagnostic based on feedback.
+ */
+enum DiagnosticQuality {
+    /**
+     * The diagnostic appears to be correct and has been vverified.
+     */
+    Accepted: "accepted",
+
+    /**
+     * The diagnostic has been rejected as incorrect or not valuable.
+     */
+    Rejected: "rejected",
+}
+
+enum ConfusionLabel {
+    TruePositive: "true-positive",
+    FalsePositive: "false-positive",
+    TrueNegative: "true-negative",
+    FalseNegative: "false-negative",
+}
+
+enum LikertLabel {
+    StronglyAgree: "strongly-agree",
+    Agree: "agree",
+    Neutral: "neutral",
+    Disagree: "disagree",
+    StronglyDisagree: "strongly-disagree",
+}
 
 model ReviewDiagnosticFeedback {
     id?: int32 | null;
diff --git a/internal/openapi/shared.tsp b/internal/openapi/shared.tsp
index 34b50ef5bed7..1b13815ef3ca 100644
--- a/internal/openapi/shared.tsp
+++ b/internal/openapi/shared.tsp
@@ -238,10 +238,15 @@ model Range {
  */
 model Location {
     /**
-     * The Sourcegraph repository name. For example, 'github.com/sourcegraph/cody'.
+     * @deprecated use repo_id instead. The Sourcegraph repository name. For example, 'github.com/sourcegraph/cody'.
      */
     repo: string;
 
+    /**
+     * The Sourcegraph repository ID. For example, '1'.
+     */
+    repo_id?: int32 | null;
+
     /**
      * The path relative to the git root.
      */
diff --git a/internal/openapi/typescript/SourcegraphInternal.Latest.ts b/internal/openapi/typescript/SourcegraphInternal.Latest.ts
index 5599ebbeb3ac..52bddc20e418 100644
--- a/internal/openapi/typescript/SourcegraphInternal.Latest.ts
+++ b/internal/openapi/typescript/SourcegraphInternal.Latest.ts
@@ -1298,6 +1298,8 @@ export interface components {
              *     Docs: https://platform.openai.com/docs/api-reference/chat/create */
             prompt_tokens_details?: components["schemas"]["PromptTokensDetails"] | null;
         };
+        /** @enum {string} */
+        ConfusionLabel: "true-positive" | "false-positive" | "true-negative" | "false-negative";
         ContextWindow: {
             /** Format: int32 */
             maxInputTokens: number;
@@ -1668,6 +1670,11 @@ export interface components {
             fastChat: string;
             codeCompletion: string;
         };
+        /**
+         * @description Represents the quality assessment of a diagnostic based on feedback.
+         * @enum {string}
+         */
+        DiagnosticQuality: "accepted" | "rejected";
         /**
          * @description Represents the type of change at a location in the diff.
          * @enum {string}
@@ -1898,6 +1905,8 @@ export interface components {
              */
             type: "image_url";
         });
+        /** @enum {string} */
+        LikertLabel: "strongly-agree" | "agree" | "neutral" | "disagree" | "strongly-disagree";
         Links: {
             self?: string | null;
             first?: string | null;
@@ -1920,8 +1929,12 @@ export interface components {
         };
         /** @description A location in a source file. */
         Location: {
-            /** @description The Sourcegraph repository name. For example, 'github.com/sourcegraph/cody'. */
             repo: string;
+            /**
+             * Format: int32
+             * @description The Sourcegraph repository ID. For example, '1'.
+             */
+            repo_id?: number | null;
             /** @description The path relative to the git root. */
             path: string;
             /** @description The Git object ID (SHA) of the file. */
@@ -1936,8 +1949,12 @@ export interface components {
         };
         /** @description A location in a source file. */
         LocationUpdate: {
-            /** @description The Sourcegraph repository name. For example, 'github.com/sourcegraph/cody'. */
             repo?: string;
+            /**
+             * Format: int32
+             * @description The Sourcegraph repository ID. For example, '1'.
+             */
+            repo_id?: number | null;
             /** @description The path relative to the git root. */
             path?: string;
             /** @description The Git object ID (SHA) of the file. */
@@ -2211,6 +2228,8 @@ export interface components {
             diff_location?: components["schemas"]["DiffLocation"] | null;
             /** @description The main message of the review comment. */
             message: string;
+            /** @description (optional) The quality assessment of the diagnostic. */
+            quality?: components["schemas"]["DiagnosticQuality"] | null;
             /** @description (optional) The accumulated feedback for this diagnostic. */
             feedback?: components["schemas"]["ReviewDiagnosticFeedback"][] | null;
             /** @description ISO 8601 formatted DateTime. */
@@ -2238,10 +2257,8 @@ export interface components {
             message_id?: number | null;
             /** Format: int32 */
             reaction_id?: number | null;
-            /** @enum {string|null} */
-            confusion_label?: "true-positive" | "false-positive" | "true-negative" | "false-negative" | null;
-            /** @enum {string|null} */
-            helpfulness_label?: "strongly-agree" | "agree" | "neutral" | "disagree" | "strongly-disagree" | null;
+            confusion_label?: components["schemas"]["ConfusionLabel"] | null;
+            helpfulness_label?: components["schemas"]["LikertLabel"] | null;
             comment?: string | null;
             author?: components["schemas"]["ReviewDiagnosticEvaluationAuthor"] | null;
             /** @description ISO 8601 formatted DateTime. */
diff --git a/internal/review/BUILD.bazel b/internal/review/BUILD.bazel
index c7b6b272c3c2..dbcef53b0415 100644
--- a/internal/review/BUILD.bazel
+++ b/internal/review/BUILD.bazel
@@ -31,6 +31,7 @@ go_library(
         "//internal/gitserver/gitdomain",
         "//internal/llmapitelemetry",
         "//internal/openapi/goapi",
+        "//internal/review/diffutils",
         "//internal/review/grader",
         "//internal/rule",
         "//internal/telemetry",
diff --git a/internal/review/changed_lines.go b/internal/review/changed_lines.go
index 9f450930cfa6..cb5d0c3802b3 100644
--- a/internal/review/changed_lines.go
+++ b/internal/review/changed_lines.go
@@ -4,6 +4,7 @@ import (
 	sglog "github.com/sourcegraph/log"
 
 	"github.com/sourcegraph/sourcegraph/internal/openapi/goapi"
+	"github.com/sourcegraph/sourcegraph/internal/review/diffutils"
 	"github.com/sourcegraph/sourcegraph/lib/pointers"
 )
 
@@ -102,12 +103,12 @@ func (c *changedLinesCache) getChangedLines(file *changedFile) fileChangedLines
 
 	baseChangedLines := make(map[int32]bool)
 	headChangedLines := make(map[int32]bool)
-	diffLines := parseDiff(file.Diff)
+	diffLines := diffutils.ParseDiff(file.Diff)
 	for _, diffLine := range diffLines {
-		if diffLine.changeType == headAdded {
-			headChangedLines[diffLine.lineNumber] = true
-		} else if diffLine.changeType == baseRemoved {
-			baseChangedLines[diffLine.lineNumber] = true
+		if diffLine.IsAdded() {
+			headChangedLines[diffLine.LineNumber] = true
+		} else if diffLine.IsRemoved() {
+			baseChangedLines[diffLine.LineNumber] = true
 		}
 	}
 
diff --git a/internal/review/chunker_test.go b/internal/review/chunker_test.go
index 3cc103b9dabf..5f382d68d0e4 100644
--- a/internal/review/chunker_test.go
+++ b/internal/review/chunker_test.go
@@ -70,8 +70,6 @@ file: src/auth/login.test.ts
 		})
 		require.NoError(t, err)
 		autogold.Expect(`chunk 1: Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
-Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
-file: b/internal/review/service_test.go
 file: b/internal/review/testdata/TestE2E/prompt-injection.golden
 file: b/internal/review/applicable_rules.go
 
@@ -79,50 +77,49 @@ chunk 2: API and Configuration: Changes to API models, handlers and configuratio
 file: b/internal/openapi/goapi/model_agent_program.go
 file: b/internal/openapi/goapi/model_agent_program_update.go
 
-chunk 3: Rule Engine Core: Core changes to the rule engine implementation, removing built-in rules functionality and updating the rule service
+chunk 3: Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
+file: b/internal/review/service_test.go
+file: b/internal/review/testdata/TestE2E.recording.yaml
+
+chunk 4: Rule Engine Core: Core changes to the rule engine implementation, removing built-in rules functionality and updating the rule service
 file: b/internal/rule/BUILD.bazel
 file: /dev/null
 
-chunk 4: API and Configuration: Changes to API models, handlers and configuration related to removing built-in rules and updating rule specifications
+chunk 5: API and Configuration: Changes to API models, handlers and configuration related to removing built-in rules and updating rule specifications
 file: b/internal/openapi/goapi/model_review_request_configuration.go
 file: b/internal/openapi/agent.tsp
 
-chunk 5: Rule Engine Core: Core changes to the rule engine implementation, removing built-in rules functionality and updating the rule service
-file: /dev/null
-file: b/internal/rule/service.go
-file: b/internal/rule/service_test.go
-
 chunk 6: API Documentation and Schema: OpenAPI schema updates and TypeScript definitions reflecting the removal of built-in rules
 file: b/internal/openapi/api/openapi.SourcegraphInternal.Latest.yaml
 file: b/internal/openapi/typescript/SourcegraphInternal.Latest.ts
 
-chunk 7: Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
-file: b/internal/review/testdata/TestE2E.recording.yaml
-file: b/internal/review/testdata/TestE2E.recording.yaml
-
-chunk 8: Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
-file: b/internal/review/testdata/TestE2E.recording.yaml
-file: b/internal/review/testdata/TestE2E.recording.yaml
+chunk 7: Rule Engine Core: Core changes to the rule engine implementation, removing built-in rules functionality and updating the rule service
+file: /dev/null
+file: b/internal/rule/service.go
+file: b/internal/rule/service_test.go
 
-chunk 9: API and Configuration: Changes to API models, handlers and configuration related to removing built-in rules and updating rule specifications
+chunk 8: API and Configuration: Changes to API models, handlers and configuration related to removing built-in rules and updating rule specifications
 file: b/cmd/frontend/internal/agentapi/handler_agent_test.go
 file: b/cmd/frontend/internal/agentapi/handler_webhook_github_app.go
 file: b/cmd/frontend/internal/reviewapi/handler_review_test.go
 
-chunk 10: Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
+chunk 9: Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
 file: b/internal/review/testdata/TestE2E.recording.yaml
 file: b/internal/review/testdata/TestE2E/balanced.golden
 file: b/internal/review/testdata/TestE2E/high-bar.golden
 
-chunk 11: Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
-file: b/internal/review/testdata/TestE2E.recording.yaml
-
-chunk 12: Rule Engine Core: Core changes to the rule engine implementation, removing built-in rules functionality and updating the rule service
+chunk 10: Rule Engine Core: Core changes to the rule engine implementation, removing built-in rules functionality and updating the rule service
 file: b/internal/openapi/rule.tsp
 
-chunk 13: API and Configuration: Changes to API models, handlers and configuration related to removing built-in rules and updating rule specifications
+chunk 11: API and Configuration: Changes to API models, handlers and configuration related to removing built-in rules and updating rule specifications
 file: b/internal/openapi/review.tsp
 
+chunk 12: Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
+file: b/internal/review/testdata/TestE2E.recording.yaml
+
+chunk 13: Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
+file: b/internal/review/testdata/TestE2E.recording.yaml
+
 chunk 14: Review System Tests: Updates to review system test files and golden files to reflect the removal of built-in rules
 file: b/internal/review/testdata/TestE2E.recording.yaml
 
@@ -277,67 +274,6 @@ func findFileDiff(t *testing.T, fileDiffs []*diff.FileDiff, path string) *diff.F
 	return nil
 }
 
-func TestPrintHunk(t *testing.T) {
-	unifiedDiff := `diff --git a/client/web-sveltekit/src/lib/mode.ts b/client/web-sveltekit/src/lib/mode.ts
-index acd4358303e..06db377fad2 100644
---- a/client/web-sveltekit/src/lib/mode.ts
-+++ b/client/web-sveltekit/src/lib/mode.ts
-@@ -20,14 +20,15 @@ export const enum Mode {
-     CODE_INTELLIGENCE_ENABLED = 1 << 11,
-     SITE_ADMIN = 1 << 12,
-     NOTEBOOKS_ENABLED = 1 << 13,
-     SEARCH_CONTEXTS_ENABLED = 1 << 14,
-     NEEDS_REPOSITORY_CONFIGURATION = 1 << 15,
--    SEARCH_INSTANCE_ENABLED = 1 << 16,
-+    SEARCH_INSTANCE_ENABLED = 1 << 16, // TODO: remove this
-     AGENTS_ENABLED = 1 << 17,
-     CODY_PRO = 1 << 18,
--    CODY_FREE = 1 << 19
-+    CODY_FREE = 1 << 19,
-+    CODE_INTELLIGENCE_ENABLED_DEV = 1 << 20,
- }
-
- /**
-  * Returns the combined mode of the given context.
-  */
-
-`
-	fileDiff, err := diff.ParseFileDiff([]byte(unifiedDiff))
-	require.NoError(t, err)
-	obtained, err := printDiff(fileDiff)
-	require.NoError(t, err)
-	// This assertion exists to catch unintended regressions in how we format
-	// diffs with explicit line numbers for removed/added lines. It's very
-	// imporant that the line numbers are correct because they influence where
-	// we report diagnostics.
-	require.Equal(t, `diff --git a/client/web-sveltekit/src/lib/mode.ts b/client/web-sveltekit/src/lib/mode.ts
-index acd4358303e..06db377fad2 100644
---- a/client/web-sveltekit/src/lib/mode.ts
-+++ b/client/web-sveltekit/src/lib/mode.ts
-@@ -20,14 +20,15 @@ export const enum Mode {
-HEAD L20:      CODE_INTELLIGENCE_ENABLED = 1 << 11,
-HEAD L21:      SITE_ADMIN = 1 << 12,
-HEAD L22:      NOTEBOOKS_ENABLED = 1 << 13,
-HEAD L23:      SEARCH_CONTEXTS_ENABLED = 1 << 14,
-HEAD L24:      NEEDS_REPOSITORY_CONFIGURATION = 1 << 15,
-BASE L25: -    SEARCH_INSTANCE_ENABLED = 1 << 16,
-HEAD L25: +    SEARCH_INSTANCE_ENABLED = 1 << 16, // TODO: remove this
-HEAD L26:      AGENTS_ENABLED = 1 << 17,
-HEAD L27:      CODY_PRO = 1 << 18,
-BASE L28: -    CODY_FREE = 1 << 19
-HEAD L28: +    CODY_FREE = 1 << 19,
-HEAD L29: +    CODE_INTELLIGENCE_ENABLED_DEV = 1 << 20,
-HEAD L30:  }
-HEAD L31: 
-HEAD L32:  /**
-HEAD L33:   * Returns the combined mode of the given context.
-HEAD L34:   */
-HEAD L35: 
-HEAD L36: 
-\ No newline at end of file
-`, string(obtained))
-}
-
 func newTestingChangedFile(
 	t *testing.T,
 	filepath string,
diff --git a/internal/review/classifier/feedback_classifier.go b/internal/review/classifier/feedback_classifier.go
index ff0fb2087623..f6901421a255 100644
--- a/internal/review/classifier/feedback_classifier.go
+++ b/internal/review/classifier/feedback_classifier.go
@@ -112,17 +112,17 @@ type xmlReaction struct {
 }
 
 type feedbackFromReaction struct {
-	Helpfulness goapi.ReviewDiagnosticFeedbackHelpfulnessLabel `json:"helpfulness_label" jsonschema:"enum=strongly-agree,enum=agree,enum=disagree,enum=strongly-disagree" jsonschema_description:"The sentiment of the reaction to the diagnostic according to the likert scale"`
-	Confidence  string                                         `json:"confidence" jsonschema:"enum=high,enum=medium,enum=low" jsonschema_description:"How confident you are about your assessment of the reaction, either high, medium, or low"`
-	Summary     string                                         `json:"summary" jsonschema_description:"A summary of the response to the diagnostic. Only include a summary if the message content is complex or contains many responses"`
+	Helpfulness goapi.LikertLabel `json:"helpfulness_label" jsonschema:"enum=strongly-agree,enum=agree,enum=disagree,enum=strongly-disagree" jsonschema_description:"The sentiment of the reaction to the diagnostic according to the likert scale"`
+	Confidence  string            `json:"confidence" jsonschema:"enum=high,enum=medium,enum=low" jsonschema_description:"How confident you are about your assessment of the reaction, either high, medium, or low"`
+	Summary     string            `json:"summary" jsonschema_description:"A summary of the response to the diagnostic. Only include a summary if the message content is complex or contains many responses"`
 }
 
-func (f feedbackFromReaction) ConfusionLabel() *goapi.ReviewDiagnosticFeedbackConfusionLabel {
+func (f feedbackFromReaction) ConfusionLabel() *goapi.ConfusionLabel {
 	switch f.Helpfulness {
 	case "strongly-agree", "agree":
-		return pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive)
+		return pointers.Ptr(goapi.ConfusionLabelTruePositive)
 	default:
-		return pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelFalsePositive)
+		return pointers.Ptr(goapi.ConfusionLabelFalsePositive)
 	}
 }
 
diff --git a/internal/review/classifier/feedback_classifier_test.go b/internal/review/classifier/feedback_classifier_test.go
index 896205ae4fc7..c034159411a0 100644
--- a/internal/review/classifier/feedback_classifier_test.go
+++ b/internal/review/classifier/feedback_classifier_test.go
@@ -19,8 +19,8 @@ func TestClassifyFeedbackFromMessage(t *testing.T) {
 		name       string
 		message    goapi.ConversationMessage
 		diagnostic goapi.ReviewDiagnostic
-		wantLabel  goapi.ReviewDiagnosticFeedbackHelpfulnessLabel
-		wantType   goapi.ReviewDiagnosticFeedbackConfusionLabel
+		wantLabel  goapi.LikertLabel
+		wantType   goapi.ConfusionLabel
 		wantNone   bool
 	}{
 		{
@@ -113,8 +113,8 @@ func TestClassifyFeedbackFromReaction(t *testing.T) {
 		name       string
 		reaction   goapi.ConversationMessageReaction
 		diagnostic goapi.ReviewDiagnostic
-		wantLabel  goapi.ReviewDiagnosticFeedbackHelpfulnessLabel
-		wantType   goapi.ReviewDiagnosticFeedbackConfusionLabel
+		wantLabel  goapi.LikertLabel
+		wantType   goapi.ConfusionLabel
 		wantNone   bool
 	}{
 		{
diff --git a/internal/review/deduplicate.go b/internal/review/deduplicate.go
index 988c95616981..9936e9fc247e 100644
--- a/internal/review/deduplicate.go
+++ b/internal/review/deduplicate.go
@@ -145,9 +145,10 @@ func getFileSnippetsForDiagnostics(ctx context.Context, db database.DB, client g
 
 	// Group diagnostics by repo+commit+file to minimize git server calls
 	type fileKey struct {
-		repo api.RepoName
-		oid  string
-		path string
+		repoId api.RepoID
+		repo   api.RepoName
+		oid    string
+		path   string
 	}
 
 	byFile := make(map[fileKey][]goapi.ReviewDiagnostic)
@@ -156,9 +157,10 @@ func getFileSnippetsForDiagnostics(ctx context.Context, db database.DB, client g
 			continue
 		}
 		key := fileKey{
-			repo: api.RepoName(d.Location.Repo),
-			oid:  d.Location.Oid,
-			path: d.Location.Path,
+			repoId: api.RepoID(pointers.Deref(d.Location.RepoId, 0)),
+			repo:   api.RepoName(d.Location.Repo),
+			oid:    d.Location.Oid,
+			path:   d.Location.Path,
 		}
 		byFile[key] = append(byFile[key], d)
 	}
@@ -170,7 +172,7 @@ func getFileSnippetsForDiagnostics(ctx context.Context, db database.DB, client g
 	// for now we assume that any one file is under the memory limit of the server instance and that
 	// all of the diagnostic snippets fit into the memory limit
 	for key, fileDiagnostics := range byFile {
-		repo, err := db.Repos().GetByName(ctx, key.repo)
+		repo, err := db.Repos().Get(ctx, key.repoId)
 		if err != nil {
 			return nil, err
 		}
diff --git a/internal/review/deduplicate_test.go b/internal/review/deduplicate_test.go
index aabefe8056c3..9d442464dc6e 100644
--- a/internal/review/deduplicate_test.go
+++ b/internal/review/deduplicate_test.go
@@ -247,9 +247,10 @@ func TestFormatDeduplicatePrompt(t *testing.T) {
 					Severity: "warning",
 					Message:  "test message",
 					Location: goapi.Location{
-						Repo: "test/repo",
-						Path: "main.go",
-						Oid:  "abc123",
+						Repo:   "test/repo",
+						RepoId: pointers.Ptr(int32(2)),
+						Path:   "main.go",
+						Oid:    "abc123",
 						Range: &goapi.Range{
 							Start: &goapi.Position{Line: 10},
 							End:   &goapi.Position{Line: 12},
@@ -273,9 +274,10 @@ func TestFormatDeduplicatePrompt(t *testing.T) {
 						Severity: "error",
 						Message:  "old message",
 						Location: goapi.Location{
-							Repo: "test/repo",
-							Path: "main.go",
-							Oid:  "def456",
+							Repo:   "test/repo",
+							RepoId: pointers.Ptr(int32(2)),
+							Path:   "main.go",
+							Oid:    "def456",
 							Range: &goapi.Range{
 								Start: &goapi.Position{Line: 5},
 								End:   &goapi.Position{Line: 7},
@@ -298,9 +300,10 @@ func TestFormatDeduplicatePrompt(t *testing.T) {
 						Severity: "info",
 						Message:  "style suggestion",
 						Location: goapi.Location{
-							Repo: "test/repo",
-							Path: "utils.go",
-							Oid:  "def456",
+							Repo:   "test/repo",
+							RepoId: pointers.Ptr(int32(2)),
+							Path:   "utils.go",
+							Oid:    "def456",
 							Range: &goapi.Range{
 								Start: &goapi.Position{Line: 15},
 								End:   &goapi.Position{Line: 18},
@@ -342,9 +345,10 @@ func TestFormatDeduplicatePrompt(t *testing.T) {
 					Severity: "warning",
 					Message:  "test message",
 					Location: goapi.Location{
-						Repo: "test/repo",
-						Path: "main.go",
-						Oid:  "abc123",
+						Repo:   "test/repo",
+						RepoId: pointers.Ptr(int32(2)),
+						Path:   "main.go",
+						Oid:    "abc123",
 					},
 				},
 				snippet: []byte("var logger = log.New(os.Stdout, \"INFO: \", log.Ldate|log.Ltime)"),
@@ -380,16 +384,17 @@ func TestGetFileSnippetsForDiagnostics(t *testing.T) {
 
 	db := dbmocks.NewMockDB()
 	repos := dbmocks.NewMockRepoStore()
-	repos.GetByNameFunc.SetDefaultReturn(&types.Repo{ID: 42, Name: reponame}, nil)
+	repos.GetFunc.SetDefaultReturn(&types.Repo{ID: 42, Name: reponame}, nil)
 	db.ReposFunc.SetDefaultReturn(repos)
 
 	t.Run("single diagnostic with range", func(t *testing.T) {
 		diagnostics := []goapi.ReviewDiagnostic{
 			{
 				Location: goapi.Location{
-					Repo: string(reponame),
-					Oid:  string(headOID),
-					Path: "file1.go",
+					Repo:   string(reponame),
+					RepoId: pointers.Ptr(int32(1)),
+					Oid:    string(headOID),
+					Path:   "file1.go",
 					Range: &goapi.Range{
 						Start: &goapi.Position{Line: 5},
 						End:   &goapi.Position{Line: 7},
@@ -408,9 +413,10 @@ func TestGetFileSnippetsForDiagnostics(t *testing.T) {
 		diagnostics := []goapi.ReviewDiagnostic{
 			{
 				Location: goapi.Location{
-					Repo: string(reponame),
-					Oid:  string(headOID),
-					Path: "file1.go",
+					Repo:   string(reponame),
+					RepoId: pointers.Ptr(int32(1)),
+					Oid:    string(headOID),
+					Path:   "file1.go",
 					Range: &goapi.Range{
 						Start: &goapi.Position{Line: 2},
 					},
@@ -418,9 +424,10 @@ func TestGetFileSnippetsForDiagnostics(t *testing.T) {
 			},
 			{
 				Location: goapi.Location{
-					Repo: string(reponame),
-					Oid:  string(headOID),
-					Path: "file1.go",
+					Repo:   string(reponame),
+					RepoId: pointers.Ptr(int32(1)),
+					Oid:    string(headOID),
+					Path:   "file1.go",
 					Range: &goapi.Range{
 						Start: &goapi.Position{Line: 10},
 					},
@@ -439,9 +446,10 @@ func TestGetFileSnippetsForDiagnostics(t *testing.T) {
 		diagnostics := []goapi.ReviewDiagnostic{
 			{
 				Location: goapi.Location{
-					Repo: string(reponame),
-					Oid:  string(headOID),
-					Path: "file2.go",
+					Repo:   string(reponame),
+					RepoId: pointers.Ptr(int32(1)),
+					Oid:    string(headOID),
+					Path:   "file2.go",
 				},
 			},
 		}
@@ -456,9 +464,10 @@ func TestGetFileSnippetsForDiagnostics(t *testing.T) {
 		diagnostics := []goapi.ReviewDiagnostic{
 			{
 				Location: goapi.Location{
-					Repo: string(reponame),
-					Oid:  string(headOID),
-					Path: "file1.go",
+					Repo:   string(reponame),
+					RepoId: pointers.Ptr(int32(1)),
+					Oid:    string(headOID),
+					Path:   "file1.go",
 					Range: &goapi.Range{
 						Start: &goapi.Position{Line: 0},
 					},
@@ -477,9 +486,10 @@ func TestGetFileSnippetsForDiagnostics(t *testing.T) {
 		diagnostics := []goapi.ReviewDiagnostic{
 			{
 				Location: goapi.Location{
-					Repo: string(reponame),
-					Oid:  string(headOID),
-					Path: "file1.go",
+					Repo:   string(reponame),
+					RepoId: pointers.Ptr(int32(1)),
+					Oid:    string(headOID),
+					Path:   "file1.go",
 					Range: &goapi.Range{
 						Start: &goapi.Position{Line: 14},
 					},
diff --git a/internal/review/diff_chunker.go b/internal/review/diff_chunker.go
index 2b02e446a3e6..7cc1676a2794 100644
--- a/internal/review/diff_chunker.go
+++ b/internal/review/diff_chunker.go
@@ -15,33 +15,12 @@ import (
 	"github.com/sourcegraph/sourcegraph/internal/completions/tokenizer"
 	"github.com/sourcegraph/sourcegraph/internal/completions/types"
 	"github.com/sourcegraph/sourcegraph/internal/openapi/goapi"
+	"github.com/sourcegraph/sourcegraph/internal/review/diffutils"
+	"github.com/sourcegraph/sourcegraph/lib/core"
 	"github.com/sourcegraph/sourcegraph/lib/errors"
 	"github.com/sourcegraph/sourcegraph/lib/pointers"
 )
 
-type changeType string
-
-const (
-	baseUnmodified changeType = "base-unmodified"
-	baseRemoved    changeType = "base-removed"
-	headUnmodified changeType = "head-unmodified"
-	headAdded      changeType = "head-added"
-)
-
-type revision string
-
-const (
-	HEAD revision = "HEAD"
-	BASE revision = "BASE"
-)
-
-type diffLine struct {
-	lineNumber  int32
-	lineContent string
-	hunkIndex   int
-	changeType  changeType
-}
-
 type diffChunker struct {
 	logger             sglog.Logger
 	completions        llmutils.LLMChatClient
@@ -242,7 +221,7 @@ func (c *diffChunker) FormatPrompt(chunk fileChunk) (string, error) {
 		if file, ok := f.(*changedFile); ok {
 			// TODO: format line numbers more explicitly so that the LLM doesn't have to
 			// perform math with the hunk headers.
-			printedDiff, err := printDiff(file.Diff)
+			printedDiff, err := diffutils.PrintDiff(file.Diff, core.None[diffutils.DiffOptions]())
 			if err != nil {
 				return "", errors.Wrapf(err, "printDiff(path=%s)", file.Diff.NewName)
 			}
@@ -327,87 +306,6 @@ func formatRulePrompt(rule goapi.RuleRevision) string {
 </RULE>`, rule.DisplayName, strings.Join(lines, "\n"))
 }
 
-func parseDiff(fileDiff *diff.FileDiff) []diffLine {
-	diffLines := []diffLine{}
-
-	for i, hunk := range fileDiff.Hunks {
-		newStartLine := hunk.NewStartLine
-		oldStartLine := hunk.OrigStartLine
-
-		for line := range strings.SplitSeq(string(hunk.Body), "\n") {
-			if strings.HasPrefix(line, "+") {
-				diffLines = append(diffLines, diffLine{
-					lineNumber:  newStartLine,
-					lineContent: line,
-					hunkIndex:   i,
-					changeType:  headAdded,
-				})
-				newStartLine++
-			} else if strings.HasPrefix(line, "-") {
-				diffLines = append(diffLines, diffLine{
-					lineNumber:  oldStartLine,
-					lineContent: line,
-					hunkIndex:   i,
-					changeType:  baseRemoved,
-				})
-				oldStartLine++
-			} else {
-				diffLines = append(diffLines, diffLine{
-					lineNumber:  newStartLine,
-					lineContent: line,
-					hunkIndex:   i,
-					// Since the line is unmodified, we can use either HEAD or BASE.
-					// We choose HEAD because it's the most recent revision.
-					changeType: headUnmodified,
-				})
-				// Unmodified lines bump up the counter for both old and new files.
-				newStartLine++
-				oldStartLine++
-			}
-		}
-	}
-
-	return diffLines
-}
-
-func printDiff(fileDiff *diff.FileDiff) ([]byte, error) {
-	// Copy fileDiff so we can modify it.
-	diffCopy := *fileDiff
-	diffCopy.Hunks = make([]*diff.Hunk, len(fileDiff.Hunks))
-	for i, hunk := range fileDiff.Hunks {
-		hunkCopy := *hunk
-		diffCopy.Hunks[i] = &hunkCopy
-	}
-
-	diffLines := parseDiff(&diffCopy)
-
-	// Produce the modified lines in the unified diff format.
-	var modifiedLines []string
-	lastHunkIndex := -1
-	for _, line := range diffLines {
-		if line.hunkIndex != lastHunkIndex {
-			if len(modifiedLines) > 0 {
-				diffCopy.Hunks[lastHunkIndex].Body = []byte(strings.Join(modifiedLines, "\n"))
-			}
-			lastHunkIndex = line.hunkIndex
-			modifiedLines = []string{}
-		}
-
-		revision, err := line.changeType.Revision()
-		if err != nil {
-			return nil, err
-		}
-		modifiedLines = append(modifiedLines, fmt.Sprintf("%s L%d: %s", revision, line.lineNumber, line.lineContent))
-	}
-
-	// Process the last hunk.
-	if len(modifiedLines) > 0 && lastHunkIndex >= 0 {
-		diffCopy.Hunks[lastHunkIndex].Body = []byte(strings.Join(modifiedLines, "\n"))
-	}
-
-	return diff.PrintFileDiff(&diffCopy)
-}
-
 func stableAdditionalContextKeys(request goapi.ReviewRequest) []string {
 	if request.Config == nil || request.Config.AdditionalContext == nil {
 		return []string{}
@@ -419,26 +317,3 @@ func stableAdditionalContextKeys(request goapi.ReviewRequest) []string {
 	sort.Strings(keys)
 	return keys
 }
-
-func (c changeType) IsAdded() bool {
-	return c == headAdded
-}
-
-func (c changeType) IsRemoved() bool {
-	return c == baseRemoved
-}
-
-func (c changeType) IsUnmodified() bool {
-	return c == baseUnmodified || c == headUnmodified
-}
-
-func (c changeType) Revision() (revision, error) {
-	switch c {
-	case headAdded, headUnmodified:
-		return HEAD, nil
-	case baseRemoved, baseUnmodified:
-		return BASE, nil
-	default:
-		return "", errors.Newf("unknown change type: %s", c)
-	}
-}
diff --git a/internal/review/diffutils/BUILD.bazel b/internal/review/diffutils/BUILD.bazel
new file mode 100644
index 000000000000..77f1988c1f27
--- /dev/null
+++ b/internal/review/diffutils/BUILD.bazel
@@ -0,0 +1,24 @@
+load("@io_bazel_rules_go//go:def.bzl", "go_library")
+load("//dev:go_defs.bzl", "go_test")
+
+go_library(
+    name = "diffutils",
+    srcs = ["print_diff.go"],
+    importpath = "github.com/sourcegraph/sourcegraph/internal/review/diffutils",
+    visibility = ["//:__subpackages__"],
+    deps = [
+        "//lib/core",
+        "@com_github_sourcegraph_go_diff//diff",
+    ],
+)
+
+go_test(
+    name = "diffutils_test",
+    srcs = ["print_diff_test.go"],
+    embed = [":diffutils"],
+    deps = [
+        "//lib/core",
+        "@com_github_sourcegraph_go_diff//diff",
+        "@com_github_stretchr_testify//require",
+    ],
+)
diff --git a/internal/review/diffutils/print_diff.go b/internal/review/diffutils/print_diff.go
new file mode 100644
index 000000000000..43267bf7d2c8
--- /dev/null
+++ b/internal/review/diffutils/print_diff.go
@@ -0,0 +1,179 @@
+package diffutils
+
+import (
+	"bytes"
+	"fmt"
+	"strings"
+
+	"github.com/sourcegraph/go-diff/diff"
+
+	"github.com/sourcegraph/sourcegraph/lib/core"
+)
+
+func ParseDiff(fileDiff *diff.FileDiff) []DiffLine {
+	diffLines := []DiffLine{}
+
+	for i, hunk := range fileDiff.Hunks {
+		newStartLine := hunk.NewStartLine
+		oldStartLine := hunk.OrigStartLine
+
+		for line := range strings.SplitSeq(string(hunk.Body), "\n") {
+			if strings.HasPrefix(line, "+") {
+				diffLines = append(diffLines, DiffLine{
+					LineNumber:  newStartLine,
+					LineContent: line,
+					hunkIndex:   i,
+					changeType:  headAdded,
+				})
+				newStartLine++
+			} else if strings.HasPrefix(line, "-") {
+				diffLines = append(diffLines, DiffLine{
+					LineNumber:  oldStartLine,
+					LineContent: line,
+					hunkIndex:   i,
+					changeType:  baseRemoved,
+				})
+				oldStartLine++
+			} else {
+				diffLines = append(diffLines, DiffLine{
+					LineNumber:  newStartLine,
+					LineContent: line,
+					hunkIndex:   i,
+					// Since the line is unmodified, we can use either HEAD or BASE.
+					// We choose HEAD because it's the most recent revision.
+					changeType: headUnmodified,
+				})
+				// Unmodified lines bump up the counter for both old and new files.
+				newStartLine++
+				oldStartLine++
+			}
+		}
+	}
+
+	return diffLines
+}
+
+type DiffOptions struct {
+	// LineNumber specifies the center line number to focus the diff around
+	LineNumber int32
+	// UseOriginalLine determines whether LineNumber refers to the original (BASE) or new (HEAD) line numbers
+	UseOriginalLine bool
+	// WindowSize is the number of context lines to show before and after the specified line
+	// If WindowSize is 0, the entire diff is returned
+	WindowSize int
+}
+
+func PrintDiff(fileDiff *diff.FileDiff, maybeOpts core.Option[DiffOptions]) ([]byte, error) {
+	// Copy fileDiff so we can modify it.
+	diffCopy := *fileDiff
+	diffCopy.Hunks = make([]*diff.Hunk, len(fileDiff.Hunks))
+	for i, hunk := range fileDiff.Hunks {
+		hunkCopy := *hunk
+		diffCopy.Hunks[i] = &hunkCopy
+	}
+
+	diffLines := ParseDiff(&diffCopy)
+
+	// If no options provided or window size is 0, process the entire diff
+	opts, ok := maybeOpts.Get()
+	if !ok || opts.WindowSize == 0 {
+		return processDiffLines(&diffCopy, diffLines)
+	}
+
+	// Filter lines based on the window
+	var filteredLines []DiffLine
+	for _, line := range diffLines {
+		lineNum := line.LineNumber
+		// Check if the line is within the window
+		if lineNum >= opts.LineNumber-int32(opts.WindowSize) &&
+			lineNum <= opts.LineNumber+int32(opts.WindowSize) {
+			filteredLines = append(filteredLines, line)
+		}
+	}
+
+	// If no lines match the window, return empty diff
+	if len(filteredLines) == 0 {
+		return []byte{}, nil
+	}
+
+	// Process the filtered lines using the same formatting as the full diff
+	return processDiffLines(&diffCopy, filteredLines)
+}
+
+func processDiffLines(diffCopy *diff.FileDiff, diffLines []DiffLine) ([]byte, error) {
+	var modifiedLines []string
+	lastHunkIndex := -1
+	for _, line := range diffLines {
+		if line.hunkIndex != lastHunkIndex {
+			if len(modifiedLines) > 0 {
+				diffCopy.Hunks[lastHunkIndex].Body = []byte(strings.Join(modifiedLines, "\n"))
+			}
+			lastHunkIndex = line.hunkIndex
+			modifiedLines = []string{}
+		}
+
+		modifiedLines = append(modifiedLines, line.String())
+	}
+
+	// Process the last hunk.
+	if len(modifiedLines) > 0 && lastHunkIndex >= 0 {
+		diffCopy.Hunks[lastHunkIndex].Body = []byte(strings.Join(modifiedLines, "\n"))
+	}
+
+	diffBytes, err := diff.PrintFileDiff(diffCopy)
+	if err != nil {
+		return nil, err
+	}
+
+	return bytes.ReplaceAll(diffBytes, []byte("\\ No newline at end of file\n"), []byte{}), nil
+}
+
+type DiffLine struct {
+	LineNumber  int32
+	LineContent string
+	hunkIndex   int
+	changeType  changeType
+}
+
+func (d DiffLine) String() string {
+	return strings.TrimSpace(fmt.Sprintf("%s L%d: %s", d.Revision(), d.LineNumber, d.LineContent))
+}
+
+type changeType string
+
+const (
+	baseUnmodified changeType = "base-unmodified"
+	baseRemoved    changeType = "base-removed"
+	headUnmodified changeType = "head-unmodified"
+	headAdded      changeType = "head-added"
+)
+
+func (d DiffLine) IsAdded() bool {
+	return d.changeType == headAdded
+}
+
+func (d DiffLine) IsRemoved() bool {
+	return d.changeType == baseRemoved
+}
+
+func (d DiffLine) IsUnmodified() bool {
+	return d.changeType == baseUnmodified || d.changeType == headUnmodified
+}
+
+func (d DiffLine) Revision() revision {
+	switch d.changeType {
+	case headAdded, headUnmodified:
+		return HEAD
+	case baseRemoved, baseUnmodified:
+		return BASE
+	default:
+		return "UNKNOWN"
+	}
+}
+
+type revision string
+
+const (
+	HEAD revision = "HEAD"
+	BASE revision = "BASE"
+)
diff --git a/internal/review/diffutils/print_diff_test.go b/internal/review/diffutils/print_diff_test.go
new file mode 100644
index 000000000000..b243bdc63ccf
--- /dev/null
+++ b/internal/review/diffutils/print_diff_test.go
@@ -0,0 +1,129 @@
+package diffutils
+
+import (
+	"testing"
+
+	"github.com/sourcegraph/go-diff/diff"
+	"github.com/stretchr/testify/require"
+
+	"github.com/sourcegraph/sourcegraph/lib/core"
+)
+
+var unifiedDiff = `diff --git a/client/web-sveltekit/src/lib/mode.ts b/client/web-sveltekit/src/lib/mode.ts
+index acd4358303e..06db377fad2 100644
+--- a/client/web-sveltekit/src/lib/mode.ts
++++ b/client/web-sveltekit/src/lib/mode.ts
+@@ -20,14 +20,15 @@ export const enum Mode {
+     CODE_INTELLIGENCE_ENABLED = 1 << 11,
+     SITE_ADMIN = 1 << 12,
+     NOTEBOOKS_ENABLED = 1 << 13,
+     SEARCH_CONTEXTS_ENABLED = 1 << 14,
+     NEEDS_REPOSITORY_CONFIGURATION = 1 << 15,
+-    SEARCH_INSTANCE_ENABLED = 1 << 16,
++    SEARCH_INSTANCE_ENABLED = 1 << 16, // TODO: remove this
+     AGENTS_ENABLED = 1 << 17,
+     CODY_PRO = 1 << 18,
+-    CODY_FREE = 1 << 19
++    CODY_FREE = 1 << 19,
++    CODE_INTELLIGENCE_ENABLED_DEV = 1 << 20,
+ }
+
+ /**
+  * Returns the combined mode of the given context.
+  */
+
+`
+
+func TestPrintHunk(t *testing.T) {
+	fileDiff, err := diff.ParseFileDiff([]byte(unifiedDiff))
+	require.NoError(t, err)
+	obtained, err := PrintDiff(fileDiff, core.None[DiffOptions]())
+	require.NoError(t, err)
+	// This assertion exists to catch unintended regressions in how we format
+	// diffs with explicit line numbers for removed/added lines. It's very
+	// imporant that the line numbers are correct because they influence where
+	// we report diagnostics.
+	require.Equal(t, `diff --git a/client/web-sveltekit/src/lib/mode.ts b/client/web-sveltekit/src/lib/mode.ts
+index acd4358303e..06db377fad2 100644
+--- a/client/web-sveltekit/src/lib/mode.ts
++++ b/client/web-sveltekit/src/lib/mode.ts
+@@ -20,14 +20,15 @@ export const enum Mode {
+HEAD L20:      CODE_INTELLIGENCE_ENABLED = 1 << 11,
+HEAD L21:      SITE_ADMIN = 1 << 12,
+HEAD L22:      NOTEBOOKS_ENABLED = 1 << 13,
+HEAD L23:      SEARCH_CONTEXTS_ENABLED = 1 << 14,
+HEAD L24:      NEEDS_REPOSITORY_CONFIGURATION = 1 << 15,
+BASE L25: -    SEARCH_INSTANCE_ENABLED = 1 << 16,
+HEAD L25: +    SEARCH_INSTANCE_ENABLED = 1 << 16, // TODO: remove this
+HEAD L26:      AGENTS_ENABLED = 1 << 17,
+HEAD L27:      CODY_PRO = 1 << 18,
+BASE L28: -    CODY_FREE = 1 << 19
+HEAD L28: +    CODY_FREE = 1 << 19,
+HEAD L29: +    CODE_INTELLIGENCE_ENABLED_DEV = 1 << 20,
+HEAD L30:  }
+HEAD L31:
+HEAD L32:  /**
+HEAD L33:   * Returns the combined mode of the given context.
+HEAD L34:   */
+HEAD L35:
+HEAD L36:
+`, string(obtained))
+}
+
+func TestPrintDiffWithOptions(t *testing.T) {
+	fileDiff, err := diff.ParseFileDiff([]byte(unifiedDiff))
+	require.NoError(t, err)
+
+	tests := []struct {
+		name     string
+		opts     DiffOptions
+		expected string
+	}{
+		{
+			name: "window around original removed line",
+			opts: DiffOptions{
+				LineNumber:      25,
+				UseOriginalLine: true,
+				WindowSize:      1,
+			},
+			expected: `diff --git a/client/web-sveltekit/src/lib/mode.ts b/client/web-sveltekit/src/lib/mode.ts
+index acd4358303e..06db377fad2 100644
+--- a/client/web-sveltekit/src/lib/mode.ts
++++ b/client/web-sveltekit/src/lib/mode.ts
+@@ -20,14 +20,15 @@ export const enum Mode {
+HEAD L24:      NEEDS_REPOSITORY_CONFIGURATION = 1 << 15,
+BASE L25: -    SEARCH_INSTANCE_ENABLED = 1 << 16,
+HEAD L25: +    SEARCH_INSTANCE_ENABLED = 1 << 16, // TODO: remove this
+HEAD L26:      AGENTS_ENABLED = 1 << 17,
+`,
+		},
+		{
+			name: "window around new added line",
+			opts: DiffOptions{
+				LineNumber:      29,
+				UseOriginalLine: false,
+				WindowSize:      2,
+			},
+			expected: `diff --git a/client/web-sveltekit/src/lib/mode.ts b/client/web-sveltekit/src/lib/mode.ts
+index acd4358303e..06db377fad2 100644
+--- a/client/web-sveltekit/src/lib/mode.ts
++++ b/client/web-sveltekit/src/lib/mode.ts
+@@ -20,14 +20,15 @@ export const enum Mode {
+HEAD L27:      CODY_PRO = 1 << 18,
+BASE L28: -    CODY_FREE = 1 << 19
+HEAD L28: +    CODY_FREE = 1 << 19,
+HEAD L29: +    CODE_INTELLIGENCE_ENABLED_DEV = 1 << 20,
+HEAD L30:  }
+HEAD L31:
+`,
+		},
+	}
+
+	for _, tc := range tests {
+		t.Run(tc.name, func(t *testing.T) {
+			obtained, err := PrintDiff(fileDiff, core.Some(tc.opts))
+			require.NoError(t, err)
+			require.Equal(t, tc.expected, string(obtained))
+		})
+	}
+}
diff --git a/internal/review/grader/BUILD.bazel b/internal/review/grader/BUILD.bazel
index 769a06159d14..1fcaef9a78f7 100644
--- a/internal/review/grader/BUILD.bazel
+++ b/internal/review/grader/BUILD.bazel
@@ -7,14 +7,15 @@ go_library(
     importpath = "github.com/sourcegraph/sourcegraph/internal/review/grader",
     visibility = ["//:__subpackages__"],
     deps = [
-        "//internal/api",
         "//internal/completions/llmutils",
         "//internal/completions/types",
-        "//internal/database",
-        "//internal/gitserver",
         "//internal/openapi/goapi",
+        "//internal/review/diffutils",
+        "//lib/core",
         "//lib/errors",
         "//lib/pointers",
+        "@com_github_sourcegraph_go_diff//diff",
+        "@com_github_sourcegraph_log//:log",
     ],
 )
 
@@ -24,16 +25,16 @@ go_test(
     data = glob(["testdata/**"]),
     embed = [":grader"],
     deps = [
-        "//internal/api",
         "//internal/completions/client/anthropic",
         "//internal/completions/llmutils",
-        "//internal/database/dbmocks",
-        "//internal/gitserver/gitservermocks",
         "//internal/openapi/goapi",
         "//internal/tenant/tenanttest",
-        "//internal/types",
+        "//lib/core",
         "//lib/pointers",
         "@com_github_hexops_autogold_v2//:autogold",
+        "@com_github_sourcegraph_go_diff//diff",
+        "@com_github_sourcegraph_log//:log",
+        "@com_github_stretchr_testify//assert",
         "@com_github_stretchr_testify//require",
     ],
 )
diff --git a/internal/review/grader/grader.go b/internal/review/grader/grader.go
index c9a7894d2735..391779ead8c5 100644
--- a/internal/review/grader/grader.go
+++ b/internal/review/grader/grader.go
@@ -2,19 +2,18 @@ package grader
 
 import (
 	"context"
-	"encoding/json"
 	"encoding/xml"
 	"fmt"
-	"io"
-	"strings"
 	"time"
 
-	"github.com/sourcegraph/sourcegraph/internal/api"
+	"github.com/sourcegraph/go-diff/diff"
+	sglog "github.com/sourcegraph/log"
+
 	"github.com/sourcegraph/sourcegraph/internal/completions/llmutils"
 	"github.com/sourcegraph/sourcegraph/internal/completions/types"
-	"github.com/sourcegraph/sourcegraph/internal/database"
-	"github.com/sourcegraph/sourcegraph/internal/gitserver"
 	"github.com/sourcegraph/sourcegraph/internal/openapi/goapi"
+	"github.com/sourcegraph/sourcegraph/internal/review/diffutils"
+	"github.com/sourcegraph/sourcegraph/lib/core"
 	"github.com/sourcegraph/sourcegraph/lib/errors"
 	"github.com/sourcegraph/sourcegraph/lib/pointers"
 )
@@ -22,7 +21,12 @@ import (
 var GRADER_MODEL = "anthropic::2024-10-22::claude-3-7-sonnet-extended-thinking"
 
 type Grader interface {
-	Grade(ctx context.Context, rule goapi.Rule, diagnostic goapi.ReviewDiagnostic, cache map[string]FileContent) (goapi.ReviewDiagnosticFeedback, error)
+	Grade(ctx context.Context, logger sglog.Logger, rule goapi.Rule, diagnostic goapi.ReviewDiagnostic, fileContent FileContent) (GradedDiagnostic, error)
+}
+
+type GradedDiagnostic struct {
+	Feedback      goapi.ReviewDiagnosticFeedback
+	NewDiagnostic core.Option[goapi.ReviewDiagnostic]
 }
 
 // CodeWindowSize is the number of lines of code to include above and below the
@@ -35,62 +39,101 @@ const (
 )
 
 type FileContent interface {
-	GetContent() []byte
-	GetPath() string
+	GetDiff() *diff.FileDiff
+	GetLanguage() string
 }
+
 type llmJudgeGrader struct {
 	llm            llmutils.LLMChatClient
-	git            gitserver.Client
-	db             database.DB
 	codeWindowSize CodeWindowSize
 }
 
-func NewGrader(llm llmutils.LLMChatClient, git gitserver.Client, db database.DB, fileWindowSize CodeWindowSize) Grader {
+func NewGrader(llm llmutils.LLMChatClient, fileWindowSize CodeWindowSize) Grader {
 	return &llmJudgeGrader{
 		llm:            llm,
-		git:            git,
-		db:             db,
 		codeWindowSize: fileWindowSize,
 	}
 }
 
 type xmlDiagnostic struct {
-	XMLName           xml.Name `xml:"diagnostic"`
-	Content           string   `xml:"code_snippet"`
-	DiagnosticMessage string   `xml:"diagnostic_message"`
-	RuleInstruction   string   `xml:"rule_instruction"`
+	XMLName         xml.Name          `xml:"diagnostic"`
+	Content         CDATAContent      `xml:"git_diff"`
+	Language        string            `xml:"language"`
+	Diagnostic      xmlDiagnosticInfo `xml:"diagnostic_info"`
+	RuleInstruction string            `xml:"rule_instruction"`
+}
+
+type xmlDiagnosticInfo struct {
+	XMLName   xml.Name `xml:"diagnostic_info"`
+	Message   string   `xml:"message"`
+	StartLine int32    `xml:"start_line"`
 }
 
-func (g *llmJudgeGrader) Grade(ctx context.Context, rule goapi.Rule, diagnostic goapi.ReviewDiagnostic, cache map[string]FileContent) (goapi.ReviewDiagnosticFeedback, error) {
+// CDATAContent can wrap strings that contain XML special characters so that they are not escaped when marshalled to XML
+// This makes the recordings easier to read as well as using fewer tokens for the LLM
+type CDATAContent string
 
+// MarshalXML implements the XML Marshaler interface
+func (c CDATAContent) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
+	return e.EncodeElement(struct {
+		CData string `xml:",cdata"`
+	}{string(c)}, start)
+}
+
+func (g *llmJudgeGrader) Grade(ctx context.Context, logger sglog.Logger, rule goapi.Rule, diagnostic goapi.ReviewDiagnostic, diff FileContent) (GradedDiagnostic, error) {
 	if pointers.DerefZero(diagnostic.DiffLocation) == goapi.DiffLocationHallucinated {
-		return goapi.ReviewDiagnosticFeedback{
-			HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelStronglyDisagree),
-			ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelFalsePositive),
-			Comment:          pointers.Ptr(fmt.Sprintf("The diagnostic file path %s does not exist in the diff", diagnostic.Location.Path)),
+		return GradedDiagnostic{
+			Feedback: goapi.ReviewDiagnosticFeedback{
+				HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelStronglyDisagree),
+				ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelFalsePositive),
+				Comment:          pointers.Ptr(fmt.Sprintf("The diagnostic file path %s does not exist in the diff", diagnostic.Location.Path)),
+			},
 		}, nil
 	}
 
 	// Get the code snippet for the diagnostic
-	snippet, err := g.getCodeSnippet(ctx, diagnostic, cache)
+	opts := core.None[diffutils.DiffOptions]()
+	if diagnostic.Location.Range != nil {
+		opts = core.Some(diffutils.DiffOptions{
+			LineNumber:      int32(diagnostic.Location.Range.Start.Line),
+			UseOriginalLine: true,
+			WindowSize:      int(g.codeWindowSize),
+		})
+	}
+	snippet, err := diffutils.PrintDiff(diff.GetDiff(), opts)
 	if err != nil {
-		return goapi.ReviewDiagnosticFeedback{}, errors.Wrap(err, "getCodeSnippet")
+		return GradedDiagnostic{}, errors.Wrap(err, "getCodeSnippet")
 	}
 
 	// Create XML diagnostic for LLM input
 	xmlDiag := xmlDiagnostic{
-		Content:           string(snippet),
-		DiagnosticMessage: diagnostic.Message,
-		RuleInstruction:   *rule.LatestRevision.Instruction,
+		Content:  CDATAContent(snippet),
+		Language: diff.GetLanguage(),
+		Diagnostic: xmlDiagnosticInfo{
+			Message:   diagnostic.Message,
+			StartLine: diagnostic.Location.Range.Start.Line,
+		},
+		RuleInstruction: *rule.LatestRevision.Instruction,
 	}
 
 	// Generate prompt from XML
 	prompt, err := generateGradePrompt(xmlDiag)
 	if err != nil {
-		return goapi.ReviewDiagnosticFeedback{}, errors.Wrap(err, "generateGradePrompt")
+		return GradedDiagnostic{}, errors.Wrap(err, "generateGradePrompt")
 	}
 
-	request := types.CompletionRequestParameters{
+	params := types.InternalCompletionParams{
+		Timeout: pointers.Ptr(1 * time.Minute),
+		Client: types.ClientInformation{
+			Version:       types.LatestSupportedCompletionsStreamAPIVersion,
+			ClientName:    "review-diagnostic-grader",
+			ClientVersion: "1.0.0",
+		},
+		InteractionURI: fmt.Sprintf("agentrun:review-diagnostic-grader.%d-%d", diagnostic.ReviewId, diagnostic.DiagnosticId),
+	}
+
+	output := GradedDiagnostic{}
+	return llmutils.Loop(ctx, g.llm, types.CompletionRequestParameters{
 		RequestedModel:    types.RawUnverifiedModelRef(GRADER_MODEL),
 		Stream:            pointers.Ptr(false),
 		MaxTokensToSample: 4000,
@@ -104,92 +147,10 @@ func (g *llmJudgeGrader) Grade(ctx context.Context, rule goapi.Rule, diagnostic
 				Content: types.NewContentPartString(prompt),
 			},
 		},
-		Tools: []goapi.AssistantToolsFunction{gradeDiagnosticTool()},
-	}
-	response, err := g.llm.ChatSync(ctx, request, types.InternalCompletionParams{
-		Timeout: pointers.Ptr(1 * time.Minute),
-		Client: types.ClientInformation{
-			Version:       types.LatestSupportedCompletionsStreamAPIVersion,
-			ClientName:    "review-diagnostic-grader",
-			ClientVersion: "1.0.0",
-		},
-		InteractionURI: fmt.Sprintf("agentrun:review-diagnostic-grader.%d-%d", diagnostic.ReviewId, diagnostic.DiagnosticId),
-	})
-	if err != nil {
-		return goapi.ReviewDiagnosticFeedback{}, errors.Wrap(err, "llm.ChatSync")
-	}
-
-	// Parse response
-	feedback, err := parseGradeDiagnosticTool(response)
-	if err != nil {
-		return goapi.ReviewDiagnosticFeedback{}, errors.Wrap(err, "parseGradeDiagnosticTool")
-	}
-
-	return goapi.ReviewDiagnosticFeedback{
-		HelpfulnessLabel: feedback.HelpfulnessLabel(),
-		ConfusionLabel:   feedback.ConfusionLabel(),
-		Comment:          &feedback.Summary,
-		Author: &goapi.ReviewDiagnosticEvaluationAuthor{
-			Type:     "llm_judge",
-			LlmJudge: &GRADER_MODEL,
-		},
-	}, nil
-}
-
-func (g *llmJudgeGrader) getCodeSnippet(ctx context.Context, diagnostic goapi.ReviewDiagnostic, cache map[string]FileContent) ([]byte, error) {
-	// Try to get content from provided cache first
-	if cache != nil {
-		if fileContent := cache[diagnostic.Location.Path]; fileContent != nil {
-			content := fileContent.GetContent()
-			if content == nil {
-				return nil, errors.New("file content is nil")
-			}
-			return extractLines(content, diagnostic.Location.Range, g.codeWindowSize), nil
-		}
-	}
-
-	// Fall back to git server if file not found in provided files
-	repo, err := g.db.Repos().GetByName(ctx, api.RepoName(diagnostic.Location.Repo))
-	if err != nil {
-		return nil, errors.Wrap(err, "get repo")
-	}
-
-	// Get the file reader from git server
-	reader, err := g.git.NewFileReader(ctx, repo.ID, api.CommitID(diagnostic.Location.Oid), diagnostic.Location.Path)
-	if err != nil {
-		return nil, errors.Wrap(err, "new file reader")
-	}
-	defer reader.Close()
-
-	// Read the file content
-	content, err := io.ReadAll(reader)
-	if err != nil {
-		return nil, errors.Wrap(err, "read file")
-	}
-
-	return extractLines(content, diagnostic.Location.Range, g.codeWindowSize), nil
-}
-
-// extractLines extracts the relevant lines from content based on the diagnostic range and window size
-func extractLines(content []byte, rng *goapi.Range, window CodeWindowSize) []byte {
-	windowSize := int32(window)
-	startLine := rng.Start.Line
-	endLine := startLine
-	if rng.End != nil {
-		endLine = rng.End.Line
-	}
-
-	// Add some context lines before and after
-	startLine = max(1, startLine-windowSize)
-	endLine = endLine + windowSize
-
-	// Split content into lines and extract the relevant range
-	lines := strings.Split(string(content), "\n")
-	if int(endLine) > len(lines) {
-		endLine = int32(len(lines))
-	}
-
-	return []byte(strings.Join(lines[startLine-1:endLine], "\n"))
+	}, params, []llmutils.Tool{
+		rewriteDiagnosticMessageTool(logger, diagnostic, &output),
+		relocateDiagnosticTool(logger, diagnostic, &output),
+	}, gradeDiagnosticTool(&output))
 }
 
 func generateGradePrompt(diagnostic xmlDiagnostic) (string, error) {
@@ -200,76 +161,84 @@ func generateGradePrompt(diagnostic xmlDiagnostic) (string, error) {
 	return string(xmlBytes), nil
 }
 
-func gradeDiagnosticTool() goapi.AssistantToolsFunction {
-	return goapi.AssistantToolsFunction{
-		Type: "function",
-		Function: goapi.FunctionObject{
-			Name:        "evaluate_diagnostic",
-			Description: "Evaluate whether a diagnostic is a valid violation of a rule",
-			Parameters: map[string]any{
-				"type": "object",
-				"required": []string{
-					"summary",
-					"helpfulness_label",
-				},
-				"properties": map[string]any{
-					"summary": map[string]any{
-						"type":        "string",
-						"description": "A summary of why the diagnostic is or is not a valid violation",
-					},
-					"helpfulness_label": map[string]any{
-						"type":        "string",
-						"enum":        []string{"strongly-agree", "agree", "disagree", "strongly-disagree"},
-						"description": "Whether the diagnostic is a valid violation of the rule",
-					},
-				},
-			},
-		},
-	}
-}
-
 type gradeDiagnostic struct {
-	Helpfulness string `json:"helpfulness_label"`
-	Summary     string `json:"summary"`
+	Helpfulness goapi.LikertLabel `json:"helpfulness_label" jsonschema:"enum=strongly-agree,enum=agree,enum=neutral,enum=disagree,enum=strongly-disagree" jsonschema_description:"The sentiment of the reaction to the diagnostic according to the likert scale"`
+	Summary     string            `json:"summary" jsonschema_description:"A summary of why the diagnostic is or is not a valid violation"`
 }
 
-func (g gradeDiagnostic) ConfusionLabel() *goapi.ReviewDiagnosticFeedbackConfusionLabel {
+func (g gradeDiagnostic) ConfusionLabel() *goapi.ConfusionLabel {
 	switch g.Helpfulness {
 	case "strongly-agree", "agree":
-		return pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive)
+		return pointers.Ptr(goapi.ConfusionLabelTruePositive)
 	default:
-		return pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelFalsePositive)
+		return pointers.Ptr(goapi.ConfusionLabelFalsePositive)
 	}
 }
 
-func (g gradeDiagnostic) HelpfulnessLabel() *goapi.ReviewDiagnosticFeedbackHelpfulnessLabel {
-	switch g.Helpfulness {
-	case "strongly-agree":
-		return pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelStronglyAgree)
-	case "agree":
-		return pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelAgree)
-	case "disagree":
-		return pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelDisagree)
-	case "strongly-disagree":
-		return pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelStronglyDisagree)
-	default:
-		return nil
-	}
+func gradeDiagnosticTool(output *GradedDiagnostic) llmutils.OneShotTool[gradeDiagnostic, GradedDiagnostic] {
+	return llmutils.NewOneShotTool(
+		"evaluate_diagnostic",
+		"Evaluate whether a diagnostic is a valid violation of a rule",
+		func(feedback gradeDiagnostic) (GradedDiagnostic, error) {
+			output.Feedback = goapi.ReviewDiagnosticFeedback{
+				HelpfulnessLabel: &feedback.Helpfulness,
+				ConfusionLabel:   feedback.ConfusionLabel(),
+				Comment:          &feedback.Summary,
+				Author: &goapi.ReviewDiagnosticEvaluationAuthor{
+					Type:     "llm_judge",
+					LlmJudge: &GRADER_MODEL,
+				},
+			}
+			return *output, nil
+		},
+	)
 }
 
-func parseGradeDiagnosticTool(response goapi.CompletionResponse) (gradeDiagnostic, error) {
-	if response.ToolCalls == nil {
-		return gradeDiagnostic{}, errors.New("no tool calls for grade diagnostic")
-	}
+type rewriteDiagnosticMessage struct {
+	NewMessage string `json:"newMessage" jsonschema_description:"The rewritten diagnostic message that better describes the issue"`
+	Reasoning  string `json:"reasoning" jsonschema_description:"A brief explanation of why the message was rewritten"`
+}
 
-	toolCall := (*response.ToolCalls)[0]
-	var feedback gradeDiagnostic
-	err := json.Unmarshal([]byte(toolCall.Function.Arguments), &feedback)
-	if err != nil {
-		return gradeDiagnostic{}, errors.Wrapf(err, "json.Unmarshal(gradeDiagnostic, arguments=%s)", toolCall.Function.Arguments)
-	}
+func rewriteDiagnosticMessageTool(logger sglog.Logger, originalDiagnostic goapi.ReviewDiagnostic, destination *GradedDiagnostic) llmutils.Tool {
+	return llmutils.NewTool(
+		"rewrite_diagnostic_message",
+		"Rewrite the diagnostic message to more accurately describe the issue",
+		func(rewrite rewriteDiagnosticMessage) (string, error) {
+			logger.Info("rewriting diagnostic message", sglog.String("original", originalDiagnostic.Message), sglog.String("update", rewrite.NewMessage))
+			diagnosticToUpdate := originalDiagnostic
+			if diagnostic, ok := destination.NewDiagnostic.Get(); ok {
+				diagnosticToUpdate = diagnostic
+			}
+			diagnosticToUpdate.Message = rewrite.NewMessage
+			destination.NewDiagnostic = core.Some(diagnosticToUpdate)
 
-	return feedback, nil
+			return "Successfully rewrote diagnostic message", nil
+		},
+	)
+}
+
+type relocateDiagnostic struct {
+	NewStartLine int32  `json:"newStartLine" jsonschema_description:"The corrected start line number for the diagnostic"`
+	Reasoning    string `json:"reasoning" jsonschema_description:"A brief explanation of why the location was updated"`
+}
+
+func relocateDiagnosticTool(logger sglog.Logger, originalDiagnostic goapi.ReviewDiagnostic, destination *GradedDiagnostic) llmutils.Tool {
+	return llmutils.NewTool(
+		"relocate_diagnostic",
+		"Update the location of the diagnostic if it is incorrectly placed",
+		func(relocate relocateDiagnostic) (string, error) {
+			logger.Info("relocating diagnostic", sglog.Int32("original", originalDiagnostic.Location.Range.Start.Line), sglog.Int32("update", relocate.NewStartLine))
+			diagnosticToUpdate := originalDiagnostic
+			// If the diagnostic has already been rewritten, use the rewritten version
+			if diagnostic, ok := destination.NewDiagnostic.Get(); ok {
+				diagnosticToUpdate = diagnostic
+			}
+			diagnosticToUpdate.Location.Range.Start.Line = relocate.NewStartLine
+			destination.NewDiagnostic = core.Some(diagnosticToUpdate)
+
+			return "Successfully relocated diagnostic", nil
+		},
+	)
 }
 
 const gradeDiagnosticSystemPrompt = `You are Cody, an expert AI code reviewer specializing in evaluating whether code review diagnostics are valid violations of rules.
@@ -288,5 +257,15 @@ You should classify the diagnostic as:
 
 Provide a brief summary explaining your reasoning for the classification.
 
-Your response can only be submitted via the evaluate_diagnostic tool.
+IMPORTANT: Only use the rewrite_diagnostic_message tool if one of these conditions are met:
+1. The diff contains a violation of the rule, but the diagnostic message does not correctly identify the issue
+2. The current diagnostic message is unclear, confusing, or significantly inaccurate and you can provide a substantially clearer explanation of the same issue
+
+IMPORTANT: Only use the rewrite_diagnostic_location tool if one of these conditions are met:
+1. The diagnostic correctly identifies an issue in the code snippet but is pointing to the wrong line number
+2. The diagnostic should cover a different range of lines to better highlight the problematic code
+
+For all other cases, including when the diagnostic is invalid or when the message and location are already adequate, proceed directly to the evaluate_diagnostic tool without attempting to rewrite anything.
+
+Your response can only be submitted via the evaluate_diagnostic tool after optionally using the rewrite_diagnostic_message or rewrite_diagnostic_location tools.
 `
diff --git a/internal/review/grader/grader_test.go b/internal/review/grader/grader_test.go
index 251be6cb9df6..f360f124e593 100644
--- a/internal/review/grader/grader_test.go
+++ b/internal/review/grader/grader_test.go
@@ -1,34 +1,34 @@
 package grader
 
 import (
-	"context"
-	"io"
-	"strings"
 	"testing"
 
 	"github.com/hexops/autogold/v2"
+	"github.com/sourcegraph/go-diff/diff"
+	"github.com/stretchr/testify/assert"
 	"github.com/stretchr/testify/require"
 
-	"github.com/sourcegraph/sourcegraph/internal/api"
+	sglog "github.com/sourcegraph/log"
+
 	"github.com/sourcegraph/sourcegraph/internal/completions/client/anthropic"
 	"github.com/sourcegraph/sourcegraph/internal/completions/llmutils"
-	"github.com/sourcegraph/sourcegraph/internal/database/dbmocks"
-	"github.com/sourcegraph/sourcegraph/internal/gitserver/gitservermocks"
 	"github.com/sourcegraph/sourcegraph/internal/openapi/goapi"
 	"github.com/sourcegraph/sourcegraph/internal/tenant/tenanttest"
-	"github.com/sourcegraph/sourcegraph/internal/types"
+	"github.com/sourcegraph/sourcegraph/lib/core"
 	"github.com/sourcegraph/sourcegraph/lib/pointers"
 )
 
 func TestGradeDiagnostic(t *testing.T) {
 	grader := setupGrader(t)
 	tests := []struct {
-		name        string
-		rule        goapi.Rule
-		diagnostic  goapi.ReviewDiagnostic
-		cache       map[string]FileContent
-		wantType    goapi.ReviewDiagnosticFeedbackConfusionLabel
-		wantSummary autogold.Value
+		name            string
+		rule            goapi.Rule
+		diagnostic      goapi.ReviewDiagnostic
+		diff            FileContent
+		wantType        goapi.ConfusionLabel
+		wantSummary     autogold.Value
+		wantRewrite     autogold.Value
+		wantNewLocation core.Option[goapi.Location]
 	}{
 		{
 			name: "valid variable naming violation",
@@ -38,23 +38,25 @@ func TestGradeDiagnostic(t *testing.T) {
 				},
 			},
 			diagnostic: goapi.ReviewDiagnostic{
-				Message: "Consider using a more descriptive variable name here",
+				Message: "Consider using a more descriptive variable name that follows camelCase convention instead of single-letter 'x'",
 				Location: goapi.Location{
-					Repo: "github.com/test/repo",
-					Path: "test.go",
-					Oid:  "abc123",
+					Repo:   "github.com/test/repo",
+					RepoId: pointers.Ptr(int32(1)),
+					Path:   "test.go",
+					Oid:    "abc123",
 					Range: &goapi.Range{
 						Start: &goapi.Position{
-							Line: 4,
+							Line: 5,
 						},
 						End: &goapi.Position{
-							Line: 4,
+							Line: 5,
 						},
 					},
 				},
 			},
 			wantType:    "true-positive",
-			wantSummary: autogold.Expect(`The diagnostic correctly identifies a clear violation of the rule. The variable name 'x' is not descriptive as it doesn't indicate what the variable represents or its purpose. The rule specifically instructs to "Check if variable names are descriptive," and 'x' is a single-letter name that provides no information about its meaning or usage in the code. A more descriptive name following camelCase convention would better comply with the rule.`),
+			wantSummary: autogold.Expect("The diagnostic correctly identifies a variable name that violates both parts of the rule: (1) The variable 'x' is a single-letter name that is not descriptive of its purpose, and (2) while single-letter variables are technically in camelCase format, they don't provide the semantic benefits that descriptive camelCase names offer. Single-letter variable names should typically only be used in very limited contexts like loop counters or when the purpose is extremely obvious from immediate context, but in this case 'x' is assigned a numeric value without clear context about what the number represents. A more descriptive name like 'defaultValue' or 'maxCount' would be much clearer."),
+			wantRewrite: nil,
 		},
 		{
 			name: "invalid variable naming violation",
@@ -66,132 +68,648 @@ func TestGradeDiagnostic(t *testing.T) {
 			diagnostic: goapi.ReviewDiagnostic{
 				Message: "Consider using a more descriptive variable name here",
 				Location: goapi.Location{
-					Repo: "github.com/test/repo",
-					Path: "test.go",
-					Oid:  "abc123",
+					Repo:   "github.com/test/repo",
+					RepoId: pointers.Ptr(int32(1)),
+					Path:   "test.go",
+					Oid:    "abc123",
 					Range: &goapi.Range{
 						Start: &goapi.Position{
-							Line: 7,
+							Line: 8,
 						},
 						End: &goapi.Position{
-							Line: 7,
+							Line: 8,
 						},
 					},
 				},
 			},
 			wantType:    "false-positive",
-			wantSummary: autogold.Expect(`The diagnostic suggests that "userCount" should have a more descriptive name, but "userCount" is actually a good, descriptive variable name that clearly communicates its purpose (counting users) and follows camelCase convention as required by the rule. The variable name is specific enough to understand what it represents and adheres to the naming convention mentioned in the rule instruction. The comment "// Line 7: Good variable name" also indicates that the original author considered this a well-named variable.`),
+			wantSummary: autogold.Expect(`The diagnostic incorrectly flags "userCount" as a non-descriptive variable name. "userCount" is actually a good example of a descriptive variable name that follows camelCase convention. It clearly indicates its purpose (counting users) and follows proper Go naming conventions with lowercase first letter and camelCase for word separation. This is a false positive that should be ignored.`),
 		},
 		{
-			name: "unrelated diagnostic to rule",
-			cache: map[string]FileContent{
-				"cmd/gitserver/internal/patch_test.go": &testFileContent{
-					content: `
-package internal
-
-import (
-	"context"
-	"fmt"
-	"github.com/sourcegraph/log"
-	"github.com/sourcegraph/sourcegraph/cmd/gitserver/internal/cloneurl"
-	"github.com/sourcegraph/sourcegraph/cmd/gitserver/internal/common"
-	"github.com/sourcegraph/sourcegraph/cmd/gitserver/internal/gitserverfs"
-	"github.com/sourcegraph/sourcegraph/internal/api"
-	"github.com/sourcegraph/sourcegraph/internal/gitserver"
-	"github.com/sourcegraph/sourcegraph/internal/gitserver/protocol"
-	"github.com/sourcegraph/sourcegraph/internal/observation"
-	"github.com/sourcegraph/sourcegraph/internal/tenant/tenanttest"
-	"github.com/sourcegraph/sourcegraph/internal/vcs"
-	"github.com/sourcegraph/sourcegraph/internal/wrexec"
-	"github.com/sourcegraph/sourcegraph/lib/check"
-	"github.com/stretchr/testify/require"
-	"math/rand"
-	"net"
-	"os"
-	"os/exec"
-	"path"
-	"path/filepath"
-	"strings"
-	"syscall"
-	"testing"
-	"time"
-)
-
-func TestCreateCommitFromPatch(t *testing.T) {
-
-	ctx := tenanttest.TestContext()
-
-	repoName := api.RepoName(fmt.Sprintf("github.com/sourcegraph/test-repo-%d", rand.Intn(10000)))
-
-	// We must set up the server and get a repo dir first,
-	// otherwise there will be a directory mismatch that's hard to track down.
-	observationCtx := observation.TestContextTB(t)
-	s := newTestGitserver(t, observationCtx)
-	gitDir, err := s.fs.RepoDir(ctx, repoName)
-	initRepo(t, gitDir, err)
-
-	// Add an initial commit to the repo.
-	// We will later change it and create a patch from that change.
-	gitAdd(t, gitDir, "test.txt", "init content")
-	gitRun(t, gitDir, "commit", "-m", "init commit")
-
-	// Remember HEAD as the base commit for the CreateCommitFromPatchRequest call.
-	head := strings.TrimSpace(gitRun(t, gitDir, "rev-parse", "HEAD"))
-	require.NotEmpty(t, head, "head should not be empty")
-
-	// Now create the patch that we want to apply.
-	patch := createPatch(t, gitDir, "test.txt", "patch content")
-
-	resp := s.CreateCommitFromPatch(ctx, protocol.CreateCommitFromPatchRequest{
-		Repo:       repoName,
-		BaseCommit: api.CommitID(head),
-		// The Patch field is not used in CreateCommitFromPatch. It uses the reader (3rd arg) instead.
-		Patch: nil,
-		// I think we only need this if we'd generate a patch with --no-prefix.
-		PatchFilenamesNoPrefix: false,
-		TargetRef:              "HEAD",
-		CommitInfo: protocol.PatchCommitInfo{
-			Messages:    []string{"patch commit"},
-			AuthorName:  "Foo Author",
-			AuthorEmail: "foo@sourcegraph.com",
+			name: "valid violation but incorrect location",
+			rule: goapi.Rule{
+				LatestRevision: &goapi.RuleRevision{
+					Instruction: pointers.Ptr("Check if variable names are descriptive and follow camelCase convention"),
+				},
+			},
+			diagnostic: goapi.ReviewDiagnostic{
+				Message: "Consider using a more descriptive variable name that follows camelCase convention instead of single-letter 'x'",
+				Location: goapi.Location{
+					Repo:   "github.com/test/repo",
+					RepoId: pointers.Ptr(int32(1)),
+					Path:   "test.go",
+					Oid:    "abc123",
+					Range: &goapi.Range{
+						Start: &goapi.Position{
+							Line: 6,
+						},
+					},
+				},
+			},
+			wantType:    "true-positive",
+			wantSummary: autogold.Expect("The diagnostic correctly identifies that the variable name 'x' is a single-letter name that lacks descriptive meaning. The rule specifies checking for both descriptive variable names and camelCase convention. The variable 'x' is not descriptive as it doesn't indicate its purpose or content, and it doesn't follow camelCase convention which would require a meaningful name with appropriate capitalization. Using a more descriptive variable name like 'value', 'count', or 'numberValue' would improve code readability and meet the rule's requirements."),
+			wantNewLocation: core.Some(goapi.Location{
+				Repo:   "github.com/test/repo",
+				RepoId: pointers.Ptr(int32(1)),
+				Path:   "test.go",
+				Oid:    "abc123",
+				Range: &goapi.Range{
+					Start: &goapi.Position{
+						Line: 5,
+					},
+				},
+			}),
 		},
-		Push: nil,`,
+		{
+			name: "valid violation but irrelevant message",
+			rule: goapi.Rule{
+				LatestRevision: &goapi.RuleRevision{
+					Instruction: pointers.Ptr("Check if variable names are descriptive and follow camelCase convention"),
+				},
+			},
+			diagnostic: goapi.ReviewDiagnostic{
+				Message: "This line is too long and should be split into multiple lines",
+				Location: goapi.Location{
+					Repo:   "github.com/test/repo",
+					RepoId: pointers.Ptr(int32(1)),
+					Path:   "test.go",
+					Oid:    "abc123",
+					Range: &goapi.Range{
+						Start: &goapi.Position{
+							Line: 5,
+						},
+						End: &goapi.Position{
+							Line: 5,
+						},
+					},
 				},
 			},
+			wantType:    "true-positive",
+			wantSummary: autogold.Expect("The diagnostic correctly identifies a violation of the rule. The variable 'x' on line 5 is a single-letter name that is not descriptive and doesn't follow camelCase convention. The rule explicitly states to check if variable names are descriptive and follow camelCase convention, which 'x' clearly fails to do. Single-letter variables are generally considered non-descriptive unless used in very specific contexts like loop indices or mathematical formulas."),
+			wantRewrite: autogold.Expect("Variable name 'x' is not descriptive and doesn't follow camelCase convention"),
+		},
+		// Disabled until languages are supported
+		// 		{
+		// 			name: "failed to catch limit check",
+		// 			cache: map[string]FileContent{
+		// 				"internal/search/nls/combine.go": &testFileContent{
+		// 					content: ` func (j *searchJob) combineResponses(ctx context.Context, reranker rerank.Rerank
+
+		//  func concatAndLimit(literalResponse, keywordResponse response, limit int) response {
+		//  	if literalResponse.isEmpty() {
+		// 		keywordResponse.matches = keywordResponse.matches[:min(limit, len(keywordResponse.matches))]`,
+		// 				},
+		// 			},
+		// 			diagnostic: goapi.ReviewDiagnostic{
+		// 				Message: "**bugs** Potential bug: The limit check should be done before attempting to slice the keywordResponse.matches array to avoid panic if matches is empty",
+		// 				Location: goapi.Location{
+		// 					Repo: "sourcegraph/sourcegraph",
+		// 					Path: "internal/search/nls/combine.go",
+		// 					Oid:  "7ca2c1454281f30257f4a74eabc4648fa79cb3f6",
+		// 					Range: &goapi.Range{
+		// 						Start: &goapi.Position{
+		// 							Line: 5,
+		// 						},
+		// 						End: &goapi.Position{
+		// 							Line: 5,
+		// 						},
+		// 					},
+		// 				},
+		// 			},
+		// 			rule: goapi.Rule{
+		// 				LatestRevision: &goapi.RuleRevision{
+		// 					Instruction: pointers.Ptr(`### Context
+		// Identifying bugs during code review is more efficient than catching them in production. Many bugs follow recognizable patterns that can be detected early, preventing customer-facing issues, data corruption, or security vulnerabilities.
+
+		// ### Common Pitfalls
+
+		// #### Boolean Logic Errors
+		// - Inverted conditions (using != when == was intended or vice versa)
+		// - Missing or excessive negation (! operator)
+		// - Confusing AND/OR logic in complex conditions
+		// - Off-by-one errors in boundary checks
+		// - Using assignment (=) instead of comparison (==) in conditionals
+
+		// #### Copy-Paste Issues
+		// - Code duplicated without necessary modifications
+		// - Variable names not updated in copied blocks
+		// - Function parameters not adjusted for the new context
+		// - Hardcoded values not updated when copying similar logic
+		// - Comments that don't match copied code functionality
+
+		// #### Incomplete Implementation
+		// - Unimplemented TODO comments left in production code
+		// - Partially implemented features with missing edge cases
+		// - Placeholder code never replaced with actual implementation
+		// - Commented-out code intended to be uncommented later
+		// - Debug statements accidentally left in production code
+
+		// #### Control Flow & Logic
+		// - Unreachable code paths
+		// - Missing break statements in switch/case blocks
+		// - Missing return statements causing fallthrough
+		// - Dead code that never executes
+		// - Inconsistent early returns
+
+		// ### Action Items
+		// When identifying potential bugs, provide:
+		// - Precise explanation of the issue and potential impact
+		// - Under what specific conditions the bug would manifest
+		// - Root cause analysis rather than just symptoms
+		// - Concrete recommendations for fixing the issue
+		// - Suggestions for automated tests to prevent regression
+
+		// ### Examples
+
+		//  Inverted boolean condition:
+		// '''javascript
+		// // Bug: Condition is inverted, letting invalid users in
+		// function checkAccess(user) {
+		//   // Intends to allow access only to admins
+		//   if (!user.isAdmin) {  // Should be: if (user.isAdmin)
+		//     grantAccess();
+		//   } else {
+		//     denyAccess();
+		//   }
+		// }
+		// '''
+
+		//  Correct boolean logic:
+		// '''javascript
+		// function checkAccess(user) {
+		//   if (user.isAdmin) {
+		//     grantAccess();
+		//   } else {
+		//     denyAccess();
+		//   }
+		// }
+		// '''
+
+		//  Copy-paste bug:
+		// '''python
+		// # Bug: Copy-pasted code with inconsistent variable updates
+		// def validate_username(username):
+		//     if len(username) < 3:
+		//         return False, "Username must be at least 3 characters"
+		//     if len(username) > 20:
+		//         return False, "Username must be at most 20 characters"
+		//     return True, None
+
+		// def validate_password(password):
+		//     if len(password) < 8:
+		//         return False, "Password must be at least 8 characters"
+		//     if len(username) > 64:  # BUG: Using username variable instead of password
+		//         return False, "Password must be at most 64 characters"
+		//     return True, None
+		// '''
+
+		//  Properly updated variables after copy-paste:
+		// '''python
+		// def validate_username(username):
+		//     if len(username) < 3:
+		//         return False, "Username must be at least 3 characters"
+		//     if len(username) > 20:
+		//         return False, "Username must be at most 20 characters"
+		//     return True, None
+
+		// def validate_password(password):
+		//     if len(password) < 8:
+		//         return False, "Password must be at least 8 characters"
+		//     if len(password) > 64:  # Correctly using password variable
+		//         return False, "Password must be at most 64 characters"
+		//     return True, None
+		// '''
+
+		//  Unimplemented TODO:
+		// '''java
+		// public class PaymentProcessor {
+		//     public boolean processPayment(Order order) {
+		//         validateOrder(order);
+
+		//         // TODO: Implement fraud detection before processing
+		//         // This has been in production for months with no fraud checks
+
+		//         chargeCustomer(order.getCustomerId(), order.getTotal());
+		//         return true;
+		//     }
+		// }
+		// '''
+
+		//  Implemented feature that was previously a TODO:
+		// '''java
+		// public class PaymentProcessor {
+		//     public boolean processPayment(Order order) {
+		//         validateOrder(order);
+
+		//         // Implemented fraud detection
+		//         if (fraudDetectionService.isSuspicious(order)) {
+		//             flagForReview(order);
+		//             return false;
+		//         }
+
+		//         chargeCustomer(order.getCustomerId(), order.getTotal());
+		//         return true;
+		//     }
+		// }
+		// '''
+
+		//  Missing break in switch statement:
+		// '''c
+		// // Bug: Missing break causes fallthrough to next case
+		// void processStatus(int status) {
+		//   switch(status) {
+		//     case STATUS_OK:
+		//       logSuccess();
+		//       // Missing break - will fall through to error case
+		//     case STATUS_ERROR:
+		//       logError();
+		//       break;
+		//     case STATUS_PENDING:
+		//       waitForCompletion();
+		//       break;
+		//   }
+		// }
+		// '''
+
+		//  Correct switch statement:
+		// '''c
+		// void processStatus(int status) {
+		//   switch(status) {
+		//     case STATUS_OK:
+		//       logSuccess();
+		//       break;
+		//     case STATUS_ERROR:
+		//       logError();
+		//       break;
+		//     case STATUS_PENDING:
+		//       waitForCompletion();
+		//       break;
+		//   }
+		// }
+		// '''
+
+		// ### When to use this rule
+		// Use this rule for logical errors, implementation mistakes, and code correctness issues that affect functionality but don't have security implications.
+		// For security-specific issues, use the "security" rule. For issues with how errors are handled after they occur, use the "errors" rule.
+		// For test coverage issues that might prevent bug detection, use the "testing" rule.
+		// 					`),
+		// 				},
+		// 			},
+		// 			wantType:    "false-positive",
+		// 			wantSummary: autogold.Expect("The diagnostic correctly identifies a potential bug where slicing `keywordResponse.matches` with `[:min(limit, len(keywordResponse.matches))]` could cause issues if `keywordResponse.matches` is empty. While Python won't panic on an empty list slicing operation itself, the code would be more robust if it checked if `keywordResponse.matches` is empty before attempting the slicing operation. This aligns with the rule's section on \"Control Flow & Logic\" issues, specifically regarding handling edge cases properly. The code would be safer with an additional check for an empty matches array to avoid potential issues, though the severity might not be as high as suggested since empty list slicing typically returns an empty list in Python rather than causing a panic."),
+		// 		},
+
+		// URL to regenerate: https://github.com/sourcegraph/sourcegraph/pull/3655#discussion_r1977654153
+		// Review URL: https://sourcegraph.sourcegraph.com/agents/1/reviews/465
+		// Diagnostic URL: https://sourcegraph.sourcegraph.com/agents/1/diagnostics?filter_diagnostic_ids=201
+		{
+			name: "test case from 1977654153",
+			diff: newTestFileContent(
+				t,
+				`diff --git a/cmd/gitserver/internal/patch_test.go b/cmd/gitserver/internal/patch_test.go
+index f527f7183a10..f527f7183a10 100644
+--- a/cmd/gitserver/internal/patch_test.go
++++ b/cmd/gitserver/internal/patch_test.go
+@@ -0,0 +1,250 @@
++package internal
++
++import (
++	"context"
++	"fmt"
++	"github.com/sourcegraph/log"
++	"github.com/sourcegraph/sourcegraph/cmd/gitserver/internal/cloneurl"
++	"github.com/sourcegraph/sourcegraph/cmd/gitserver/internal/common"
++	"github.com/sourcegraph/sourcegraph/cmd/gitserver/internal/gitserverfs"
++	"github.com/sourcegraph/sourcegraph/internal/api"
++	"github.com/sourcegraph/sourcegraph/internal/gitserver"
++	"github.com/sourcegraph/sourcegraph/internal/gitserver/protocol"
++	"github.com/sourcegraph/sourcegraph/internal/observation"
++	"github.com/sourcegraph/sourcegraph/internal/tenant/tenanttest"
++	"github.com/sourcegraph/sourcegraph/internal/vcs"
++	"github.com/sourcegraph/sourcegraph/internal/wrexec"
++	"github.com/sourcegraph/sourcegraph/lib/check"
++	"github.com/stretchr/testify/require"
++	"math/rand"
++	"net"
++	"os"
++	"os/exec"
++	"path"
++	"path/filepath"
++	"strings"
++	"syscall"
++	"testing"
++	"time"
++)
++
++func TestCreateCommitFromPatch(t *testing.T) {
++
++	ctx := tenanttest.TestContext()
++
++	repoName := api.RepoName(fmt.Sprintf("github.com/sourcegraph/test-repo-%d", rand.Intn(10000)))
++
++	// We must set up the server and get a repo dir first,
++	// otherwise there will be a directory mismatch that's hard to track down.
++	observationCtx := observation.TestContextTB(t)
++	s := newTestGitserver(t, observationCtx)
++	gitDir, err := s.fs.RepoDir(ctx, repoName)
++	initRepo(t, gitDir, err)
++
++	// Add an initial commit to the repo.
++	// We will later change it and create a patch from that change.
++	gitAdd(t, gitDir, "test.txt", "init content")
++	gitRun(t, gitDir, "commit", "-m", "init commit")
++
++	// Remember HEAD as the base commit for the CreateCommitFromPatchRequest call.
++	head := strings.TrimSpace(gitRun(t, gitDir, "rev-parse", "HEAD"))
++	require.NotEmpty(t, head, "head should not be empty")
++
++	// Now create the patch that we want to apply.
++	patch := createPatch(t, gitDir, "test.txt", "patch content")
++
++	resp := s.CreateCommitFromPatch(ctx, protocol.CreateCommitFromPatchRequest{
++		Repo:       repoName,
++		BaseCommit: api.CommitID(head),
++		// The Patch field is not used in CreateCommitFromPatch. It uses the reader (3rd arg) instead.
++		Patch: nil,
++		// I think we only need this if we'd generate a patch with --no-prefix.
++		PatchFilenamesNoPrefix: false,
++		TargetRef:              "HEAD",
++		CommitInfo: protocol.PatchCommitInfo{
++			Messages:    []string{"patch commit"},
++			AuthorName:  "Foo Author",
++			AuthorEmail: "foo@sourcegraph.com",
++		},
++		Push: nil,
++		// We're setting the field Push to nil, so PushRef is not used.
++		PushRef: nil,
++		// We'll add this field later.
++		//SSHCommitSigning: nil,
++	}, strings.NewReader(patch))
++
++	require.Nil(t, resp.Error)
++
++	// Verify that the commit message includes the intended patch commit message.
++	commitMessage := gitRun(t, gitDir, "show", "-s", "--format=%B")
++	require.NoError(t, err)
++	require.Contains(t, commitMessage, "patch commit", "commit message should include our patch message")
++}
++
++func TestCreateCommitFromPatch_WithPush(t *testing.T) {
++	ctx := tenanttest.TestContext()
++
++	repoName := api.RepoName(fmt.Sprintf("github.com/sourcegraph/test-repo-%d", rand.Intn(10000)))
++
++	// Set up server and test repo like in original test
++	observationCtx := observation.TestContextTB(t)
++	s := newTestGitserver(t, observationCtx)
++	gitDir, err := s.fs.RepoDir(ctx, repoName)
++	initRepo(t, gitDir, err)
++
++	// Set up a local git code host (as a background daemon) and get the URL to the repo.
++	// If the test runs but fails "without running tests", or if the test completes but the runner doesn't stop,
++	// it's likely that cleaning up the daemon processes is the problem.
++	daemonURL, cleanup := setupLocalGitCodehost(t, ctx, gitDir)
++	t.Cleanup(cleanup)
++
++	// Create initial commit
++	gitAdd(t, gitDir, "test.txt", "init content")
++	gitRun(t, gitDir, "commit", "-m", "init commit")
++	head := strings.TrimSpace(gitRun(t, gitDir, "rev-parse", "HEAD"))
++
++	patch := createPatch(t, gitDir, "test.txt", "patch content")
++
++	refMaster := "refs/heads/master"
++	resp := s.CreateCommitFromPatch(ctx, protocol.CreateCommitFromPatchRequest{
++		Repo:       repoName,
++		BaseCommit: api.CommitID(head),
++		Patch:      nil,
++		TargetRef:  refMaster,
++		CommitInfo: protocol.PatchCommitInfo{
++			Messages:    []string{"patch commit"},
++			AuthorName:  "Test Author",
++			AuthorEmail: "test@sourcegraph.com",
++		},
++		Push: &protocol.PushConfig{
++			RemoteURL: daemonURL,
++		},
++		PushRef: &refMaster,
++	}, strings.NewReader(patch))
++
++	require.Nil(t, resp.Error)
++
++	// Create clone directory first
++	cloneDir := t.TempDir()
++	err = os.MkdirAll(cloneDir, 0755)
++	require.NoError(t, err)
++
++	// Clone into "." since we're already in the right directory
++	gitRun(t, common.GitDir(cloneDir), "clone", daemonURL, ".")
++
++	// Verify commit exists in cloned repo
++	commitMsg := gitRun(t, common.GitDir(cloneDir), "log", "-1", "--format=%B")
++	require.Contains(t, commitMsg, "patch commit")
++}
++
++/* This function sets up a git codehost, that can server repositories like a github instance would */
++func setupLocalGitCodehost(t *testing.T, ctx context.Context, gitDir common.GitDir) (string, func()) {
++	// Initialize as bare repo since we'll be serving it
++	gitRun(t, gitDir, "init", "--bare")
++	gitRun(t, gitDir, "config", "receive.denyCurrentBranch", "ignore")
++
++	baseDir := removeGitDirSuffix(gitDir)
++
++	// Get the absolute path to ensure correct path resolution
++	absBaseDir, err := filepath.Abs(baseDir)
++	require.NoError(t, err)
++
++	parentDir := path.Dir(absBaseDir)
++	repoName := path.Base(absBaseDir)
++
++	// Create git-daemon-export-ok file in the .git directory
++	exportFile := path.Join(gitDir.Path(), "git-daemon-export-ok")
++	err = os.WriteFile(exportFile, []byte(""), 0644)
++	require.NoError(t, err)
++
++	// Find a random available port
++	listener, err := net.Listen("tcp", ":0")
++	require.NoError(t, err)
++	port := listener.Addr().(*net.TCPAddr).Port
++	listener.Close()
++
++	daemonCmd := exec.CommandContext(ctx, "git", "daemon",
++		"--reuseaddr",
++		"--base-path="+parentDir,
++		"--export-all",
++		"--enable=receive-pack",
++		fmt.Sprintf("--port=%d", port),
++		"--verbose",
++		parentDir,
++	)
++	daemonCmd.SysProcAttr = &syscall.SysProcAttr{
++		Setpgid: true,
++	}
++
++	// Redirect to stdout/stderr for better debugging if something fails
++	daemonCmd.Stdout = os.Stdout
++	daemonCmd.Stderr = os.Stderr
++
++	err = daemonCmd.Start()
++	require.NoError(t, err)
++
++	pid := daemonCmd.Process.Pid
++	t.Logf("Started git daemon with PID %d", pid)
++
++	// Give daemon more time to start
++	time.Sleep(1 * time.Second)
++
++	cleanup := func() {
++		// See cmd/gitserver/internal/git/gitcli/command.go#NewCommand for more details on using syscall.Kill and process groups
++		// Negative process id means "that process and all of its child processes"
++		syscall.Kill(-daemonCmd.Process.Pid, syscall.SIGKILL)
++	}
++	return fmt.Sprintf("git://localhost:%d/%s", port, repoName), cleanup
++}
++
++func initRepo(t *testing.T, gitDir common.GitDir, err error) {
++	// Given the place that the server wants the repo to be at,
++	// we now create that file path and create an empty git repo there.
++	check.MustNoError(t, os.MkdirAll(removeGitDirSuffix(gitDir), os.ModePerm))
++	cmd := exec.Command("git", "init", "--initial-branch=master", ".")
++	cmd.Dir = removeGitDirSuffix(gitDir)
++	out, err := cmd.CombinedOutput()
++	check.MustNoError(t, err, string(out))
++}
++
++func createPatch(t *testing.T, gitDir common.GitDir, filename, content string) string {
++	gitAdd(t, gitDir, filename, content)
++	// Generate patch with --cached so that the CommitFromPatch function can apply it with --cached
++	patch := gitRun(t, gitDir, "diff", "--cached")
++	require.NotEmpty(t, patch, "patch should not be empty")
++	// reset the file to its previous state so that we can actually apply a diff in the tested function
++	gitRun(t, gitDir, "reset", "--hard")
++	return patch
++}
++
++/* This functions sets up a gitserver from the sourcegraph product. This is not like a github instance. See setupLocalGitCodehost for that. */
++func newTestGitserver(t *testing.T, observationCtx *observation.Context) *Server {
++	baseDir := t.TempDir()
++	return &Server{
++		fs:                      gitserverfs.New(observationCtx, baseDir),
++		logger:                  log.NoOp(),
++		recordingCommandFactory: wrexec.NewNoOpRecordingCommandFactory(),
++		getRemoteURLFunc: func(context.Context, api.RepoName) (*cloneurl.CloneURL, error) {
++			url, _ := vcs.ParseURL("https://sourcegraph.com/dummy.git")
++			return &cloneurl.CloneURL{URL: url}, nil
++		},
++	}
++}
++
++// I copied this function from cmd/symbols/internal/rockskip/mocks_test.go and adjusted it a bit. Feel free to unify :)
++func gitRun(t *testing.T, dir common.GitDir, args ...string) string {
++	fsDir := removeGitDirSuffix(dir)
++	out, err := gitserver.CreateGitCommand(fsDir, "git", args...).CombinedOutput()
++	check.MustNoError(t, err, string(out))
++	return string(out)
++}
++
++func gitAdd(t *testing.T, repoDir common.GitDir, filename string, contents string) {
++	fsDir := removeGitDirSuffix(repoDir)
++	check.MustNoError(t, os.WriteFile(path.Join(fsDir, filename), []byte(contents), 0644), "os.WriteFile")`,
+			),
 			diagnostic: goapi.ReviewDiagnostic{
-				Message: "**go-initialization-nil(warning)** Avoid implicit nil initialization of Push and PushRef fields. Make initialization explicit in CreateCommitFromPatchRequest.",
+				Message: "**go-conditionals(warning)** Empty string check using os.WriteFile return value should use explicit len() check or strings.TrimSpace() in gitAdd() function.",
 				Location: goapi.Location{
 					Repo: "sourcegraph/sourcegraph",
 					Path: "cmd/gitserver/internal/patch_test.go",
 					Oid:  "f527f7183a10936bd679dc0eb6e98f8f69db2136",
 					Range: &goapi.Range{
 						Start: &goapi.Position{
-							Line: 70,
+							Line: 244,
 						},
 						End: &goapi.Position{
-							Line: 70,
+							Line: 244,
 						},
 					},
 				},
 			},
 			rule: goapi.Rule{
 				LatestRevision: &goapi.RuleRevision{
-					Instruction: pointers.Ptr(`# Go conditionals## Prefer switch over if for checking enum cases_Rationale:_ Go doesn't have native support for pattern-matching. However, we can use the [exhaustive](https://github.com/nishanths/exhaustive) linter in the future to get exhaustiveness checking for enums. This relies on using switch statements.go// Bad - using if statements for enumsif status == StatusPending {    // handle pending} else if status == StatusActive {    // handle active} else if status == StatusSuspended {    // handle suspended}// Good - using switch for enumsswitch status {case StatusPending:    // handle pendingcase StatusActive:    // handle activecase StatusSuspended:    // handle suspendeddefault:    // Handle unknown case or use core.PanicUnknownEnumCase}## Switch statements must use a default branch_Description_: If the default case is impossible to hit in practice, use core.PanicUnknownEnumCase (). Otherwise, handle that case appropriately.goswitch status {case StatusPending:    // handle pendingcase StatusActive:    // handle activecase StatusSuspended:    // handle suspendeddefault:    // Option 1: For cases where default should never be reached    core.PanicUnknownEnumCase(status)        // Option 2: For cases where default is a valid possibility    handleUnknownStatus(status)}_Rationale_: This adds an extra safeguard in case:- Some code incorrectly materializes an enum value (e.g. JSON unmarshaling etc.) that is invalid.- The exhaustive linter is not yet enabled for the whole package (rollout will be tricky for larger packages).- The exhaustive linter is disabled by someone for a specific type for some reason, and they then write a non-exhaustive match.`),
+					Instruction: pointers.Ptr(`# Go conditionals
+
+## Prefer switch over if for checking enum cases
+
+_Rationale:_ Go doesn't have native support for pattern-matching. However, we can use the [exhaustive](https://github.com/nishanths/exhaustive) linter in the future to get exhaustiveness checking for enums. This relies on using switch statements.
+
+go
+// Bad - using if statements for enums
+if status == StatusPending {
+    // handle pending
+} else if status == StatusActive {
+    // handle active
+} else if status == StatusSuspended {
+    // handle suspended
+}
+
+// Good - using switch for enums
+switch status {
+case StatusPending:
+    // handle pending
+case StatusActive:
+    // handle active
+case StatusSuspended:
+    // handle suspended
+default:
+    // Handle unknown case or use core.PanicUnknownEnumCase
+}
+
+
+## Switch statements must use a default branch
+
+_Description_: If the default case is impossible to hit in practice, use core.PanicUnknownEnumCase (). Otherwise, handle that case appropriately.
+
+go
+switch status {
+case StatusPending:
+    // handle pending
+case StatusActive:
+    // handle active
+case StatusSuspended:
+    // handle suspended
+default:
+    // Option 1: For cases where default should never be reached
+    core.PanicUnknownEnumCase(status)
+
+    // Option 2: For cases where default is a valid possibility
+    handleUnknownStatus(status)
+}
+
+
+_Rationale_: This adds an extra safeguard in case:
+- Some code incorrectly materializes an enum value (e.g. JSON unmarshaling etc.) that is invalid.
+- The exhaustive linter is not yet enabled for the whole package (rollout will be tricky for larger packages).
+- The exhaustive linter is disabled by someone for a specific type for some reason, and they then write a non-exhaustive match.`),
 				},
 			},
 			wantType:    "false-positive",
-			wantSummary: autogold.Expect("The diagnostic is not a valid violation of the provided rule. The rule instruction focuses on using switch statements for enums and including default branches in switch statements, but the diagnostic flags an issue with nil initialization of fields in a struct. These are completely unrelated concerns - the diagnostic addresses initialization practices while the rule pertains to conditional statement patterns and enum handling. There appears to be a mismatch between the diagnostic and the rule it claims to enforce."),
+			wantSummary: autogold.Expect(`The diagnostic is invalid because there is no conditional logic or empty string checking in the provided code. The code simply calls os.WriteFile to write a file with some content. The diagnostic message references a "gitAdd()" function that isn't visible in the snippet. Additionally, the rule instruction is about using switch over if statements for enums and ensuring switch statements have default branches, neither of which applies to the shown code. There's no relation between the code snippet and the reported issue about empty string checks.`),
 		},
+
+		// URL to regenerate: https://github.com/sourcegraph/sourcegraph/pull/4229#discussion_r2010862364
+		// Review URL: https://sourcegraph.sourcegraph.com/agents/1/reviews/2657
+		// Diagnostic URL: https://sourcegraph.sourcegraph.com/agents/1/diagnostics?filter_diagnostic_ids=459
 		{
-			name: "test case for 2010862364",
-			cache: map[string]FileContent{
-				"internal/rule/service.go": &testFileContent{
-					content: ` import (
+			name: "test case from 2010862364",
+			diff: newTestFileContent(
+				t,
+				`diff --git a/internal/rule/service.go b/internal/rule/service.go
+index ea7e4c7678e0..4167e0928ee5 100644
+--- a/internal/rule/service.go
++++ b/internal/rule/service.go
+@@ -16,6 +16,7 @@ import (
  	"github.com/sourcegraph/sourcegraph/lib/core"
  	"github.com/sourcegraph/sourcegraph/lib/errors"
  	"github.com/sourcegraph/sourcegraph/lib/maps"`,
-				},
-			},
+			),
 			diagnostic: goapi.ReviewDiagnostic{
 				Message: "**[external_url](https://sourcegraph.sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/.sourcegraph/external_url.rule.md)** ExternalURL should be retrieved via db.Conf().GetExternalURL(ctx) instead of conf package for Enterprise Starter support",
 				Location: goapi.Location{
@@ -200,10 +718,10 @@ func TestCreateCommitFromPatch(t *testing.T) {
 					Oid:  "4167e0928ee5564bd3cb524413e8949d5ed807ad",
 					Range: &goapi.Range{
 						Start: &goapi.Position{
-							Line: 4,
+							Line: 18,
 						},
 						End: &goapi.Position{
-							Line: 4,
+							Line: 18,
 						},
 					},
 				},
@@ -220,129 +738,142 @@ Explain that this is a requirement for Enterprise Starter (aka. Multitenant) bec
 				},
 			},
 			wantType:    "false-positive",
-			wantSummary: autogold.Expect(`The diagnostic claims a violation of the ExternalURL access pattern rule, but the code snippet only shows import statements for "errors" and "maps" packages. There is no actual code shown that accesses ExternalURL in any way, whether through the prohibited conf package or otherwise. Without seeing the actual access pattern in the code, it's impossible to determine if there's a rule violation. The diagnostic appears to be completely unfounded based on the provided code snippet.`),
+			wantSummary: autogold.Expect(`The diagnostic is incorrectly flagging an issue that doesn't exist in the shown code. The git diff only displays import statements and doesn't contain any code related to accessing the external URL. Line 18 specifically only shows the import statement for "github.com/sourcegraph/sourcegraph/lib/maps" and there's no evidence of improper external URL access patterns in the visible code. This appears to be a completely misplaced diagnostic as there's no violation of the external_url rule in the provided code snippet.`),
 		},
+
+		// URL to regenerate: https://github.com/sourcegraph/sourcegraph/pull/4229#discussion_r2010862359
+		// Review URL: https://sourcegraph.sourcegraph.com/agents/1/reviews/2657
+		// Diagnostic URL: https://sourcegraph.sourcegraph.com/agents/1/diagnostics?filter_diagnostic_ids=458
 		{
-			name: "captures a security check being removed",
-			cache: map[string]FileContent{
-				"cmd/frontend/internal/ruleapi/handler_rule.go": &testFileContent{
-					content: ` func (h *ruleHandler) HandleRetrieveRules(w http.ResponseWriter, r *http.Request
+			name: "test case for 2010862359",
+			diff: newTestFileContent(
+				t,
+				`diff --git a/cmd/frontend/internal/ruleapi/handler_rule.go b/cmd/frontend/internal/ruleapi/handler_rule.go
+index ea7e4c7678e0..c350236ea636 100644
+--- a/cmd/frontend/internal/ruleapi/handler_rule.go
++++ b/cmd/frontend/internal/ruleapi/handler_rule.go
+@@ -43,6 +45,93 @@ func (h *ruleHandler) HandleRetrieveRules(w http.ResponseWriter, r *http.Request
  	return nil
  }
 
-// POST /.api/rules
-func (h *ruleHandler) HandleCreateRule(w http.ResponseWriter, r *http.Request) error {
-	request := &goapi.Rule{}
-	if err := json.NewDecoder(r.Body).Decode(request); err != nil {
-		return errcode.NewJSONHTTPErr(err, "json.Decode()", http.StatusBadRequest)
-	}
-
-	if request.LatestRevision == nil {
-		return errcode.NewJSONHTTPErr(errors.New("latest_revision must be set"), "post_rules_latest_revision_required", http.StatusBadRequest)
-	}
-
-	if pointers.DerefZero(request.LatestRevision.RawContent) != "" {
-		rule, err := rule.ParseMarkdown(*request.LatestRevision.RawContent)
-		if err != nil {
-			return errcode.NewJSONHTTPErr(err, "post_rules_parse_raw_content", http.StatusBadRequest)
-		}
-		request.LatestRevision = rule.LatestRevision
-		request.LatestRevision.RawContent = nil
-	}
-
-	// All rules created via the API are "inline" rules.
-	request.LatestRevision.Source = goapi.RuleSource{
-		Inline: pointers.Ptr(true),
-	}
-
-	if request.LatestRevision.Instruction == nil {
-		// Allow creating an empty rule for "I'm feeling lucky" mode. You can always PATCH the rule later.
-		request.LatestRevision.Instruction = pointers.Ptr("")
-	}
-
-	rules, err := h.db.Rules().BulkUpsert(r.Context(), []goapi.Rule{*request})
-	if err != nil {
-		h.logger.Error("failed to create a rule", sglog.Error(err))
-		return errcode.NewJSONHTTPErr(err, "post_rules_bulk_upsert", http.StatusInternalServerError)
-	}
-	if len(rules) != 1 {
-		return errcode.NewJSONHTTPErr(errors.New("expected exactly one rule"), "post_rules_bulk_upsert", http.StatusInternalServerError)
-	}
-
-	handlerutil.ServeJSON(w, r, h.logger, rules[0])
-	return nil
-}
-
-// PATCH /.api/rules/{rule_id}/latest_revision
-func (h *ruleHandler) HandlePatchRuleLatestRevision(w http.ResponseWriter, r *http.Request) error {
-	id, err := parseRuleID(r)
-	if err != nil {
-		return err
-	}
-
-	rule, err := h.db.Rules().Get(r.Context(), database.RuleGetOptions{ID: pointers.Ptr(id)})
-	if err != nil {
-		return errcode.NewJSONHTTPErr(err, "db.Rules().Get()", http.StatusInternalServerError)
-	}
-
-	if err := json.NewDecoder(r.Body).Decode(&rule.LatestRevision); err != nil {
-		return errcode.NewJSONHTTPErr(err, "json.Decode()", http.StatusBadRequest)
-	}
-
-	rules, err := h.db.Rules().BulkUpsert(r.Context(), []goapi.Rule{rule})
-	if err != nil {
-		return errcode.NewJSONHTTPErr(err, "db.Rules().BulkUpsert()", http.StatusInternalServerError)
-	}
-
-	if len(rules) != 1 {
-		return errcode.NewJSONHTTPErr(errors.New("expected exactly one rule"), "db.Rules().BulkUpsert()", http.StatusInternalServerError)
-	}
-
-	handlerutil.ServeJSON(w, r, h.logger, rules[0])
-	return nil
-}
-
-// DELETE /.api/rules/{rule_id}
-func (h *ruleHandler) HandleDeleteRule(w http.ResponseWriter, r *http.Request) error {
-	id, err := parseRuleID(r)
-	if err != nil {
-		return err
-	}
-
-	if err := h.db.Rules().Delete(r.Context(), id); err != nil {`,
-				},
-			},
++// POST /.api/rules
++func (h *ruleHandler) HandleCreateRule(w http.ResponseWriter, r *http.Request) error {
++	request := &goapi.Rule{}
++	if err := json.NewDecoder(r.Body).Decode(request); err != nil {
++		return errcode.NewJSONHTTPErr(err, "json.Decode()", http.StatusBadRequest)
++	}
++
++	if request.LatestRevision == nil {
++		return errcode.NewJSONHTTPErr(errors.New("latest_revision must be set"), "post_rules_latest_revision_required", http.StatusBadRequest)
++	}
++
++	if pointers.DerefZero(request.LatestRevision.RawContent) != "" {
++		rule, err := rule.ParseMarkdown(*request.LatestRevision.RawContent)
++		if err != nil {
++			return errcode.NewJSONHTTPErr(err, "post_rules_parse_raw_content", http.StatusBadRequest)
++		}
++		request.LatestRevision = rule.LatestRevision
++		request.LatestRevision.RawContent = nil
++	}
++
++	// All rules created via the API are "inline" rules.
++	request.LatestRevision.Source = goapi.RuleSource{
++		Inline: pointers.Ptr(true),
++	}
++
++	if request.LatestRevision.Instruction == nil {
++		// Allow creating an empty rule for "I'm feeling lucky" mode. You can always PATCH the rule later.
++		request.LatestRevision.Instruction = pointers.Ptr("")
++	}
++
++	rules, err := h.db.Rules().BulkUpsert(r.Context(), []goapi.Rule{*request})
++	if err != nil {
++		h.logger.Error("failed to create a rule", sglog.Error(err))
++		return errcode.NewJSONHTTPErr(err, "post_rules_bulk_upsert", http.StatusInternalServerError)
++	}
++	if len(rules) != 1 {
++		return errcode.NewJSONHTTPErr(errors.New("expected exactly one rule"), "post_rules_bulk_upsert", http.StatusInternalServerError)
++	}
++
++	handlerutil.ServeJSON(w, r, h.logger, rules[0])
++	return nil
++}
++
++// PATCH /.api/rules/{rule_id}/latest_revision
++func (h *ruleHandler) HandlePatchRuleLatestRevision(w http.ResponseWriter, r *http.Request) error {
++	id, err := parseRuleID(r)
++	if err != nil {
++		return err
++	}
++
++	rule, err := h.db.Rules().Get(r.Context(), database.RuleGetOptions{ID: pointers.Ptr(id)})
++	if err != nil {
++		return errcode.NewJSONHTTPErr(err, "db.Rules().Get()", http.StatusInternalServerError)
++	}
++
++	if err := json.NewDecoder(r.Body).Decode(&rule.LatestRevision); err != nil {
++		return errcode.NewJSONHTTPErr(err, "json.Decode()", http.StatusBadRequest)
++	}
++
++	rules, err := h.db.Rules().BulkUpsert(r.Context(), []goapi.Rule{rule})
++	if err != nil {
++		return errcode.NewJSONHTTPErr(err, "db.Rules().BulkUpsert()", http.StatusInternalServerError)
++	}
++
++	if len(rules) != 1 {
++		return errcode.NewJSONHTTPErr(errors.New("expected exactly one rule"), "db.Rules().BulkUpsert()", http.StatusInternalServerError)
++	}
++
++	handlerutil.ServeJSON(w, r, h.logger, rules[0])
++	return nil
++}
++
++// DELETE /.api/rules/{rule_id}
++func (h *ruleHandler) HandleDeleteRule(w http.ResponseWriter, r *http.Request) error {
++	id, err := parseRuleID(r)
++	if err != nil {
++		return err
++	}
++
++	if err := h.db.Rules().Delete(r.Context(), id); err != nil {`,
+			),
 			diagnostic: goapi.ReviewDiagnostic{
 				Message: "**[security-common-issues](https://sourcegraph.sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/.sourcegraph/security-common-issues.rule.md)** Rule deletion should verify user has permissions to delete rule",
 				Location: goapi.Location{
 					Repo: "sourcegraph/sourcegraph",
 					Path: "cmd/frontend/internal/ruleapi/handler_rule.go",
-					Oid:  "4167e0928ee5564bd3cb524413e8949d5ed807ad",
+					Oid:  "c350236ea636a4a35e5807d72e41d9c17105a43d",
 					Range: &goapi.Range{
 						Start: &goapi.Position{
-							Line: 84,
+							Line: 127,
 						},
 						End: &goapi.Position{
-							Line: 84,
+							Line: 127,
 						},
 					},
 				},
 			},
 			rule: goapi.Rule{
 				LatestRevision: &goapi.RuleRevision{
-					Instruction: pointers.Ptr(`As an expert security reviewer, examine the code for common security issues while maintaining a low false positive rate. In your review, consider the following areas:
-
-Input Validation and Sanitization: Ensure that all external inputs are properly validated and sanitized to prevent injection and related attacks.
-Authentication & Authorization: Confirm that secure and robust mechanisms are used, avoiding hardcoded credentials and insecure session management.
-Error Handling: Verify that error handling does not expose sensitive information in error messages or logs.
-Secure Configuration & Cryptography: Check that secure defaults are used, cryptographic libraries are up-to-date, and weak algorithms are avoided.
-Logging Practices: Ensure that logs do not inadvertently store sensitive information.
-Secret Handling: Secrets are stored securely rather than in code, use constant-time comparisons against user input,
+					Instruction: pointers.Ptr(`---
+title: Security Common Issues
+description: Reviews code changes for adherence to common security best practices and the potential introduction of vulnerabilities
+tags: [\"security\", \"generic\"]
+---
+
+As an expert security reviewer, examine the code for common security issues while maintaining a low false positive rate. In your review, consider the following areas:
+ - Input Validation and Sanitization: Ensure that all external inputs are properly validated and sanitized to prevent injection and related attacks.
+ - Authentication & Authorization: Confirm that secure and robust mechanisms are used, avoiding hardcoded credentials and insecure session management.
+ - Error Handling: Verify that error handling does not expose sensitive information in error messages or logs.
+ - Secure Configuration & Cryptography: Check that secure defaults are used, cryptographic libraries are up-to-date, and weak algorithms are avoided.
+ - Logging Practices: Ensure that logs do not inadvertently store sensitive information.
+ - Secret Handling: Secrets are stored securely rather than in code, use constant-time comparisons against user input,
+
 Focus on identifying issues that could lead to significant security risks. When flagging potential issues, provide clear explanations and recommendations for remediation.`),
 				},
 			},
 			wantType:    "true-positive",
-			wantSummary: autogold.Expect("The diagnostic correctly identifies a potential authorization issue in the code. The snippet shows a rule deletion operation (`h.db.Rules().Delete(r.Context(), id)`) without any visible authorization check to verify that the user has permission to delete the rule. This falls under the \"Authentication & Authorization\" category in the rule instructions, which specifically mentions confirming that robust authorization mechanisms are used. Without proper permission checking, a user might be able to delete rules they shouldn't have access to, creating a privilege escalation vulnerability. However, since we only see a small code snippet and can't confirm if permission checks might exist elsewhere in the call stack (such as in middleware or in the handler initialization), I can't \"strongly agree\" that this is definitely a violation."),
+			wantSummary: autogold.Expect("The diagnostic correctly identifies a security issue. The code shows a rule deletion operation (`h.db.Rules().Delete`) without any visible authorization check to verify that the user has appropriate permissions to perform this action. Implementing permission checks before allowing deletion operations is a fundamental security practice to prevent unauthorized data manipulation. This aligns with the rule's focus on Authentication & Authorization, specifically ensuring that \"secure and robust mechanisms are used\" for access control. Without permission verification, any user who can reach this endpoint could potentially delete rules they shouldn't have access to, creating a significant security vulnerability."),
 		},
 		// Inject here
 	}
@@ -351,174 +882,49 @@ Focus on identifying issues that could lead to significant security risks. When
 		t.Run(tt.name, func(t *testing.T) {
 			tt.diagnostic.DiagnosticId = 1
 			tt.diagnostic.ReviewId = 1
-
-			// Create a map of file contents for the test
-			if tt.cache == nil {
-				tt.cache = defaultCache
+			if tt.diff == nil {
+				tt.diff = newTestFileContent(t, `diff --git a/test.go b/test.go
+					index abc123..abc123 100644
+					--- a/test.go
+					+++ b/test.go
+
+					dex f527f7183a10..f527f7183a10 100644
+--- a/cmd/gitserver/internal/patch_test.go
++++ b/cmd/gitserver/internal/patch_test.go
+@@ -0,0 +1,12 @@
++ package test
++
++ func example() {
++     // Line 4: Poor variable name
++     x := 42
++
++     // Line 7: Good variable name
++     userCount := 100
++
++     // Line 10: Ambiguous formatting
++     result:=process(data)
++ }`)
 			}
 
-			feedback, err := grader.Grade(tenanttest.TestContext(), tt.rule, tt.diagnostic, tt.cache)
+			result, err := grader.Grade(tenanttest.TestContext(), sglog.NoOp(), tt.rule, tt.diagnostic, tt.diff)
 			require.NoError(t, err)
 
-			tt.wantSummary.Equal(t, *feedback.Comment)
-			require.Equal(t, tt.wantType, *feedback.ConfusionLabel)
-			require.Equal(t, goapi.ReviewDiagnosticEvaluationAuthorTypeLlmJudge, feedback.Author.Type)
-			require.Equal(t, GRADER_MODEL, *feedback.Author.LlmJudge)
-		})
-	}
-}
-
-// This test can be deleted as it is only testing the mock git client
-// but it is useful for debugging test failures for TestGradeDiagnostic
-func TestGetCodeSnippet(t *testing.T) {
-	grader := setupGrader(t).(*llmJudgeGrader)
-	tests := []struct {
-		name       string
-		diagnostic goapi.ReviewDiagnostic
-		want       autogold.Value
-		wantErr    bool
-	}{
-		{
-			name: "single line with context",
-			diagnostic: goapi.ReviewDiagnostic{
-				Location: goapi.Location{
-					Repo: "github.com/test/repo",
-					Path: "test.go",
-					Oid:  "abc123",
-					Range: &goapi.Range{
-						Start: &goapi.Position{
-							Line: 4,
-						},
-						End: &goapi.Position{
-							Line: 4,
-						},
-					},
-				},
-			},
-			want: autogold.Expect(`func example() {
-    // Line 4: Poor variable name
-    x := 42`),
-			wantErr: false,
-		},
-		{
-			name: "second issue",
-			diagnostic: goapi.ReviewDiagnostic{
-				Location: goapi.Location{
-					Repo: "github.com/test/repo",
-					Path: "test.go",
-					Oid:  "abc123",
-					Range: &goapi.Range{
-						Start: &goapi.Position{
-							Line: 7,
-						},
-						End: &goapi.Position{
-							Line: 7,
-						},
-					},
-				},
-			},
-			want: autogold.Expect(`
-    // Line 7: Good variable name
-    userCount := 100`),
-			wantErr: false,
-		},
-		{
-			name: "third issue",
-			diagnostic: goapi.ReviewDiagnostic{
-				Location: goapi.Location{
-					Repo: "github.com/test/repo",
-					Path: "test.go",
-					Oid:  "abc123",
-					Range: &goapi.Range{
-						Start: &goapi.Position{
-							Line: 10,
-						},
-						End: &goapi.Position{
-							Line: 10,
-						},
-					},
-				},
-			},
-			want: autogold.Expect(`
-    // Line 10: Ambiguous formatting
-    result:=process(data)`),
-			wantErr: false,
-		},
-		{
-			name: "multi-line range",
-			diagnostic: goapi.ReviewDiagnostic{
-				Location: goapi.Location{
-					Repo: "github.com/test/repo",
-					Path: "test.go",
-					Oid:  "abc123",
-					Range: &goapi.Range{
-						Start: &goapi.Position{
-							Line: 4,
-						},
-						End: &goapi.Position{
-							Line: 6,
-						},
-					},
-				},
-			},
-			want: autogold.Expect(`func example() {
-    // Line 4: Poor variable name
-    x := 42
-
-    // Line 7: Good variable name`),
-			wantErr: false,
-		},
-		{
-			name: "start of file",
-			diagnostic: goapi.ReviewDiagnostic{
-				Location: goapi.Location{
-					Repo: "github.com/test/repo",
-					Path: "test.go",
-					Oid:  "abc123",
-					Range: &goapi.Range{
-						Start: &goapi.Position{
-							Line: 1,
-						},
-						End: &goapi.Position{
-							Line: 1,
-						},
-					},
-				},
-			},
-			want:    autogold.Expect("package test\n"),
-			wantErr: false,
-		},
-		{
-			name: "end of file",
-			diagnostic: goapi.ReviewDiagnostic{
-				Location: goapi.Location{
-					Repo: "github.com/test/repo",
-					Path: "test.go",
-					Oid:  "abc123",
-					Range: &goapi.Range{
-						Start: &goapi.Position{
-							Line: 12,
-						},
-						End: &goapi.Position{
-							Line: 12,
-						},
-					},
-				},
-			},
-			want:    autogold.Expect("    result:=process(data)\n}"),
-			wantErr: false,
-		},
-	}
-
-	for _, tt := range tests {
-		t.Run(tt.name, func(t *testing.T) {
-			snippet, err := grader.getCodeSnippet(tenanttest.TestContext(), tt.diagnostic, map[string]FileContent{})
-			if tt.wantErr {
-				require.Error(t, err)
-				return
+			tt.wantSummary.Equal(t, *result.Feedback.Comment)
+			assert.Equal(t, tt.wantType, *result.Feedback.ConfusionLabel)
+			assert.Equal(t, goapi.ReviewDiagnosticEvaluationAuthorTypeLlmJudge, result.Feedback.Author.Type)
+			assert.Equal(t, GRADER_MODEL, *result.Feedback.Author.LlmJudge)
+			if tt.wantRewrite != nil {
+				require.True(t, result.NewDiagnostic.IsSome())
+				newDiagnostic := result.NewDiagnostic.Unwrap()
+				tt.wantRewrite.Equal(t, newDiagnostic.Message)
+			}
+			if newLocation, ok := tt.wantNewLocation.Get(); ok {
+				require.True(t, result.NewDiagnostic.IsSome())
+				assert.Equal(t, newLocation, result.NewDiagnostic.Unwrap().Location)
+			}
+			if tt.wantNewLocation.IsNone() && tt.wantRewrite == nil {
+				assert.Equal(t, result.NewDiagnostic, core.None[goapi.ReviewDiagnostic]())
 			}
-			require.NoError(t, err)
-			tt.want.Equal(t, string(snippet))
 		})
 	}
 }
@@ -526,6 +932,16 @@ func TestGetCodeSnippet(t *testing.T) {
 // testFileContent implements the FileContent interface for testing
 type testFileContent struct {
 	content string
+	diff    *diff.FileDiff
+}
+
+func newTestFileContent(t *testing.T, content string) FileContent {
+	diff, err := diff.ParseFileDiff([]byte(content))
+	require.NoError(t, err)
+	return &testFileContent{
+		content: content,
+		diff:    diff,
+	}
 }
 
 func (f *testFileContent) GetContent() []byte {
@@ -536,46 +952,17 @@ func (f *testFileContent) GetPath() string {
 	return "test.go"
 }
 
-func setupGrader(t *testing.T) Grader {
-	completions, modelConfig := anthropic.NewTestClientWithModel(t, "claude-3-7-sonnet-latest")
-	client := llmutils.NewTestingLLMChatClient(completions, modelConfig)
-
-	// Create mock git client that returns static file content
-	git := gitservermocks.NewMockClient()
-	git.NewFileReaderFunc.SetDefaultHook(func(ctx context.Context, repoID api.RepoID, commitID api.CommitID, path string) (io.ReadCloser, error) {
-		// Return different content based on line number to test different scenarios
-		content := ""
-		switch path {
-		case "test.go":
-			content = defaultFileContent
-		}
-		return io.NopCloser(strings.NewReader(content)), nil
-	})
-
-	// Create mock DB
-	db := dbmocks.NewMockDB()
-	repos := dbmocks.NewMockRepoStore()
-	repos.GetByNameFunc.SetDefaultReturn(&types.Repo{ID: 1}, nil)
-	db.ReposFunc.SetDefaultReturn(repos)
-
-	return NewGrader(client, git, db, 1)
+func (f *testFileContent) GetDiff() *diff.FileDiff {
+	return f.diff
 }
 
-var defaultCache = map[string]FileContent{
-	"test.go": &testFileContent{
-		content: defaultFileContent,
-	},
+func (f *testFileContent) GetLanguage() string {
+	return "go"
 }
 
-var defaultFileContent = `package test
-
-func example() {
-    // Line 4: Poor variable name
-    x := 42
-
-    // Line 7: Good variable name
-    userCount := 100
+func setupGrader(t *testing.T) Grader {
+	completions, modelConfig := anthropic.NewTestClientWithModel(t, "claude-3-7-sonnet-latest")
+	client := llmutils.NewTestingLLMChatClient(completions, modelConfig)
 
-    // Line 10: Ambiguous formatting
-    result:=process(data)
-}`
+	return NewGrader(client, 1)
+}
diff --git a/internal/review/grader/scripts/fetch-pr-comment.ts b/internal/review/grader/scripts/fetch-pr-comment.ts
index 4d735c2fc8be..38cc92f009cc 100755
--- a/internal/review/grader/scripts/fetch-pr-comment.ts
+++ b/internal/review/grader/scripts/fetch-pr-comment.ts
@@ -16,6 +16,7 @@ interface CommentOutput {
     body: string
     created_at: string
     path: string
+    original_commit_id: string
     commit_id: string
     line: number
     start_line: number
@@ -23,6 +24,7 @@ interface CommentOutput {
     original_start_line: number
     diff_hunk: string
     rule_instructions?: string
+    html_url: string
 }
 
 interface PullRequestOutput {
@@ -65,17 +67,26 @@ function extractSourcegraphRuleUrl(text: string): string | null {
 }
 
 function formatTestCase({ comment, pr, ruleInstructions, title, isGoodDiagnostic }: Checkpoint): string {
-    // Count lines in diff_hunk to determine the end line
-    const lineCount = (comment.diff_hunk.match(/\n/g) || []).length + 1
+    // Construct the full git diff header
+    const diffHeader = `diff --git a/${comment.path} b/${comment.path}
+index ${comment.original_commit_id.slice(0, 12)}..${comment.commit_id.slice(0, 12)} 100644
+--- a/${comment.path}
++++ b/${comment.path}
+${comment.diff_hunk}`
+
+    const metadata = parseDiagnosticMetadata(comment.body)
 
     // Format the test case
-    return `{
+    return `
+   // URL to regenerate: ${comment.html_url}
+   // Review URL: ${getReviewUrl(metadata)}
+   // Diagnostic URL: ${getDiagnosticUrl(metadata)}
+    {
     name: "${title || `test case from ${comment.id}`}",
-    cache: map[string]FileContent{
-        "${comment.path}": &testFileContent{
-            content: \`${formatDiffHunk(comment.diff_hunk)}\`,
-        },
-    },
+    diff: newTestFileContent(
+        t,
+        \`${diffHeader}\`,
+    ),
     diagnostic: goapi.ReviewDiagnostic{
         Message: "${formatCommentBody(comment.body)}",
         Location: goapi.Location{
@@ -84,10 +95,10 @@ function formatTestCase({ comment, pr, ruleInstructions, title, isGoodDiagnostic
             Oid: "${comment.commit_id}",
             Range: &goapi.Range{
                 Start: &goapi.Position{
-                    Line: ${lineCount},
+                    Line: ${comment.line},
                 },
                 End: &goapi.Position{
-                    Line: ${lineCount},
+                    Line: ${comment.line},
                 },
             },
         },
@@ -115,8 +126,33 @@ function formatCommentBody(body: string): string {
     )
 }
 
-function formatDiffHunk(hunk: string): string {
-    return hunk.replaceAll(/\n\+/g, '\n').replace(/@@.*@@/, '')
+function getReviewUrl({ endpoint, agent_id, review_id }: DiagnosticMetadata): string {
+    return `https://${endpoint}/agents/${agent_id}/reviews/${review_id}`
+}
+
+function getDiagnosticUrl({ endpoint, agent_id, diagnostic_id }: DiagnosticMetadata): string {
+    return `https://${endpoint}/agents/${agent_id}/diagnostics?filter_diagnostic_ids=${diagnostic_id}`
+}
+
+function parseDiagnosticMetadata(body: string): DiagnosticMetadata {
+    const metadataMatch = body.match(/<!--sourcegraph\/review-agent:diagnostic-metadata\s*({.*?})\s*-->/s)
+    if (!metadataMatch?.[1]) {
+        throw new Error('No diagnostic metadata found')
+    }
+    return {
+        ...{
+            endpoint: process.env.SRC_ENDPOINT || 'sourcegraph.sourcegraph.com',
+            agent_id: process.env.AGENT_ID || '1',
+        },
+        ...JSON.parse(metadataMatch[1]),
+    }
+}
+
+interface DiagnosticMetadata {
+    review_id: string
+    diagnostic_id: string
+    endpoint: string
+    agent_id: string
 }
 
 function formatRuleInstructions(instructions?: string): string {
diff --git a/internal/review/grader/testdata/TestGradeDiagnostic.recording.yaml b/internal/review/grader/testdata/TestGradeDiagnostic.recording.yaml
index fd924d3404b3..815482a64c5e 100644
--- a/internal/review/grader/testdata/TestGradeDiagnostic.recording.yaml
+++ b/internal/review/grader/testdata/TestGradeDiagnostic.recording.yaml
@@ -1,12 +1,10 @@
 recordings:
-- hash: deb00cc0fe82ff8d411a721e48d4d3aba6a426cc6a4cc348d0e5c879684305a9
+- hash: d79beeacea71bddb5d6f7687f14dac9f46f9ed70ca7d77c3fcfd1333e79a5a05
   request:
-    recording_date: "2025-03-21T00:08:02Z"
+    recording_date: "2025-04-07T21:44:56-07:00"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
-    - key: Cache-Control
-      value: no-cache
     - key: Accept
       value: application/json
     - key: Content-Type
@@ -17,14 +15,21 @@ recordings:
       value: "2023-06-01"
     - key: X-Api-Key
       value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
+    - key: Cache-Control
+      value: no-cache
     body: |
       max_tokens: 4000
       messages:
       - content:
-        - text: '<diagnostic><code_snippet>func example() {&#xA;    // Line 4: Poor variable
-            name&#xA;    x := 42</code_snippet><diagnostic_message>Consider using a more
-            descriptive variable name here</diagnostic_message><rule_instruction>Check if
-            variable names are descriptive and follow camelCase convention</rule_instruction></diagnostic>'
+        - text: "You are Cody, an expert AI code reviewer.\n\n<diagnostic><git_diff><![CDATA[diff
+            --git a/test.go b/test.go\n\t\t\t\t\tindex abc123..abc123 100644\n\t\t\t\t\t---
+            a/test.go\n\t\t\t\t\t+++ b/test.go\n\n\t\t\t\t\tdex f527f7183a10..f527f7183a10
+            100644\n--- a/cmd/gitserver/internal/patch_test.go\n+++ b/cmd/gitserver/internal/patch_test.go\n@@
+            -0,0 +1,12 @@\nHEAD L5: +     x := 42\nHEAD L6: +\nHEAD L7: +     // Line 7:
+            Good variable name\n]]></git_diff><language>go</language><diagnostic_info><message>Consider
+            using a more descriptive variable name that follows camelCase convention instead
+            of single-letter &#39;x&#39;</message><start_line>6</start_line></diagnostic_info><rule_instruction>Check
+            if variable names are descriptive and follow camelCase convention</rule_instruction></diagnostic>"
           type: text
         role: user
       model: claude-3-7-sonnet-latest
@@ -45,16 +50,28 @@ recordings:
 
         Provide a brief summary explaining your reasoning for the classification.
 
-        Your response can only be submitted via the evaluate_diagnostic tool.
+        IMPORTANT: Only use the rewrite_diagnostic_message tool if one of these conditions are met:
+        1. The diff contains a violation of the rule, but the diagnostic message does not correctly identify the issue
+        2. The current diagnostic message is unclear, confusing, or significantly inaccurate and you can provide a substantially clearer explanation of the same issue
+
+        IMPORTANT: Only use the rewrite_diagnostic_location tool if one of these conditions are met:
+        1. The diagnostic correctly identifies an issue in the code snippet but is pointing to the wrong line number
+        2. The diagnostic should cover a different range of lines to better highlight the problematic code
+
+        For all other cases, including when the diagnostic is invalid or when the message and location are already adequate, proceed directly to the evaluate_diagnostic tool without attempting to rewrite anything.
+
+        Your response can only be submitted via the evaluate_diagnostic tool after optionally using the rewrite_diagnostic_message or rewrite_diagnostic_location tools.
       tools:
       - description: Evaluate whether a diagnostic is a valid violation of a rule
         input_schema:
           properties:
             helpfulness_label:
-              description: Whether the diagnostic is a valid violation of the rule
+              description: The sentiment of the reaction to the diagnostic according to
+                the likert scale
               enum:
               - strongly-agree
               - agree
+              - neutral
               - disagree
               - strongly-disagree
               type: string
@@ -62,27 +79,54 @@ recordings:
               description: A summary of why the diagnostic is or is not a valid violation
               type: string
           required:
-          - summary
           - helpfulness_label
+          - summary
           type: object
         name: evaluate_diagnostic
+      - description: Update the location of the diagnostic if it is incorrectly placed
+        input_schema:
+          properties:
+            newStartLine:
+              description: The corrected start line number for the diagnostic
+              type: integer
+            reasoning:
+              description: A brief explanation of why the location was updated
+              type: string
+          required:
+          - newStartLine
+          - reasoning
+          type: object
+        name: relocate_diagnostic
+      - description: Rewrite the diagnostic message to more accurately describe the issue
+        input_schema:
+          properties:
+            newMessage:
+              description: The rewritten diagnostic message that better describes the issue
+              type: string
+            reasoning:
+              description: A brief explanation of why the message was rewritten
+              type: string
+          required:
+          - newMessage
+          - reasoning
+          type: object
+        name: rewrite_diagnostic_message
   response:
     status_code: 200
-    body: '{"id":"msg_01RUEHkm27fCLyWKSVhatdvb","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I''ll
-      evaluate whether this diagnostic is a valid violation of the rule by analyzing
-      the code snippet, diagnostic message, and rule instruction."},{"type":"tool_use","id":"toolu_0157niF2bDjtoZzBZQrEqaY3","name":"evaluate_diagnostic","input":{"helpfulness_label":"strongly-agree","summary":"The
-      diagnostic correctly identifies a clear violation of the rule. The variable
-      name ''x'' is not descriptive as it doesn''t indicate what the variable represents
-      or its purpose. The rule specifically instructs to \"Check if variable names
-      are descriptive,\" and ''x'' is a single-letter name that provides no information
-      about its meaning or usage in the code. A more descriptive name following camelCase
-      convention would better comply with the rule."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":728,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":191}}'
+    body: '{"id":"msg_01NDBeUFCcBK7g6LKzjN7NYD","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I''ll
+      evaluate this diagnostic for you. First, I need to determine if the diagnostic
+      is valid and properly placed.\n\nLooking at the code snippet, I can see that
+      the diagnostic is pointing to line 6, which is an empty line. However, the actual
+      variable declaration `x := 42` appears on line 5. Let me correct the location
+      first."},{"type":"tool_use","id":"toolu_01RfiVH5KY3jCCZyfXcpykgC","name":"relocate_diagnostic","input":{"newStartLine":5,"reasoning":"The
+      diagnostic should point to line 5 where the variable ''x'' is declared, not
+      line 6 which is an empty line."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":176}}'
     headers:
     - key: Content-Type
       value: application/json
-- hash: abb072d74410b53ab6686552629e98d138bf4e5a19582f743ad35efe6cad8703
+- hash: f09336d14fc83b5139944eda8e188447ce851aaabf11f2e20f6be67f2bf09221
   request:
-    recording_date: "2025-03-21T00:08:06Z"
+    recording_date: "2025-04-07T21:45:00-07:00"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
@@ -102,12 +146,38 @@ recordings:
       max_tokens: 4000
       messages:
       - content:
-        - text: '<diagnostic><code_snippet>&#xA;    // Line 7: Good variable name&#xA;    userCount
-            := 100</code_snippet><diagnostic_message>Consider using a more descriptive variable
-            name here</diagnostic_message><rule_instruction>Check if variable names are
-            descriptive and follow camelCase convention</rule_instruction></diagnostic>'
+        - text: "You are Cody, an expert AI code reviewer.\n\n<diagnostic><git_diff><![CDATA[diff
+            --git a/test.go b/test.go\n\t\t\t\t\tindex abc123..abc123 100644\n\t\t\t\t\t---
+            a/test.go\n\t\t\t\t\t+++ b/test.go\n\n\t\t\t\t\tdex f527f7183a10..f527f7183a10
+            100644\n--- a/cmd/gitserver/internal/patch_test.go\n+++ b/cmd/gitserver/internal/patch_test.go\n@@
+            -0,0 +1,12 @@\nHEAD L5: +     x := 42\nHEAD L6: +\nHEAD L7: +     // Line 7:
+            Good variable name\n]]></git_diff><language>go</language><diagnostic_info><message>Consider
+            using a more descriptive variable name that follows camelCase convention instead
+            of single-letter &#39;x&#39;</message><start_line>6</start_line></diagnostic_info><rule_instruction>Check
+            if variable names are descriptive and follow camelCase convention</rule_instruction></diagnostic>"
           type: text
         role: user
+      - content:
+        - text: |-
+            I'll evaluate this diagnostic for you. First, I need to determine if the diagnostic is valid and properly placed.
+
+            Looking at the code snippet, I can see that the diagnostic is pointing to line 6, which is an empty line. However, the actual variable declaration `x := 42` appears on line 5. Let me correct the location first.
+          type: text
+        role: assistant
+      - content:
+        - id: toolu_01RfiVH5KY3jCCZyfXcpykgC
+          input:
+            newStartLine: 5
+            reasoning: The diagnostic should point to line 5 where the variable 'x' is declared,
+              not line 6 which is an empty line.
+          name: relocate_diagnostic
+          type: tool_use
+        role: assistant
+      - content:
+        - content: Successfully relocated diagnostic
+          tool_use_id: toolu_01RfiVH5KY3jCCZyfXcpykgC
+          type: tool_result
+        role: user
       model: claude-3-7-sonnet-latest
       system: |
         You are Cody, an expert AI code reviewer specializing in evaluating whether code review diagnostics are valid violations of rules.
@@ -126,16 +196,28 @@ recordings:
 
         Provide a brief summary explaining your reasoning for the classification.
 
-        Your response can only be submitted via the evaluate_diagnostic tool.
+        IMPORTANT: Only use the rewrite_diagnostic_message tool if one of these conditions are met:
+        1. The diff contains a violation of the rule, but the diagnostic message does not correctly identify the issue
+        2. The current diagnostic message is unclear, confusing, or significantly inaccurate and you can provide a substantially clearer explanation of the same issue
+
+        IMPORTANT: Only use the rewrite_diagnostic_location tool if one of these conditions are met:
+        1. The diagnostic correctly identifies an issue in the code snippet but is pointing to the wrong line number
+        2. The diagnostic should cover a different range of lines to better highlight the problematic code
+
+        For all other cases, including when the diagnostic is invalid or when the message and location are already adequate, proceed directly to the evaluate_diagnostic tool without attempting to rewrite anything.
+
+        Your response can only be submitted via the evaluate_diagnostic tool after optionally using the rewrite_diagnostic_message or rewrite_diagnostic_location tools.
       tools:
       - description: Evaluate whether a diagnostic is a valid violation of a rule
         input_schema:
           properties:
             helpfulness_label:
-              description: Whether the diagnostic is a valid violation of the rule
+              description: The sentiment of the reaction to the diagnostic according to
+                the likert scale
               enum:
               - strongly-agree
               - agree
+              - neutral
               - disagree
               - strongly-disagree
               type: string
@@ -143,28 +225,185 @@ recordings:
               description: A summary of why the diagnostic is or is not a valid violation
               type: string
           required:
+          - helpfulness_label
           - summary
+          type: object
+        name: evaluate_diagnostic
+      - description: Update the location of the diagnostic if it is incorrectly placed
+        input_schema:
+          properties:
+            newStartLine:
+              description: The corrected start line number for the diagnostic
+              type: integer
+            reasoning:
+              description: A brief explanation of why the location was updated
+              type: string
+          required:
+          - newStartLine
+          - reasoning
+          type: object
+        name: relocate_diagnostic
+      - description: Rewrite the diagnostic message to more accurately describe the issue
+        input_schema:
+          properties:
+            newMessage:
+              description: The rewritten diagnostic message that better describes the issue
+              type: string
+            reasoning:
+              description: A brief explanation of why the message was rewritten
+              type: string
+          required:
+          - newMessage
+          - reasoning
+          type: object
+        name: rewrite_diagnostic_message
+  response:
+    status_code: 200
+    body: '{"id":"msg_01Nf1gNJNK73TqgmTWp36Yr3","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"Now
+      let me evaluate if this diagnostic is a valid violation of the rule:"},{"type":"tool_use","id":"toolu_017EWNTY2gonue4ByqeHXb1h","name":"evaluate_diagnostic","input":{"helpfulness_label":"strongly-agree","summary":"The
+      diagnostic correctly identifies that the variable name ''x'' is a single-letter
+      name that lacks descriptive meaning. The rule specifies checking for both descriptive
+      variable names and camelCase convention. The variable ''x'' is not descriptive
+      as it doesn''t indicate its purpose or content, and it doesn''t follow camelCase
+      convention which would require a meaningful name with appropriate capitalization.
+      Using a more descriptive variable name like ''value'', ''count'', or ''numberValue''
+      would improve code readability and meet the rule''s requirements."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1508,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":205}}'
+    headers:
+    - key: Content-Type
+      value: application/json
+- hash: 65c54bda25a4d49071dfc1961639d5b4741297dfaff0edc8e0b8aff977f5014f
+  request:
+    recording_date: "2025-04-07T21:51:23-07:00"
+    url: https://api.anthropic.com/v1/messages
+    method: POST
+    headers:
+    - key: Cache-Control
+      value: no-cache
+    - key: Accept
+      value: application/json
+    - key: Content-Type
+      value: application/json
+    - key: Client
+      value: sourcegraph/1.0
+    - key: Anthropic-Version
+      value: "2023-06-01"
+    - key: X-Api-Key
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
+    body: |
+      max_tokens: 4000
+      messages:
+      - content:
+        - text: "You are Cody, an expert AI code reviewer.\n\n<diagnostic><git_diff><![CDATA[diff
+            --git a/test.go b/test.go\n\t\t\t\t\tindex abc123..abc123 100644\n\t\t\t\t\t---
+            a/test.go\n\t\t\t\t\t+++ b/test.go\n\n\t\t\t\t\tdex f527f7183a10..f527f7183a10
+            100644\n--- a/cmd/gitserver/internal/patch_test.go\n+++ b/cmd/gitserver/internal/patch_test.go\n@@
+            -0,0 +1,12 @@\nHEAD L4: +     // Line 4: Poor variable name\nHEAD L5: +     x
+            := 42\nHEAD L6: +\n]]></git_diff><language>go</language><diagnostic_info><message>Consider
+            using a more descriptive variable name that follows camelCase convention instead
+            of single-letter &#39;x&#39;</message><start_line>5</start_line></diagnostic_info><rule_instruction>Check
+            if variable names are descriptive and follow camelCase convention</rule_instruction></diagnostic>"
+          type: text
+        role: user
+      model: claude-3-7-sonnet-latest
+      system: |
+        You are Cody, an expert AI code reviewer specializing in evaluating whether code review diagnostics are valid violations of rules.
+
+        Your task is to evaluate whether a diagnostic is a valid violation of a rule by analyzing:
+        1. The code snippet where the diagnostic appears
+        2. The diagnostic message explaining the issue
+        3. The rule's instruction defining what it checks for
+
+        You should classify the diagnostic as:
+        - strongly-agree: The diagnostic is definitely a valid violation of the rule
+        - agree: The diagnostic is likely a valid violation of the rule
+        - neutral: The diagnostic is not clear whether it is a valid violation of the rule
+        - disagree: The diagnostic is likely not a valid violation of the rule
+        - strongly-disagree: The diagnostic is definitely not a valid violation of the rule
+
+        Provide a brief summary explaining your reasoning for the classification.
+
+        IMPORTANT: Only use the rewrite_diagnostic_message tool if one of these conditions are met:
+        1. The diff contains a violation of the rule, but the diagnostic message does not correctly identify the issue
+        2. The current diagnostic message is unclear, confusing, or significantly inaccurate and you can provide a substantially clearer explanation of the same issue
+
+        IMPORTANT: Only use the rewrite_diagnostic_location tool if one of these conditions are met:
+        1. The diagnostic correctly identifies an issue in the code snippet but is pointing to the wrong line number
+        2. The diagnostic should cover a different range of lines to better highlight the problematic code
+
+        For all other cases, including when the diagnostic is invalid or when the message and location are already adequate, proceed directly to the evaluate_diagnostic tool without attempting to rewrite anything.
+
+        Your response can only be submitted via the evaluate_diagnostic tool after optionally using the rewrite_diagnostic_message or rewrite_diagnostic_location tools.
+      tools:
+      - description: Evaluate whether a diagnostic is a valid violation of a rule
+        input_schema:
+          properties:
+            helpfulness_label:
+              description: The sentiment of the reaction to the diagnostic according to
+                the likert scale
+              enum:
+              - strongly-agree
+              - agree
+              - neutral
+              - disagree
+              - strongly-disagree
+              type: string
+            summary:
+              description: A summary of why the diagnostic is or is not a valid violation
+              type: string
+          required:
           - helpfulness_label
+          - summary
           type: object
         name: evaluate_diagnostic
+      - description: Update the location of the diagnostic if it is incorrectly placed
+        input_schema:
+          properties:
+            newStartLine:
+              description: The corrected start line number for the diagnostic
+              type: integer
+            reasoning:
+              description: A brief explanation of why the location was updated
+              type: string
+          required:
+          - newStartLine
+          - reasoning
+          type: object
+        name: relocate_diagnostic
+      - description: Rewrite the diagnostic message to more accurately describe the issue
+        input_schema:
+          properties:
+            newMessage:
+              description: The rewritten diagnostic message that better describes the issue
+              type: string
+            reasoning:
+              description: A brief explanation of why the message was rewritten
+              type: string
+          required:
+          - newMessage
+          - reasoning
+          type: object
+        name: rewrite_diagnostic_message
   response:
     status_code: 200
-    body: '{"id":"msg_012eYEvRnRiyNPovHrA4J25T","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I''ll
-      evaluate whether this diagnostic is a valid violation of the rule by analyzing
-      the code snippet, diagnostic message, and rule instruction."},{"type":"tool_use","id":"toolu_01DZdv8C5zjHMQ77mbpotBm8","name":"evaluate_diagnostic","input":{"helpfulness_label":"disagree","summary":"The
-      diagnostic suggests that \"userCount\" should have a more descriptive name,
-      but \"userCount\" is actually a good, descriptive variable name that clearly
-      communicates its purpose (counting users) and follows camelCase convention as
-      required by the rule. The variable name is specific enough to understand what
-      it represents and adheres to the naming convention mentioned in the rule instruction.
-      The comment \"// Line 7: Good variable name\" also indicates that the original
-      author considered this a well-named variable."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":725,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":201}}'
+    body: '{"id":"msg_018FbMPn1re2FZtDouetT7Jt","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I''ll
+      evaluate this diagnostic which flags a single-letter variable name in Go code.
+      Let me check if this is a valid violation of the rule that requires descriptive
+      variable names following camelCase convention."},{"type":"tool_use","id":"toolu_01Y46zQbRGnuegeQEhZimdhg","name":"evaluate_diagnostic","input":{"helpfulness_label":"strongly-agree","summary":"The
+      diagnostic correctly identifies a variable name that violates both parts of
+      the rule: (1) The variable ''x'' is a single-letter name that is not descriptive
+      of its purpose, and (2) while single-letter variables are technically in camelCase
+      format, they don''t provide the semantic benefits that descriptive camelCase
+      names offer. Single-letter variable names should typically only be used in very
+      limited contexts like loop counters or when the purpose is extremely obvious
+      from immediate context, but in this case ''x'' is assigned a numeric value without
+      clear context about what the number represents. A more descriptive name like
+      ''defaultValue'' or ''maxCount'' would be much clearer."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1318,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":262}}'
     headers:
     - key: Content-Type
       value: application/json
-- hash: f1f76095c282f6afed5f8c87a6aebec1b5a8c7c6ba8f589751e0b812753f582f
+- hash: 57b103b517e5ed124527f9de942429a6661d8170a00461ed241fc5de7fb6cedd
   request:
-    recording_date: "2025-03-21T00:08:13Z"
+    recording_date: "2025-04-07T21:51:28-07:00"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
@@ -184,30 +423,14 @@ recordings:
       max_tokens: 4000
       messages:
       - content:
-        - text: '<diagnostic><code_snippet>&#x9;&#x9;},&#xA;&#x9;&#x9;Push: nil,</code_snippet><diagnostic_message>**go-initialization-nil(warning)**
-            Avoid implicit nil initialization of Push and PushRef fields. Make initialization
-            explicit in CreateCommitFromPatchRequest.</diagnostic_message><rule_instruction>#
-            Go conditionals## Prefer switch over if for checking enum cases_Rationale:_
-            Go doesn&#39;t have native support for pattern-matching. However, we can use
-            the [exhaustive](https://github.com/nishanths/exhaustive) linter in the future
-            to get exhaustiveness checking for enums. This relies on using switch statements.go//
-            Bad - using if statements for enumsif status == StatusPending {    // handle
-            pending} else if status == StatusActive {    // handle active} else if status
-            == StatusSuspended {    // handle suspended}// Good - using switch for enumsswitch
-            status {case StatusPending:    // handle pendingcase StatusActive:    // handle
-            activecase StatusSuspended:    // handle suspendeddefault:    // Handle unknown
-            case or use core.PanicUnknownEnumCase}## Switch statements must use a default
-            branch_Description_: If the default case is impossible to hit in practice, use
-            core.PanicUnknownEnumCase (). Otherwise, handle that case appropriately.goswitch
-            status {case StatusPending:    // handle pendingcase StatusActive:    // handle
-            activecase StatusSuspended:    // handle suspendeddefault:    // Option 1: For
-            cases where default should never be reached    core.PanicUnknownEnumCase(status)        //
-            Option 2: For cases where default is a valid possibility    handleUnknownStatus(status)}_Rationale_:
-            This adds an extra safeguard in case:- Some code incorrectly materializes an
-            enum value (e.g. JSON unmarshaling etc.) that is invalid.- The exhaustive linter
-            is not yet enabled for the whole package (rollout will be tricky for larger
-            packages).- The exhaustive linter is disabled by someone for a specific type
-            for some reason, and they then write a non-exhaustive match.</rule_instruction></diagnostic>'
+        - text: "You are Cody, an expert AI code reviewer.\n\n<diagnostic><git_diff><![CDATA[diff
+            --git a/test.go b/test.go\n\t\t\t\t\tindex abc123..abc123 100644\n\t\t\t\t\t---
+            a/test.go\n\t\t\t\t\t+++ b/test.go\n\n\t\t\t\t\tdex f527f7183a10..f527f7183a10
+            100644\n--- a/cmd/gitserver/internal/patch_test.go\n+++ b/cmd/gitserver/internal/patch_test.go\n@@
+            -0,0 +1,12 @@\nHEAD L7: +     // Line 7: Good variable name\nHEAD L8: +     userCount
+            := 100\nHEAD L9: +\n]]></git_diff><language>go</language><diagnostic_info><message>Consider
+            using a more descriptive variable name here</message><start_line>8</start_line></diagnostic_info><rule_instruction>Check
+            if variable names are descriptive and follow camelCase convention</rule_instruction></diagnostic>"
           type: text
         role: user
       model: claude-3-7-sonnet-latest
@@ -228,16 +451,28 @@ recordings:
 
         Provide a brief summary explaining your reasoning for the classification.
 
-        Your response can only be submitted via the evaluate_diagnostic tool.
+        IMPORTANT: Only use the rewrite_diagnostic_message tool if one of these conditions are met:
+        1. The diff contains a violation of the rule, but the diagnostic message does not correctly identify the issue
+        2. The current diagnostic message is unclear, confusing, or significantly inaccurate and you can provide a substantially clearer explanation of the same issue
+
+        IMPORTANT: Only use the rewrite_diagnostic_location tool if one of these conditions are met:
+        1. The diagnostic correctly identifies an issue in the code snippet but is pointing to the wrong line number
+        2. The diagnostic should cover a different range of lines to better highlight the problematic code
+
+        For all other cases, including when the diagnostic is invalid or when the message and location are already adequate, proceed directly to the evaluate_diagnostic tool without attempting to rewrite anything.
+
+        Your response can only be submitted via the evaluate_diagnostic tool after optionally using the rewrite_diagnostic_message or rewrite_diagnostic_location tools.
       tools:
       - description: Evaluate whether a diagnostic is a valid violation of a rule
         input_schema:
           properties:
             helpfulness_label:
-              description: Whether the diagnostic is a valid violation of the rule
+              description: The sentiment of the reaction to the diagnostic according to
+                the likert scale
               enum:
               - strongly-agree
               - agree
+              - neutral
               - disagree
               - strongly-disagree
               type: string
@@ -245,36 +480,188 @@ recordings:
               description: A summary of why the diagnostic is or is not a valid violation
               type: string
           required:
+          - helpfulness_label
           - summary
+          type: object
+        name: evaluate_diagnostic
+      - description: Update the location of the diagnostic if it is incorrectly placed
+        input_schema:
+          properties:
+            newStartLine:
+              description: The corrected start line number for the diagnostic
+              type: integer
+            reasoning:
+              description: A brief explanation of why the location was updated
+              type: string
+          required:
+          - newStartLine
+          - reasoning
+          type: object
+        name: relocate_diagnostic
+      - description: Rewrite the diagnostic message to more accurately describe the issue
+        input_schema:
+          properties:
+            newMessage:
+              description: The rewritten diagnostic message that better describes the issue
+              type: string
+            reasoning:
+              description: A brief explanation of why the message was rewritten
+              type: string
+          required:
+          - newMessage
+          - reasoning
+          type: object
+        name: rewrite_diagnostic_message
+  response:
+    status_code: 200
+    body: '{"id":"msg_01AT2ytPseV9WeauEQ1N3mZE","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I''ll
+      evaluate this diagnostic for you by analyzing the code and the rule it''s supposed
+      to violate.\n\nLooking at the code snippet, I can see a variable declaration
+      on line 8:\n```go\nuserCount := 100\n```\n\nThe diagnostic message states \"Consider
+      using a more descriptive variable name here\" and points to this line. However,
+      the variable name \"userCount\" seems to be:\n1. Following camelCase convention
+      (starts with lowercase, uses uppercase for word separation)\n2. Is descriptive
+      (clearly indicates it''s counting users)\n\nThis variable name appears to be
+      following the exact practices the rule is checking for - it''s descriptive and
+      follows camelCase."},{"type":"tool_use","id":"toolu_01F3kQQxNPGFA3BsoPPbHWe5","name":"evaluate_diagnostic","input":{"helpfulness_label":"strongly-disagree","summary":"The
+      diagnostic incorrectly flags \"userCount\" as a non-descriptive variable name.
+      \"userCount\" is actually a good example of a descriptive variable name that
+      follows camelCase convention. It clearly indicates its purpose (counting users)
+      and follows proper Go naming conventions with lowercase first letter and camelCase
+      for word separation. This is a false positive that should be ignored."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1302,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":298}}'
+    headers:
+    - key: Content-Type
+      value: application/json
+- hash: 53860cd37b3f13cd3a865455985cee42ba1c98a1b9df5dbae5f35173c8494904
+  request:
+    recording_date: "2025-04-07T21:51:33-07:00"
+    url: https://api.anthropic.com/v1/messages
+    method: POST
+    headers:
+    - key: X-Api-Key
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
+    - key: Cache-Control
+      value: no-cache
+    - key: Accept
+      value: application/json
+    - key: Content-Type
+      value: application/json
+    - key: Client
+      value: sourcegraph/1.0
+    - key: Anthropic-Version
+      value: "2023-06-01"
+    body: |
+      max_tokens: 4000
+      messages:
+      - content:
+        - text: "You are Cody, an expert AI code reviewer.\n\n<diagnostic><git_diff><![CDATA[diff
+            --git a/test.go b/test.go\n\t\t\t\t\tindex abc123..abc123 100644\n\t\t\t\t\t---
+            a/test.go\n\t\t\t\t\t+++ b/test.go\n\n\t\t\t\t\tdex f527f7183a10..f527f7183a10
+            100644\n--- a/cmd/gitserver/internal/patch_test.go\n+++ b/cmd/gitserver/internal/patch_test.go\n@@
+            -0,0 +1,12 @@\nHEAD L4: +     // Line 4: Poor variable name\nHEAD L5: +     x
+            := 42\nHEAD L6: +\n]]></git_diff><language>go</language><diagnostic_info><message>This
+            line is too long and should be split into multiple lines</message><start_line>5</start_line></diagnostic_info><rule_instruction>Check
+            if variable names are descriptive and follow camelCase convention</rule_instruction></diagnostic>"
+          type: text
+        role: user
+      model: claude-3-7-sonnet-latest
+      system: |
+        You are Cody, an expert AI code reviewer specializing in evaluating whether code review diagnostics are valid violations of rules.
+
+        Your task is to evaluate whether a diagnostic is a valid violation of a rule by analyzing:
+        1. The code snippet where the diagnostic appears
+        2. The diagnostic message explaining the issue
+        3. The rule's instruction defining what it checks for
+
+        You should classify the diagnostic as:
+        - strongly-agree: The diagnostic is definitely a valid violation of the rule
+        - agree: The diagnostic is likely a valid violation of the rule
+        - neutral: The diagnostic is not clear whether it is a valid violation of the rule
+        - disagree: The diagnostic is likely not a valid violation of the rule
+        - strongly-disagree: The diagnostic is definitely not a valid violation of the rule
+
+        Provide a brief summary explaining your reasoning for the classification.
+
+        IMPORTANT: Only use the rewrite_diagnostic_message tool if one of these conditions are met:
+        1. The diff contains a violation of the rule, but the diagnostic message does not correctly identify the issue
+        2. The current diagnostic message is unclear, confusing, or significantly inaccurate and you can provide a substantially clearer explanation of the same issue
+
+        IMPORTANT: Only use the rewrite_diagnostic_location tool if one of these conditions are met:
+        1. The diagnostic correctly identifies an issue in the code snippet but is pointing to the wrong line number
+        2. The diagnostic should cover a different range of lines to better highlight the problematic code
+
+        For all other cases, including when the diagnostic is invalid or when the message and location are already adequate, proceed directly to the evaluate_diagnostic tool without attempting to rewrite anything.
+
+        Your response can only be submitted via the evaluate_diagnostic tool after optionally using the rewrite_diagnostic_message or rewrite_diagnostic_location tools.
+      tools:
+      - description: Evaluate whether a diagnostic is a valid violation of a rule
+        input_schema:
+          properties:
+            helpfulness_label:
+              description: The sentiment of the reaction to the diagnostic according to
+                the likert scale
+              enum:
+              - strongly-agree
+              - agree
+              - neutral
+              - disagree
+              - strongly-disagree
+              type: string
+            summary:
+              description: A summary of why the diagnostic is or is not a valid violation
+              type: string
+          required:
           - helpfulness_label
+          - summary
           type: object
         name: evaluate_diagnostic
+      - description: Update the location of the diagnostic if it is incorrectly placed
+        input_schema:
+          properties:
+            newStartLine:
+              description: The corrected start line number for the diagnostic
+              type: integer
+            reasoning:
+              description: A brief explanation of why the location was updated
+              type: string
+          required:
+          - newStartLine
+          - reasoning
+          type: object
+        name: relocate_diagnostic
+      - description: Rewrite the diagnostic message to more accurately describe the issue
+        input_schema:
+          properties:
+            newMessage:
+              description: The rewritten diagnostic message that better describes the issue
+              type: string
+            reasoning:
+              description: A brief explanation of why the message was rewritten
+              type: string
+          required:
+          - newMessage
+          - reasoning
+          type: object
+        name: rewrite_diagnostic_message
   response:
     status_code: 200
-    body: '{"id":"msg_01LZNHbetbVQ2tx3g41P1MbX","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I''ll
-      analyze whether this diagnostic is a valid violation of the rule by examining
-      the code snippet, diagnostic message, and rule instruction.\n\nThe diagnostic
-      message indicates a warning about \"implicit nil initialization of Push and
-      PushRef fields,\" recommending explicit initialization in CreateCommitFromPatchRequest.\n\nHowever,
-      the provided rule instruction focuses on:\n1. Preferring switch statements over
-      if statements for enum cases\n2. Requiring default branches in switch statements\n\nLooking
-      at the code snippet `Push: nil,`, I don''t see any relation to conditional statements
-      or enum handling. This appears to be related to field initialization in a struct,
-      not conditional logic or switch statements.\n\nLet me evaluate this diagnostic
-      using the tool:"},{"type":"tool_use","id":"toolu_011FYkmKgVThBUxdvawwQ3Ag","name":"evaluate_diagnostic","input":{"helpfulness_label":"strongly-disagree","summary":"The
-      diagnostic is not a valid violation of the provided rule. The rule instruction
-      focuses on using switch statements for enums and including default branches
-      in switch statements, but the diagnostic flags an issue with nil initialization
-      of fields in a struct. These are completely unrelated concerns - the diagnostic
-      addresses initialization practices while the rule pertains to conditional statement
-      patterns and enum handling. There appears to be a mismatch between the diagnostic
-      and the rule it claims to enforce."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1156,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":312}}'
+    body: '{"id":"msg_01E3L5vhD12vzmggsjyjV4fN","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I''ll
+      evaluate this diagnostic for you.\n\nLooking at the diagnostic message and code,
+      I see a mismatch. The diagnostic claims line 5 is too long and should be split
+      into multiple lines, but the actual code (`x := 42`) is quite short, and the
+      rule is about variable naming conventions, not line length.\n\nI should rewrite
+      the diagnostic message to correctly address the variable naming issue:"},{"type":"tool_use","id":"toolu_01UQt4f3DMjkWQR44CrMW6iR","name":"rewrite_diagnostic_message","input":{"newMessage":"Variable
+      name ''x'' is not descriptive and doesn''t follow camelCase convention","reasoning":"The
+      original message incorrectly claimed the line was too long. The actual issue
+      is that ''x'' is a poor variable name as indicated by the comment in line 4.
+      The rule specifically checks for descriptive variable names that follow camelCase
+      convention, which ''x'' doesn''t satisfy."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1304,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":237}}'
     headers:
     - key: Content-Type
       value: application/json
-- hash: 85a4bbe96c3293af9d661e051498af1311278cd8c5d3a7f8cd5aaf37938e62c6
+- hash: e24b10caa306f9f2dd7f7e80c5dd98ca6926913b75f19d6d7e310a700e6f549e
   request:
-    recording_date: "2025-03-24T22:14:44Z"
+    recording_date: "2025-04-07T21:51:37-07:00"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
@@ -294,15 +681,326 @@ recordings:
       max_tokens: 4000
       messages:
       - content:
-        - text: '<diagnostic><code_snippet> &#x9;&#34;github.com/sourcegraph/sourcegraph/lib/errors&#34;&#xA;
-            &#x9;&#34;github.com/sourcegraph/sourcegraph/lib/maps&#34;</code_snippet><diagnostic_message>**[external_url](https://sourcegraph.sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/.sourcegraph/external_url.rule.md)**
+        - text: "You are Cody, an expert AI code reviewer.\n\n<diagnostic><git_diff><![CDATA[diff
+            --git a/test.go b/test.go\n\t\t\t\t\tindex abc123..abc123 100644\n\t\t\t\t\t---
+            a/test.go\n\t\t\t\t\t+++ b/test.go\n\n\t\t\t\t\tdex f527f7183a10..f527f7183a10
+            100644\n--- a/cmd/gitserver/internal/patch_test.go\n+++ b/cmd/gitserver/internal/patch_test.go\n@@
+            -0,0 +1,12 @@\nHEAD L4: +     // Line 4: Poor variable name\nHEAD L5: +     x
+            := 42\nHEAD L6: +\n]]></git_diff><language>go</language><diagnostic_info><message>This
+            line is too long and should be split into multiple lines</message><start_line>5</start_line></diagnostic_info><rule_instruction>Check
+            if variable names are descriptive and follow camelCase convention</rule_instruction></diagnostic>"
+          type: text
+        role: user
+      - content:
+        - text: |-
+            I'll evaluate this diagnostic for you.
+
+            Looking at the diagnostic message and code, I see a mismatch. The diagnostic claims line 5 is too long and should be split into multiple lines, but the actual code (`x := 42`) is quite short, and the rule is about variable naming conventions, not line length.
+
+            I should rewrite the diagnostic message to correctly address the variable naming issue:
+          type: text
+        role: assistant
+      - content:
+        - id: toolu_01UQt4f3DMjkWQR44CrMW6iR
+          input:
+            newMessage: Variable name 'x' is not descriptive and doesn't follow camelCase
+              convention
+            reasoning: The original message incorrectly claimed the line was too long. The
+              actual issue is that 'x' is a poor variable name as indicated by the comment
+              in line 4. The rule specifically checks for descriptive variable names that
+              follow camelCase convention, which 'x' doesn't satisfy.
+          name: rewrite_diagnostic_message
+          type: tool_use
+        role: assistant
+      - content:
+        - content: Successfully rewrote diagnostic message
+          tool_use_id: toolu_01UQt4f3DMjkWQR44CrMW6iR
+          type: tool_result
+        role: user
+      model: claude-3-7-sonnet-latest
+      system: |
+        You are Cody, an expert AI code reviewer specializing in evaluating whether code review diagnostics are valid violations of rules.
+
+        Your task is to evaluate whether a diagnostic is a valid violation of a rule by analyzing:
+        1. The code snippet where the diagnostic appears
+        2. The diagnostic message explaining the issue
+        3. The rule's instruction defining what it checks for
+
+        You should classify the diagnostic as:
+        - strongly-agree: The diagnostic is definitely a valid violation of the rule
+        - agree: The diagnostic is likely a valid violation of the rule
+        - neutral: The diagnostic is not clear whether it is a valid violation of the rule
+        - disagree: The diagnostic is likely not a valid violation of the rule
+        - strongly-disagree: The diagnostic is definitely not a valid violation of the rule
+
+        Provide a brief summary explaining your reasoning for the classification.
+
+        IMPORTANT: Only use the rewrite_diagnostic_message tool if one of these conditions are met:
+        1. The diff contains a violation of the rule, but the diagnostic message does not correctly identify the issue
+        2. The current diagnostic message is unclear, confusing, or significantly inaccurate and you can provide a substantially clearer explanation of the same issue
+
+        IMPORTANT: Only use the rewrite_diagnostic_location tool if one of these conditions are met:
+        1. The diagnostic correctly identifies an issue in the code snippet but is pointing to the wrong line number
+        2. The diagnostic should cover a different range of lines to better highlight the problematic code
+
+        For all other cases, including when the diagnostic is invalid or when the message and location are already adequate, proceed directly to the evaluate_diagnostic tool without attempting to rewrite anything.
+
+        Your response can only be submitted via the evaluate_diagnostic tool after optionally using the rewrite_diagnostic_message or rewrite_diagnostic_location tools.
+      tools:
+      - description: Evaluate whether a diagnostic is a valid violation of a rule
+        input_schema:
+          properties:
+            helpfulness_label:
+              description: The sentiment of the reaction to the diagnostic according to
+                the likert scale
+              enum:
+              - strongly-agree
+              - agree
+              - neutral
+              - disagree
+              - strongly-disagree
+              type: string
+            summary:
+              description: A summary of why the diagnostic is or is not a valid violation
+              type: string
+          required:
+          - helpfulness_label
+          - summary
+          type: object
+        name: evaluate_diagnostic
+      - description: Update the location of the diagnostic if it is incorrectly placed
+        input_schema:
+          properties:
+            newStartLine:
+              description: The corrected start line number for the diagnostic
+              type: integer
+            reasoning:
+              description: A brief explanation of why the location was updated
+              type: string
+          required:
+          - newStartLine
+          - reasoning
+          type: object
+        name: relocate_diagnostic
+      - description: Rewrite the diagnostic message to more accurately describe the issue
+        input_schema:
+          properties:
+            newMessage:
+              description: The rewritten diagnostic message that better describes the issue
+              type: string
+            reasoning:
+              description: A brief explanation of why the message was rewritten
+              type: string
+          required:
+          - newMessage
+          - reasoning
+          type: object
+        name: rewrite_diagnostic_message
+  response:
+    status_code: 200
+    body: '{"id":"msg_019qpj9ro74xNBgjnujrTnEC","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"Now
+      I''ll evaluate whether this diagnostic is a valid violation of the rule:"},{"type":"tool_use","id":"toolu_01Ms4cSYruZCbWJWx3ZDzio2","name":"evaluate_diagnostic","input":{"helpfulness_label":"strongly-agree","summary":"The
+      diagnostic correctly identifies a violation of the rule. The variable ''x''
+      on line 5 is a single-letter name that is not descriptive and doesn''t follow
+      camelCase convention. The rule explicitly states to check if variable names
+      are descriptive and follow camelCase convention, which ''x'' clearly fails to
+      do. Single-letter variables are generally considered non-descriptive unless
+      used in very specific contexts like loop indices or mathematical formulas."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1558,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":185}}'
+    headers:
+    - key: Content-Type
+      value: application/json
+- hash: 0f71d73e1ac84fec22fef6cc33ac63e063c3d772e750922d4ef70e553ee7aa83
+  request:
+    recording_date: "2025-04-07T21:51:44-07:00"
+    url: https://api.anthropic.com/v1/messages
+    method: POST
+    headers:
+    - key: Content-Type
+      value: application/json
+    - key: Client
+      value: sourcegraph/1.0
+    - key: Anthropic-Version
+      value: "2023-06-01"
+    - key: X-Api-Key
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
+    - key: Cache-Control
+      value: no-cache
+    - key: Accept
+      value: application/json
+    body: |
+      max_tokens: 4000
+      messages:
+      - content:
+        - text: "You are Cody, an expert AI code reviewer.\n\n<diagnostic><git_diff><![CDATA[diff
+            --git a/cmd/gitserver/internal/patch_test.go b/cmd/gitserver/internal/patch_test.go\nindex
+            f527f7183a10..f527f7183a10 100644\n--- a/cmd/gitserver/internal/patch_test.go\n+++
+            b/cmd/gitserver/internal/patch_test.go\n@@ -0,0 +1,250 @@\nHEAD L243: +\tfsDir
+            := removeGitDirSuffix(repoDir)\nHEAD L244: +\tcheck.MustNoError(t, os.WriteFile(path.Join(fsDir,
+            filename), []byte(contents), 0644), \"os.WriteFile\")\nHEAD L245:\n]]></git_diff><language>go</language><diagnostic_info><message>**go-conditionals(warning)**
+            Empty string check using os.WriteFile return value should use explicit len()
+            check or strings.TrimSpace() in gitAdd() function.</message><start_line>244</start_line></diagnostic_info><rule_instruction>#
+            Go conditionals&#xA;&#xA;## Prefer switch over if for checking enum cases&#xA;&#xA;_Rationale:_
+            Go doesn&#39;t have native support for pattern-matching. However, we can use
+            the [exhaustive](https://github.com/nishanths/exhaustive) linter in the future
+            to get exhaustiveness checking for enums. This relies on using switch statements.&#xA;&#xA;go&#xA;//
+            Bad - using if statements for enums&#xA;if status == StatusPending {&#xA;    //
+            handle pending&#xA;} else if status == StatusActive {&#xA;    // handle active&#xA;}
+            else if status == StatusSuspended {&#xA;    // handle suspended&#xA;}&#xA;&#xA;//
+            Good - using switch for enums&#xA;switch status {&#xA;case StatusPending:&#xA;
+            \   // handle pending&#xA;case StatusActive:&#xA;    // handle active&#xA;case
+            StatusSuspended:&#xA;    // handle suspended&#xA;default:&#xA;    // Handle
+            unknown case or use core.PanicUnknownEnumCase&#xA;}&#xA;&#xA;&#xA;## Switch
+            statements must use a default branch&#xA;&#xA;_Description_: If the default
+            case is impossible to hit in practice, use core.PanicUnknownEnumCase (). Otherwise,
+            handle that case appropriately.&#xA;&#xA;go&#xA;switch status {&#xA;case StatusPending:&#xA;
+            \   // handle pending&#xA;case StatusActive:&#xA;    // handle active&#xA;case
+            StatusSuspended:&#xA;    // handle suspended&#xA;default:&#xA;    // Option
+            1: For cases where default should never be reached&#xA;    core.PanicUnknownEnumCase(status)&#xA;&#xA;
+            \   // Option 2: For cases where default is a valid possibility&#xA;    handleUnknownStatus(status)&#xA;}&#xA;&#xA;&#xA;_Rationale_:
+            This adds an extra safeguard in case:&#xA;- Some code incorrectly materializes
+            an enum value (e.g. JSON unmarshaling etc.) that is invalid.&#xA;- The exhaustive
+            linter is not yet enabled for the whole package (rollout will be tricky for
+            larger packages).&#xA;- The exhaustive linter is disabled by someone for a specific
+            type for some reason, and they then write a non-exhaustive match.</rule_instruction></diagnostic>"
+          type: text
+        role: user
+      model: claude-3-7-sonnet-latest
+      system: |
+        You are Cody, an expert AI code reviewer specializing in evaluating whether code review diagnostics are valid violations of rules.
+
+        Your task is to evaluate whether a diagnostic is a valid violation of a rule by analyzing:
+        1. The code snippet where the diagnostic appears
+        2. The diagnostic message explaining the issue
+        3. The rule's instruction defining what it checks for
+
+        You should classify the diagnostic as:
+        - strongly-agree: The diagnostic is definitely a valid violation of the rule
+        - agree: The diagnostic is likely a valid violation of the rule
+        - neutral: The diagnostic is not clear whether it is a valid violation of the rule
+        - disagree: The diagnostic is likely not a valid violation of the rule
+        - strongly-disagree: The diagnostic is definitely not a valid violation of the rule
+
+        Provide a brief summary explaining your reasoning for the classification.
+
+        IMPORTANT: Only use the rewrite_diagnostic_message tool if one of these conditions are met:
+        1. The diff contains a violation of the rule, but the diagnostic message does not correctly identify the issue
+        2. The current diagnostic message is unclear, confusing, or significantly inaccurate and you can provide a substantially clearer explanation of the same issue
+
+        IMPORTANT: Only use the rewrite_diagnostic_location tool if one of these conditions are met:
+        1. The diagnostic correctly identifies an issue in the code snippet but is pointing to the wrong line number
+        2. The diagnostic should cover a different range of lines to better highlight the problematic code
+
+        For all other cases, including when the diagnostic is invalid or when the message and location are already adequate, proceed directly to the evaluate_diagnostic tool without attempting to rewrite anything.
+
+        Your response can only be submitted via the evaluate_diagnostic tool after optionally using the rewrite_diagnostic_message or rewrite_diagnostic_location tools.
+      tools:
+      - description: Evaluate whether a diagnostic is a valid violation of a rule
+        input_schema:
+          properties:
+            helpfulness_label:
+              description: The sentiment of the reaction to the diagnostic according to
+                the likert scale
+              enum:
+              - strongly-agree
+              - agree
+              - neutral
+              - disagree
+              - strongly-disagree
+              type: string
+            summary:
+              description: A summary of why the diagnostic is or is not a valid violation
+              type: string
+          required:
+          - helpfulness_label
+          - summary
+          type: object
+        name: evaluate_diagnostic
+      - description: Update the location of the diagnostic if it is incorrectly placed
+        input_schema:
+          properties:
+            newStartLine:
+              description: The corrected start line number for the diagnostic
+              type: integer
+            reasoning:
+              description: A brief explanation of why the location was updated
+              type: string
+          required:
+          - newStartLine
+          - reasoning
+          type: object
+        name: relocate_diagnostic
+      - description: Rewrite the diagnostic message to more accurately describe the issue
+        input_schema:
+          properties:
+            newMessage:
+              description: The rewritten diagnostic message that better describes the issue
+              type: string
+            reasoning:
+              description: A brief explanation of why the message was rewritten
+              type: string
+          required:
+          - newMessage
+          - reasoning
+          type: object
+        name: rewrite_diagnostic_message
+  response:
+    status_code: 200
+    body: '{"id":"msg_01TSxZzpFujKohCZPpPRfLcC","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I''ll
+      analyze this diagnostic to determine if it''s a valid violation of the Go conditionals
+      rule.\n\nFirst, let''s understand what we''re looking at:\n\n1. The code snippet
+      shows a test file with a line calling `os.WriteFile`\n2. The diagnostic is warning
+      about an \"empty string check using os.WriteFile return value\" that should
+      use `len()` or `strings.TrimSpace()`\n3. The diagnostic points to line 244\n\nLooking
+      at the rule instruction, it covers two aspects of Go conditionals:\n- Preferring
+      switch over if for checking enum cases\n- Ensuring switch statements have a
+      default branch\n\nThe diagnostic message mentions checking for empty strings,
+      but the code shown doesn''t contain any conditional logic or empty string checks
+      - it simply calls `os.WriteFile`. Also, the diagnostic mentions a `gitAdd()`
+      function that isn''t visible in the provided code snippet."},{"type":"tool_use","id":"toolu_01UASP51AWgRFyYK9uSwKrsB","name":"evaluate_diagnostic","input":{"helpfulness_label":"strongly-disagree","summary":"The
+      diagnostic is invalid because there is no conditional logic or empty string
+      checking in the provided code. The code simply calls os.WriteFile to write a
+      file with some content. The diagnostic message references a \"gitAdd()\" function
+      that isn''t visible in the snippet. Additionally, the rule instruction is about
+      using switch over if statements for enums and ensuring switch statements have
+      default branches, neither of which applies to the shown code. There''s no relation
+      between the code snippet and the reported issue about empty string checks."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1963,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":371}}'
+    headers:
+    - key: Content-Type
+      value: application/json
+- hash: f515cc9d1e6c8ad84330336822a21aa363f50355c5536a63d8c906e16b8ef39f
+  request:
+    recording_date: "2025-04-07T21:51:50-07:00"
+    url: https://api.anthropic.com/v1/messages
+    method: POST
+    headers:
+    - key: Accept
+      value: application/json
+    - key: Content-Type
+      value: application/json
+    - key: Client
+      value: sourcegraph/1.0
+    - key: Anthropic-Version
+      value: "2023-06-01"
+    - key: X-Api-Key
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
+    - key: Cache-Control
+      value: no-cache
+    body: |
+      max_tokens: 4000
+      messages:
+      - content:
+        - text: "You are Cody, an expert AI code reviewer.\n\n<diagnostic><git_diff><![CDATA[diff
+            --git a/internal/rule/service.go b/internal/rule/service.go\nindex ea7e4c7678e0..4167e0928ee5
+            100644\n--- a/internal/rule/service.go\n+++ b/internal/rule/service.go\n@@ -16,6
+            +16,7 @@ import (\nHEAD L17:  \t\"github.com/sourcegraph/sourcegraph/lib/errors\"\nHEAD
+            L18:  \t\"github.com/sourcegraph/sourcegraph/lib/maps\"\nHEAD L19:\n]]></git_diff><language>go</language><diagnostic_info><message>**[external_url](https://sourcegraph.sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/.sourcegraph/external_url.rule.md)**
             ExternalURL should be retrieved via db.Conf().GetExternalURL(ctx) instead of
-            conf package for Enterprise Starter support</diagnostic_message><rule_instruction>Check
+            conf package for Enterprise Starter support</message><start_line>18</start_line></diagnostic_info><rule_instruction>Check
             for incorrect access patterns of conf.Get().ExternalURL:&#xA;&#xA;The external
             URL should always be retrieved from the database&#xA;Correct pattern: db.Conf().GetExternalURL(ctx)&#xA;The
             external URL should never be retrieved from the conf package&#xA;Incorrect pattern:
             conf.SiteConfig().ExternalURL&#xA;Explain that this is a requirement for Enterprise
-            Starter (aka. Multitenant) because the external URL depends on the current tenant</rule_instruction></diagnostic>'
+            Starter (aka. Multitenant) because the external URL depends on the current tenant</rule_instruction></diagnostic>"
           type: text
         role: user
       model: claude-3-7-sonnet-latest
@@ -323,16 +1021,28 @@ recordings:
 
         Provide a brief summary explaining your reasoning for the classification.
 
-        Your response can only be submitted via the evaluate_diagnostic tool.
+        IMPORTANT: Only use the rewrite_diagnostic_message tool if one of these conditions are met:
+        1. The diff contains a violation of the rule, but the diagnostic message does not correctly identify the issue
+        2. The current diagnostic message is unclear, confusing, or significantly inaccurate and you can provide a substantially clearer explanation of the same issue
+
+        IMPORTANT: Only use the rewrite_diagnostic_location tool if one of these conditions are met:
+        1. The diagnostic correctly identifies an issue in the code snippet but is pointing to the wrong line number
+        2. The diagnostic should cover a different range of lines to better highlight the problematic code
+
+        For all other cases, including when the diagnostic is invalid or when the message and location are already adequate, proceed directly to the evaluate_diagnostic tool without attempting to rewrite anything.
+
+        Your response can only be submitted via the evaluate_diagnostic tool after optionally using the rewrite_diagnostic_message or rewrite_diagnostic_location tools.
       tools:
       - description: Evaluate whether a diagnostic is a valid violation of a rule
         input_schema:
           properties:
             helpfulness_label:
-              description: Whether the diagnostic is a valid violation of the rule
+              description: The sentiment of the reaction to the diagnostic according to
+                the likert scale
               enum:
               - strongly-agree
               - agree
+              - neutral
               - disagree
               - strongly-disagree
               type: string
@@ -340,39 +1050,64 @@ recordings:
               description: A summary of why the diagnostic is or is not a valid violation
               type: string
           required:
-          - summary
           - helpfulness_label
+          - summary
           type: object
         name: evaluate_diagnostic
+      - description: Update the location of the diagnostic if it is incorrectly placed
+        input_schema:
+          properties:
+            newStartLine:
+              description: The corrected start line number for the diagnostic
+              type: integer
+            reasoning:
+              description: A brief explanation of why the location was updated
+              type: string
+          required:
+          - newStartLine
+          - reasoning
+          type: object
+        name: relocate_diagnostic
+      - description: Rewrite the diagnostic message to more accurately describe the issue
+        input_schema:
+          properties:
+            newMessage:
+              description: The rewritten diagnostic message that better describes the issue
+              type: string
+            reasoning:
+              description: A brief explanation of why the message was rewritten
+              type: string
+          required:
+          - newMessage
+          - reasoning
+          type: object
+        name: rewrite_diagnostic_message
   response:
     status_code: 200
-    body: '{"id":"msg_015EQmjxmPnXxHTMxnwzk5Vy","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I
-      need to evaluate whether this diagnostic correctly identifies a violation of
-      the rule about retrieving ExternalURL. \n\nLooking at the diagnostic, I notice:\n1.
-      The code snippet only shows imports for \"github.com/sourcegraph/sourcegraph/lib/errors\"
-      and \"github.com/sourcegraph/sourcegraph/lib/maps\"\n2. The diagnostic message
-      indicates an \"external_url\" rule violation, claiming ExternalURL should be
-      retrieved via db.Conf().GetExternalURL(ctx)\n3. The rule prohibits using conf.SiteConfig().ExternalURL
-      and requires using db.Conf().GetExternalURL(ctx)\n\nHowever, the code snippet
-      doesn''t actually show any code accessing ExternalURL - it only shows import
-      statements. There''s no evidence in the provided code that confirms the rule
-      violation mentioned in the diagnostic message.\n\nLet me evaluate this diagnostic:"},{"type":"tool_use","id":"toolu_01H9sHP9dpiUv3d6gwJaKTxR","name":"evaluate_diagnostic","input":{"helpfulness_label":"strongly-disagree","summary":"The
-      diagnostic claims a violation of the ExternalURL access pattern rule, but the
-      code snippet only shows import statements for \"errors\" and \"maps\" packages.
-      There is no actual code shown that accesses ExternalURL in any way, whether
-      through the prohibited conf package or otherwise. Without seeing the actual
-      access pattern in the code, it''s impossible to determine if there''s a rule
-      violation. The diagnostic appears to be completely unfounded based on the provided
-      code snippet."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":925,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":362}}'
+    body: '{"id":"msg_01P2xm7LECdmxte9pb5W8vgh","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I
+      need to evaluate this diagnostic, but I''m looking at a git diff that doesn''t
+      actually show any code related to external URL access. The diff only shows import
+      statements and doesn''t contain any code that would violate the rule about using
+      `conf.Get().ExternalURL` instead of `db.Conf().GetExternalURL(ctx)`.\n\nThe
+      diagnostic is positioned at line 18, which only shows an import statement: `\"github.com/sourcegraph/sourcegraph/lib/maps\"`."},{"type":"tool_use","id":"toolu_0114X29Lbme1Btrnk3g9vUvq","name":"evaluate_diagnostic","input":{"helpfulness_label":"strongly-disagree","summary":"The
+      diagnostic is incorrectly flagging an issue that doesn''t exist in the shown
+      code. The git diff only displays import statements and doesn''t contain any
+      code related to accessing the external URL. Line 18 specifically only shows
+      the import statement for \"github.com/sourcegraph/sourcegraph/lib/maps\" and
+      there''s no evidence of improper external URL access patterns in the visible
+      code. This appears to be a completely misplaced diagnostic as there''s no violation
+      of the external_url rule in the provided code snippet."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1462,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":295}}'
     headers:
     - key: Content-Type
       value: application/json
-- hash: 0de44dc37dbfa8faec0f2bd2646e0322679406eaa415a821c1b55bfd4bd4d554
+- hash: 4c58e3272df745e3280eac0851f5f652e0a6ed8572646baf92086ccfe3ecc4ff
   request:
-    recording_date: "2025-03-24T22:35:37Z"
+    recording_date: "2025-04-07T21:51:56-07:00"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
+    - key: X-Api-Key
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
     - key: Cache-Control
       value: no-cache
     - key: Accept
@@ -383,29 +1118,35 @@ recordings:
       value: sourcegraph/1.0
     - key: Anthropic-Version
       value: "2023-06-01"
-    - key: X-Api-Key
-      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
     body: |
       max_tokens: 4000
       messages:
       - content:
-        - text: '<diagnostic><code_snippet>&#xA;&#x9;if err := h.db.Rules().Delete(r.Context(),
-            id); err != nil {</code_snippet><diagnostic_message>**[security-common-issues](https://sourcegraph.sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/.sourcegraph/security-common-issues.rule.md)**
-            Rule deletion should verify user has permissions to delete rule</diagnostic_message><rule_instruction>As
-            an expert security reviewer, examine the code for common security issues while
-            maintaining a low false positive rate. In your review, consider the following
-            areas:&#xA;&#xA;Input Validation and Sanitization: Ensure that all external
-            inputs are properly validated and sanitized to prevent injection and related
-            attacks.&#xA;Authentication &amp; Authorization: Confirm that secure and robust
-            mechanisms are used, avoiding hardcoded credentials and insecure session management.&#xA;Error
-            Handling: Verify that error handling does not expose sensitive information in
-            error messages or logs.&#xA;Secure Configuration &amp; Cryptography: Check that
-            secure defaults are used, cryptographic libraries are up-to-date, and weak algorithms
-            are avoided.&#xA;Logging Practices: Ensure that logs do not inadvertently store
-            sensitive information.&#xA;Secret Handling: Secrets are stored securely rather
-            than in code, use constant-time comparisons against user input,&#xA;Focus on
-            identifying issues that could lead to significant security risks. When flagging
-            potential issues, provide clear explanations and recommendations for remediation.</rule_instruction></diagnostic>'
+        - text: "You are Cody, an expert AI code reviewer.\n\n<diagnostic><git_diff><![CDATA[diff
+            --git a/cmd/frontend/internal/ruleapi/handler_rule.go b/cmd/frontend/internal/ruleapi/handler_rule.go\nindex
+            ea7e4c7678e0..c350236ea636 100644\n--- a/cmd/frontend/internal/ruleapi/handler_rule.go\n+++
+            b/cmd/frontend/internal/ruleapi/handler_rule.go\n@@ -43,6 +45,93 @@ func (h
+            *ruleHandler) HandleRetrieveRules(w http.ResponseWriter, r *http.Request\nHEAD
+            L126: +\nHEAD L127: +\tif err := h.db.Rules().Delete(r.Context(), id); err !=
+            nil {\nHEAD L128:\n]]></git_diff><language>go</language><diagnostic_info><message>**[security-common-issues](https://sourcegraph.sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/.sourcegraph/security-common-issues.rule.md)**
+            Rule deletion should verify user has permissions to delete rule</message><start_line>127</start_line></diagnostic_info><rule_instruction>---&#xA;title:
+            Security Common Issues&#xA;description: Reviews code changes for adherence to
+            common security best practices and the potential introduction of vulnerabilities&#xA;tags:
+            [\\&#34;security\\&#34;, \\&#34;generic\\&#34;]&#xA;---&#xA;&#xA;As an expert
+            security reviewer, examine the code for common security issues while maintaining
+            a low false positive rate. In your review, consider the following areas:&#xA;
+            - Input Validation and Sanitization: Ensure that all external inputs are properly
+            validated and sanitized to prevent injection and related attacks.&#xA; - Authentication
+            &amp; Authorization: Confirm that secure and robust mechanisms are used, avoiding
+            hardcoded credentials and insecure session management.&#xA; - Error Handling:
+            Verify that error handling does not expose sensitive information in error messages
+            or logs.&#xA; - Secure Configuration &amp; Cryptography: Check that secure defaults
+            are used, cryptographic libraries are up-to-date, and weak algorithms are avoided.&#xA;
+            - Logging Practices: Ensure that logs do not inadvertently store sensitive information.&#xA;
+            - Secret Handling: Secrets are stored securely rather than in code, use constant-time
+            comparisons against user input,&#xA;&#xA;Focus on identifying issues that could
+            lead to significant security risks. When flagging potential issues, provide
+            clear explanations and recommendations for remediation.</rule_instruction></diagnostic>"
           type: text
         role: user
       model: claude-3-7-sonnet-latest
@@ -426,16 +1167,28 @@ recordings:
 
         Provide a brief summary explaining your reasoning for the classification.
 
-        Your response can only be submitted via the evaluate_diagnostic tool.
+        IMPORTANT: Only use the rewrite_diagnostic_message tool if one of these conditions are met:
+        1. The diff contains a violation of the rule, but the diagnostic message does not correctly identify the issue
+        2. The current diagnostic message is unclear, confusing, or significantly inaccurate and you can provide a substantially clearer explanation of the same issue
+
+        IMPORTANT: Only use the rewrite_diagnostic_location tool if one of these conditions are met:
+        1. The diagnostic correctly identifies an issue in the code snippet but is pointing to the wrong line number
+        2. The diagnostic should cover a different range of lines to better highlight the problematic code
+
+        For all other cases, including when the diagnostic is invalid or when the message and location are already adequate, proceed directly to the evaluate_diagnostic tool without attempting to rewrite anything.
+
+        Your response can only be submitted via the evaluate_diagnostic tool after optionally using the rewrite_diagnostic_message or rewrite_diagnostic_location tools.
       tools:
       - description: Evaluate whether a diagnostic is a valid violation of a rule
         input_schema:
           properties:
             helpfulness_label:
-              description: Whether the diagnostic is a valid violation of the rule
+              description: The sentiment of the reaction to the diagnostic according to
+                the likert scale
               enum:
               - strongly-agree
               - agree
+              - neutral
               - disagree
               - strongly-disagree
               type: string
@@ -443,26 +1196,57 @@ recordings:
               description: A summary of why the diagnostic is or is not a valid violation
               type: string
           required:
-          - summary
           - helpfulness_label
+          - summary
           type: object
         name: evaluate_diagnostic
+      - description: Update the location of the diagnostic if it is incorrectly placed
+        input_schema:
+          properties:
+            newStartLine:
+              description: The corrected start line number for the diagnostic
+              type: integer
+            reasoning:
+              description: A brief explanation of why the location was updated
+              type: string
+          required:
+          - newStartLine
+          - reasoning
+          type: object
+        name: relocate_diagnostic
+      - description: Rewrite the diagnostic message to more accurately describe the issue
+        input_schema:
+          properties:
+            newMessage:
+              description: The rewritten diagnostic message that better describes the issue
+              type: string
+            reasoning:
+              description: A brief explanation of why the message was rewritten
+              type: string
+          required:
+          - newMessage
+          - reasoning
+          type: object
+        name: rewrite_diagnostic_message
   response:
     status_code: 200
-    body: '{"id":"msg_01T86m19zD36dRh1E2ocHRq7","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I''ll
-      evaluate whether this diagnostic is a valid violation of the security-common-issues
-      rule. Let me analyze the code snippet, diagnostic message, and rule instruction."},{"type":"tool_use","id":"toolu_01WgWJ1rXWTGUbpV8VWe6CjA","name":"evaluate_diagnostic","input":{"helpfulness_label":"agree","summary":"The
-      diagnostic correctly identifies a potential authorization issue in the code.
-      The snippet shows a rule deletion operation (`h.db.Rules().Delete(r.Context(),
-      id)`) without any visible authorization check to verify that the user has permission
-      to delete the rule. This falls under the \"Authentication & Authorization\"
-      category in the rule instructions, which specifically mentions confirming that
-      robust authorization mechanisms are used. Without proper permission checking,
-      a user might be able to delete rules they shouldn''t have access to, creating
-      a privilege escalation vulnerability. However, since we only see a small code
-      snippet and can''t confirm if permission checks might exist elsewhere in the
-      call stack (such as in middleware or in the handler initialization), I can''t
-      \"strongly agree\" that this is definitely a violation."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1009,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":260}}'
+    body: '{"id":"msg_011bzPGHjj3JsG41KbHduDZH","type":"message","role":"assistant","model":"claude-3-7-sonnet-20250219","content":[{"type":"text","text":"I''ll
+      review this diagnostic to evaluate if it''s a valid violation of the security
+      rule.\n\nLooking at the code snippet, I can see this is a function that deletes
+      a rule from a database, but it''s missing authorization checks. The diagnostic
+      points out that rule deletion should verify user permissions before executing
+      the deletion.\n\nThis falls under the \"Authentication & Authorization\" category
+      in the rule instruction, which specifically mentions ensuring \"secure and robust
+      mechanisms are used\" for authorization."},{"type":"tool_use","id":"toolu_0116VSzExBHFsEHauhEWrJhS","name":"evaluate_diagnostic","input":{"helpfulness_label":"strongly-agree","summary":"The
+      diagnostic correctly identifies a security issue. The code shows a rule deletion
+      operation (`h.db.Rules().Delete`) without any visible authorization check to
+      verify that the user has appropriate permissions to perform this action. Implementing
+      permission checks before allowing deletion operations is a fundamental security
+      practice to prevent unauthorized data manipulation. This aligns with the rule''s
+      focus on Authentication & Authorization, specifically ensuring that \"secure
+      and robust mechanisms are used\" for access control. Without permission verification,
+      any user who can reach this endpoint could potentially delete rules they shouldn''t
+      have access to, creating a significant security vulnerability."}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1693,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":286}}'
     headers:
     - key: Content-Type
       value: application/json
diff --git a/internal/review/mocks_test.go b/internal/review/mocks_test.go
index 3a1a3767c807..6a3546726fee 100644
--- a/internal/review/mocks_test.go
+++ b/internal/review/mocks_test.go
@@ -683,7 +683,7 @@ type MockGrader struct {
 func NewMockGrader() *MockGrader {
 	return &MockGrader{
 		GradeFunc: &GraderGradeFunc{
-			defaultHook: func(context.Context, goapi.Rule, goapi.ReviewDiagnostic, map[string]grader.FileContent) (r0 goapi.ReviewDiagnosticFeedback, r1 error) {
+			defaultHook: func(context.Context, log.Logger, goapi.Rule, goapi.ReviewDiagnostic, grader.FileContent) (r0 grader.GradedDiagnostic, r1 error) {
 				return
 			},
 		},
@@ -695,7 +695,7 @@ func NewMockGrader() *MockGrader {
 func NewStrictMockGrader() *MockGrader {
 	return &MockGrader{
 		GradeFunc: &GraderGradeFunc{
-			defaultHook: func(context.Context, goapi.Rule, goapi.ReviewDiagnostic, map[string]grader.FileContent) (goapi.ReviewDiagnosticFeedback, error) {
+			defaultHook: func(context.Context, log.Logger, goapi.Rule, goapi.ReviewDiagnostic, grader.FileContent) (grader.GradedDiagnostic, error) {
 				panic("unexpected invocation of MockGrader.Grade")
 			},
 		},
@@ -715,23 +715,23 @@ func NewMockGraderFrom(i grader.Grader) *MockGrader {
 // GraderGradeFunc describes the behavior when the Grade method of the
 // parent MockGrader instance is invoked.
 type GraderGradeFunc struct {
-	defaultHook func(context.Context, goapi.Rule, goapi.ReviewDiagnostic, map[string]grader.FileContent) (goapi.ReviewDiagnosticFeedback, error)
-	hooks       []func(context.Context, goapi.Rule, goapi.ReviewDiagnostic, map[string]grader.FileContent) (goapi.ReviewDiagnosticFeedback, error)
+	defaultHook func(context.Context, log.Logger, goapi.Rule, goapi.ReviewDiagnostic, grader.FileContent) (grader.GradedDiagnostic, error)
+	hooks       []func(context.Context, log.Logger, goapi.Rule, goapi.ReviewDiagnostic, grader.FileContent) (grader.GradedDiagnostic, error)
 	history     []GraderGradeFuncCall
 	mutex       sync.Mutex
 }
 
 // Grade delegates to the next hook function in the queue and stores the
 // parameter and result values of this invocation.
-func (m *MockGrader) Grade(v0 context.Context, v1 goapi.Rule, v2 goapi.ReviewDiagnostic, v3 map[string]grader.FileContent) (goapi.ReviewDiagnosticFeedback, error) {
-	r0, r1 := m.GradeFunc.nextHook()(v0, v1, v2, v3)
-	m.GradeFunc.appendCall(GraderGradeFuncCall{v0, v1, v2, v3, r0, r1})
+func (m *MockGrader) Grade(v0 context.Context, v1 log.Logger, v2 goapi.Rule, v3 goapi.ReviewDiagnostic, v4 grader.FileContent) (grader.GradedDiagnostic, error) {
+	r0, r1 := m.GradeFunc.nextHook()(v0, v1, v2, v3, v4)
+	m.GradeFunc.appendCall(GraderGradeFuncCall{v0, v1, v2, v3, v4, r0, r1})
 	return r0, r1
 }
 
 // SetDefaultHook sets function that is called when the Grade method of the
 // parent MockGrader instance is invoked and the hook queue is empty.
-func (f *GraderGradeFunc) SetDefaultHook(hook func(context.Context, goapi.Rule, goapi.ReviewDiagnostic, map[string]grader.FileContent) (goapi.ReviewDiagnosticFeedback, error)) {
+func (f *GraderGradeFunc) SetDefaultHook(hook func(context.Context, log.Logger, goapi.Rule, goapi.ReviewDiagnostic, grader.FileContent) (grader.GradedDiagnostic, error)) {
 	f.defaultHook = hook
 }
 
@@ -739,7 +739,7 @@ func (f *GraderGradeFunc) SetDefaultHook(hook func(context.Context, goapi.Rule,
 // Grade method of the parent MockGrader instance invokes the hook at the
 // front of the queue and discards it. After the queue is empty, the default
 // hook function is invoked for any future action.
-func (f *GraderGradeFunc) PushHook(hook func(context.Context, goapi.Rule, goapi.ReviewDiagnostic, map[string]grader.FileContent) (goapi.ReviewDiagnosticFeedback, error)) {
+func (f *GraderGradeFunc) PushHook(hook func(context.Context, log.Logger, goapi.Rule, goapi.ReviewDiagnostic, grader.FileContent) (grader.GradedDiagnostic, error)) {
 	f.mutex.Lock()
 	f.hooks = append(f.hooks, hook)
 	f.mutex.Unlock()
@@ -747,20 +747,20 @@ func (f *GraderGradeFunc) PushHook(hook func(context.Context, goapi.Rule, goapi.
 
 // SetDefaultReturn calls SetDefaultHook with a function that returns the
 // given values.
-func (f *GraderGradeFunc) SetDefaultReturn(r0 goapi.ReviewDiagnosticFeedback, r1 error) {
-	f.SetDefaultHook(func(context.Context, goapi.Rule, goapi.ReviewDiagnostic, map[string]grader.FileContent) (goapi.ReviewDiagnosticFeedback, error) {
+func (f *GraderGradeFunc) SetDefaultReturn(r0 grader.GradedDiagnostic, r1 error) {
+	f.SetDefaultHook(func(context.Context, log.Logger, goapi.Rule, goapi.ReviewDiagnostic, grader.FileContent) (grader.GradedDiagnostic, error) {
 		return r0, r1
 	})
 }
 
 // PushReturn calls PushHook with a function that returns the given values.
-func (f *GraderGradeFunc) PushReturn(r0 goapi.ReviewDiagnosticFeedback, r1 error) {
-	f.PushHook(func(context.Context, goapi.Rule, goapi.ReviewDiagnostic, map[string]grader.FileContent) (goapi.ReviewDiagnosticFeedback, error) {
+func (f *GraderGradeFunc) PushReturn(r0 grader.GradedDiagnostic, r1 error) {
+	f.PushHook(func(context.Context, log.Logger, goapi.Rule, goapi.ReviewDiagnostic, grader.FileContent) (grader.GradedDiagnostic, error) {
 		return r0, r1
 	})
 }
 
-func (f *GraderGradeFunc) nextHook() func(context.Context, goapi.Rule, goapi.ReviewDiagnostic, map[string]grader.FileContent) (goapi.ReviewDiagnosticFeedback, error) {
+func (f *GraderGradeFunc) nextHook() func(context.Context, log.Logger, goapi.Rule, goapi.ReviewDiagnostic, grader.FileContent) (grader.GradedDiagnostic, error) {
 	f.mutex.Lock()
 	defer f.mutex.Unlock()
 
@@ -798,16 +798,19 @@ type GraderGradeFuncCall struct {
 	Arg0 context.Context
 	// Arg1 is the value of the 2nd argument passed to this method
 	// invocation.
-	Arg1 goapi.Rule
+	Arg1 log.Logger
 	// Arg2 is the value of the 3rd argument passed to this method
 	// invocation.
-	Arg2 goapi.ReviewDiagnostic
+	Arg2 goapi.Rule
 	// Arg3 is the value of the 4th argument passed to this method
 	// invocation.
-	Arg3 map[string]grader.FileContent
+	Arg3 goapi.ReviewDiagnostic
+	// Arg4 is the value of the 5th argument passed to this method
+	// invocation.
+	Arg4 grader.FileContent
 	// Result0 is the value of the 1st result returned from this method
 	// invocation.
-	Result0 goapi.ReviewDiagnosticFeedback
+	Result0 grader.GradedDiagnostic
 	// Result1 is the value of the 2nd result returned from this method
 	// invocation.
 	Result1 error
@@ -816,7 +819,7 @@ type GraderGradeFuncCall struct {
 // Args returns an interface slice containing the arguments of this
 // invocation.
 func (c GraderGradeFuncCall) Args() []interface{} {
-	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
+	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
 }
 
 // Results returns an interface slice containing the results of this
diff --git a/internal/review/service.go b/internal/review/service.go
index eaec27d1598e..2c8125ee626d 100644
--- a/internal/review/service.go
+++ b/internal/review/service.go
@@ -7,6 +7,7 @@ import (
 	"sort"
 	"time"
 
+	"github.com/sourcegraph/go-diff/diff"
 	sglog "github.com/sourcegraph/log"
 
 	"github.com/sourcegraph/sourcegraph/internal/api"
@@ -228,40 +229,54 @@ func (c *reviewService) ReviewCode(ctx context.Context, params ReviewCodeParams)
 	}
 
 	// grading
-	acceptedDiagnostics := make([]goapi.ReviewDiagnostic, 0, len(finalDiagnostics))
 	// Create a map of file contents from changedFiles
 	fileCache := make(map[string]grader.FileContent)
 	for _, file := range changedFiles {
 		fileCache[file.Path()] = &fileContentWrapper{file: &file}
 	}
-	for _, diagnostic := range finalDiagnostics {
+	for i, diagnostic := range finalDiagnostics {
 		// Get the full rule from the rules index
 		rule, ok := rulesIndex.Get(diagnostic.Rule.Uri)
 		if !ok {
-			return goapi.Review{}, errors.Newf("rule not found for diagnostic: %s", diagnostic.Rule.Uri)
+			c.Logger.Warn("rule not found for diagnostic, skipping", sglog.String("rule_uri", diagnostic.Rule.Uri))
+			continue
+		}
+		diff, ok := fileCache[diagnostic.Location.Path]
+		if !ok {
+			c.Logger.Warn("diff not found for diagnostic, skipping", sglog.String("diagnostic_location", fmt.Sprintf("%s:%d", diagnostic.Location.Path, diagnostic.Location.Range.Start.Line)))
+			continue
 		}
-		feedback, err := c.Grader.Grade(ctx, rule, diagnostic, fileCache)
+		gradedDiagnostic, err := c.Grader.Grade(ctx, c.Logger, rule, diagnostic, diff)
 		if err != nil {
 			return goapi.Review{}, errors.Wrap(err, "Grader.Grade")
 		}
-		if isFeedbackAcceptable(feedback) {
+		// If the grader has returned a new diagnostic, replace the old one
+		if newDiagnostic, ok := gradedDiagnostic.NewDiagnostic.Get(); ok {
+			diagnostic = newDiagnostic
+		}
+		// Add the graders feedback to the diagnostic
+		diagnostic.Feedback = &[]goapi.ReviewDiagnosticFeedback{gradedDiagnostic.Feedback}
+		if isFeedbackAcceptable(gradedDiagnostic.Feedback) {
 			c.Logger.Debug("diagnostic accepted",
 				sglog.String("diagnostic", diagnostic.Rule.Uri),
 				sglog.String("diagnostic_message", diagnostic.Message),
 				sglog.String("diagnostic_location", fmt.Sprintf("%s:%d", diagnostic.Location.Path, diagnostic.Location.Range.Start.Line)),
-				sglog.Stringp("reasoning", feedback.Comment),
+				sglog.Stringp("reasoning", gradedDiagnostic.Feedback.Comment),
 			)
-			acceptedDiagnostics = append(acceptedDiagnostics, diagnostic)
+			diagnostic.Quality = pointers.Ptr(goapi.DiagnosticQualityAccepted)
 		} else {
 			c.Logger.Info("diagnostic not accepted",
 				sglog.String("diagnostic", diagnostic.Rule.Uri),
 				sglog.String("diagnostic_message", diagnostic.Message),
 				sglog.String("diagnostic_location", fmt.Sprintf("%s:%d", diagnostic.Location.Path, diagnostic.Location.Range.Start.Line)),
-				sglog.Stringp("feedback", feedback.Comment),
+				sglog.Stringp("feedback", gradedDiagnostic.Feedback.Comment),
 			)
+			diagnostic.Quality = pointers.Ptr(goapi.DiagnosticQualityRejected)
 		}
+
+		// Overwrite the final diagnostic with the graded result
+		finalDiagnostics[i] = diagnostic
 	}
-	finalDiagnostics = acceptedDiagnostics
 
 	finalModelUsages := []goapi.ModelUsage{}
 	for model, usages := range llmapitelemetry.GetTokenUsages(ctx).TotalByModelRef() {
@@ -454,11 +469,11 @@ func isFeedbackAcceptable(feedback goapi.ReviewDiagnosticFeedback) bool {
 		return false
 	}
 
-	if *feedback.ConfusionLabel != goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive {
+	if *feedback.ConfusionLabel != goapi.ConfusionLabelTruePositive {
 		return false
 	}
 
-	return feedback.HelpfulnessScoreExceeds(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelNeutral)
+	return feedback.HelpfulnessScoreExceeds(goapi.LikertLabelNeutral)
 }
 
 // fileContentWrapper implements the grader.FileContent interface
@@ -466,10 +481,10 @@ type fileContentWrapper struct {
 	file *changedFile
 }
 
-func (w *fileContentWrapper) GetContent() []byte {
-	return w.file.Content
+func (w *fileContentWrapper) GetLanguage() string {
+	return w.file.Languages[0]
 }
 
-func (w *fileContentWrapper) GetPath() string {
-	return w.file.Path()
+func (w *fileContentWrapper) GetDiff() *diff.FileDiff {
+	return w.file.Diff
 }
diff --git a/internal/review/service_test.go b/internal/review/service_test.go
index d853d4a060e6..e195cb5b155d 100644
--- a/internal/review/service_test.go
+++ b/internal/review/service_test.go
@@ -23,6 +23,7 @@ import (
 	"github.com/sourcegraph/sourcegraph/internal/gitserver"
 	"github.com/sourcegraph/sourcegraph/internal/gitserver/gitservermocks"
 	"github.com/sourcegraph/sourcegraph/internal/llmapitelemetry"
+	grader "github.com/sourcegraph/sourcegraph/internal/review/grader"
 	"github.com/sourcegraph/sourcegraph/internal/rule"
 	"github.com/sourcegraph/sourcegraph/internal/telemetry/telemetrytest"
 	"github.com/sourcegraph/sourcegraph/internal/tenant/tenanttest"
@@ -353,6 +354,7 @@ func newTestService(t *testing.T, git *gitservermocks.MockClient) Service {
 	completions, modelConfig := anthropic.NewTestClient(t)
 	client := llmutils.NewTestingLLMChatClient(completions, modelConfig)
 	repos := dbmocks.NewMockRepoStore()
+	repos.GetFunc.SetDefaultReturn(&types.Repo{ID: 1}, nil)
 	repos.GetByNameFunc.SetDefaultReturn(&types.Repo{ID: 1}, nil)
 	db := dbmocks.NewMockDB()
 	db.ReposFunc.SetDefaultReturn(repos)
@@ -360,10 +362,12 @@ func newTestService(t *testing.T, git *gitservermocks.MockClient) Service {
 	fakes.WireSome(db, fakedb.FakeDBOptions{SkipAgents: true, SkipRepos: true})
 	rules := rule.NewService(git, db, logger)
 	recorder, _ := telemetrytest.NewRecorder()
-	grader := NewMockGrader()
-	grader.GradeFunc.SetDefaultReturn(goapi.ReviewDiagnosticFeedback{
-		HelpfulnessLabel: pointers.Ptr(goapi.ReviewDiagnosticFeedbackHelpfulnessLabelAgree),
-		ConfusionLabel:   pointers.Ptr(goapi.ReviewDiagnosticFeedbackConfusionLabelTruePositive),
+	mockGrader := NewMockGrader()
+	mockGrader.GradeFunc.SetDefaultReturn(grader.GradedDiagnostic{
+		Feedback: goapi.ReviewDiagnosticFeedback{
+			HelpfulnessLabel: pointers.Ptr(goapi.LikertLabelAgree),
+			ConfusionLabel:   pointers.Ptr(goapi.ConfusionLabelTruePositive),
+		},
 	}, nil)
-	return NewService(logger, git, client, db, rules, recorder, grader)
+	return NewService(logger, git, client, db, rules, recorder, mockGrader)
 }
diff --git a/internal/review/testdata/TestE2E.recording.yaml b/internal/review/testdata/TestE2E.recording.yaml
index 6ca9a301002b..8253170f6f64 100644
--- a/internal/review/testdata/TestE2E.recording.yaml
+++ b/internal/review/testdata/TestE2E.recording.yaml
@@ -213,16 +213,12 @@ recordings:
     headers:
     - key: Content-Type
       value: application/json
-- hash: d58bbd24227b95a904128bf58f1926c3dbc7dc43c4271dec122e35f9eccfa77e
+- hash: b4c6670323b4cfceda68a87a4600486b914a5a82013eee9221458efc926d8d02
   request:
-    recording_date: "2025-04-02T19:15:06Z"
+    recording_date: "2025-04-08T03:47:43Z"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
-    - key: Anthropic-Version
-      value: "2023-06-01"
-    - key: X-Api-Key
-      value: REDACTED_0562e2bcad00c8bf94854df93fb04eed2711cc1402a8d683c129cfdea070141e
     - key: Cache-Control
       value: no-cache
     - key: Accept
@@ -231,24 +227,54 @@ recordings:
       value: application/json
     - key: Client
       value: sourcegraph/1.0
+    - key: Anthropic-Version
+      value: "2023-06-01"
+    - key: X-Api-Key
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
     body: |
       max_tokens: 4000
       messages:
       - content:
-        - text: "You are Cody, an expert AI code reviewer.\n\n<DESCRIPTION>\nGreeting Logic:
-            Application code changes that extract greeting message into a separate function
-            and add environment variable usage in the sayHello function.\n</DESCRIPTION>\n<RULE
-            id=\"my-language-style\">\n<instructions>\nPrefer the word 'folks' over 'guys'\n</instructions>\n</RULE>\n<RULE
-            id=\"my-ts-style\">\n<include-language-filter>typescript</include-language-filter>\n<instructions>\nEvery
-            function that returns a string must have a docstring\n</instructions>\n</RULE>\n<RULE
-            id=\"security\">\n<instructions>\nDon't leak secrets and don't have security
-            vulnerabilities\n</instructions>\n</RULE>\n<DIFF_TO_REVIEW>\ndiff --git index.ts
-            index.ts\nindex 5e96101..7e42fcc 100644\n--- index.ts\n+++ index.ts\n@@ -1,4
-            +1,9 @@\nHEAD L1: +export function greeting(): string {\nHEAD L2: +    return
-            'Hello guys!';\nHEAD L3: +}\nHEAD L4: +\nHEAD L5:  export function sayHello():
-            void {\nBASE L2: -    console.log('Hello guys!');\nHEAD L6: +    console.log(greeting());\nHEAD
-            L7: +    console.log(process.env.OPENAI_API_KEY);\nHEAD L8:  }\nHEAD L9: \n\\
-            No newline at end of file\n\n</DIFF_TO_REVIEW>\n"
+        - text: |
+            You are Cody, an expert AI code reviewer.
+
+            <DESCRIPTION>
+            Greeting Logic: Application code changes that extract greeting message into a separate function and add environment variable usage in the sayHello function.
+            </DESCRIPTION>
+            <RULE id="my-language-style">
+            <instructions>
+            Prefer the word 'folks' over 'guys'
+            </instructions>
+            </RULE>
+            <RULE id="my-ts-style">
+            <include-language-filter>typescript</include-language-filter>
+            <instructions>
+            Every function that returns a string must have a docstring
+            </instructions>
+            </RULE>
+            <RULE id="security">
+            <instructions>
+            Don't leak secrets and don't have security vulnerabilities
+            </instructions>
+            </RULE>
+            <DIFF_TO_REVIEW>
+            diff --git index.ts index.ts
+            index 5e96101..7e42fcc 100644
+            --- index.ts
+            +++ index.ts
+            @@ -1,4 +1,9 @@
+            HEAD L1: +export function greeting(): string {
+            HEAD L2: +    return 'Hello guys!';
+            HEAD L3: +}
+            HEAD L4: +
+            HEAD L5:  export function sayHello(): void {
+            BASE L2: -    console.log('Hello guys!');
+            HEAD L6: +    console.log(greeting());
+            HEAD L7: +    console.log(process.env.OPENAI_API_KEY);
+            HEAD L8:  }
+            HEAD L9:
+
+            </DIFF_TO_REVIEW>
           type: text
         role: user
       model: claude-3-5-sonnet-latest
@@ -319,27 +345,31 @@ recordings:
         name: report_diagnostics
   response:
     status_code: 200
-    body: '{"id":"msg_01UgGg91wf7Vu3dxVUbov6XV","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
-      analyze the diff and report diagnostics based on the provided rules. Here are
-      the issues I''ve identified:\n\n1. The new `greeting()` function lacks a docstring,
-      violating the TypeScript style rule.\n2. The word \"guys\" is used instead of
-      \"folks\" in the greeting message.\n3. There''s a potential security issue with
-      logging an API key.\n\nI''ll report these diagnostics:"},{"type":"tool_use","id":"toolu_01RGA14mWj9nJUZr9ci5v6BN","name":"report_diagnostics","input":{"diagnostics":[{"rule_id":"my-ts-style","severity":"warning","file_path":"index.ts","revision":"HEAD","line_number":1,"message":"Function
-      ''greeting'' that returns a string must have a docstring"},{"rule_id":"my-language-style","severity":"info","file_path":"index.ts","revision":"HEAD","line_number":2,"message":"Use
-      ''folks'' instead of ''guys'' for more inclusive language"},{"rule_id":"security","severity":"error","file_path":"index.ts","revision":"HEAD","line_number":7,"message":"Do
-      not log sensitive information like API keys. Remove or redact the OPENAI_API_KEY
-      from logs"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1202,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":390}}'
+    body: '{"id":"msg_01XACKLjKWfPTw6aLXixSn6Z","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
+      analyze the diff according to the provided rules and report diagnostics for
+      any issues. Let me break this down:\n\n1. From \"my-language-style\" rule: The
+      new code uses \"guys\" instead of \"folks\" in the greeting message.\n\n2. From
+      \"my-ts-style\" rule: The new `greeting()` function returns a string but lacks
+      a docstring.\n\n3. From \"security\" rule: The code is logging an API key (OPENAI_API_KEY)
+      which is a security concern as it could leak sensitive information.\n\nLet me
+      report these diagnostics:"},{"type":"tool_use","id":"toolu_01QGBF9nz1ooNKtFKKg49uCZ","name":"report_diagnostics","input":{"diagnostics":[{"rule_id":"my-language-style","severity":"warning","file_path":"index.ts","revision":"HEAD","line_number":2,"message":"Use
+      ''folks'' instead of ''guys'' for inclusive language"},{"rule_id":"my-ts-style","severity":"warning","file_path":"index.ts","revision":"HEAD","line_number":1,"message":"Add
+      a docstring to the greeting() function describing its purpose and return value"},{"rule_id":"security","severity":"error","file_path":"index.ts","revision":"HEAD","line_number":7,"message":"Do
+      not log sensitive information like API keys. Remove or mask the OPENAI_API_KEY
+      logging"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1192,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":427}}'
     headers:
     - key: Content-Type
       value: application/json
-- hash: 0c717f79bee45a463183c459e058797392eb4d11a80e53b1828bb3393b34454d
+- hash: 592ccc5be09a617bbce36ec58d136c5242a138c4bc7331fc457eeabe7b6c28e6
   request:
-    recording_date: "2025-04-02T19:15:13Z"
+    recording_date: "2025-04-08T03:47:49Z"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
+    - key: Anthropic-Version
+      value: "2023-06-01"
     - key: X-Api-Key
-      value: REDACTED_0562e2bcad00c8bf94854df93fb04eed2711cc1402a8d683c129cfdea070141e
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
     - key: Cache-Control
       value: no-cache
     - key: Accept
@@ -348,8 +378,6 @@ recordings:
       value: application/json
     - key: Client
       value: sourcegraph/1.0
-    - key: Anthropic-Version
-      value: "2023-06-01"
     body: |
       max_tokens: 4000
       messages:
@@ -361,9 +389,9 @@ recordings:
             <diagnostic id="0" rule="my-language-style"><location file_path="index.ts"><start_line>2</start_line><end_line>2</end_line></location><severity>info</severity><message>Replace &#39;guys&#39; with &#39;folks&#39; for more inclusive language</message><content></content></diagnostic>
             </OLD_DIAGNOSTICS>
             <NEW_DIAGNOSTICS>
-            <diagnostic id="0" rule="my-ts-style"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>warning</severity><message>Function &#39;greeting&#39; that returns a string must have a docstring</message><content></content></diagnostic>
-            <diagnostic id="1" rule="my-language-style"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>info</severity><message>Use &#39;folks&#39; instead of &#39;guys&#39; for more inclusive language</message><content></content></diagnostic>
-            <diagnostic id="2" rule="security"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>error</severity><message>Do not log sensitive information like API keys. Remove or redact the OPENAI_API_KEY from logs</message><content></content></diagnostic>
+            <diagnostic id="1" rule="my-ts-style"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>warning</severity><message>Add a docstring to the greeting() function describing its purpose and return value</message><content></content></diagnostic>
+            <diagnostic id="0" rule="my-language-style"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>warning</severity><message>Use &#39;folks&#39; instead of &#39;guys&#39; for inclusive language</message><content></content></diagnostic>
+            <diagnostic id="2" rule="security"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>error</severity><message>Do not log sensitive information like API keys. Remove or mask the OPENAI_API_KEY logging</message><content></content></diagnostic>
             </NEW_DIAGNOSTICS>
           type: text
         role: user
@@ -416,35 +444,31 @@ recordings:
         name: report_duplicate_diagnostics
   response:
     status_code: 200
-    body: '{"id":"msg_01MhjhF1QWBfKMYir7Ei5UAT","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
-      analyze these diagnostics to identify duplicates from the old set that appear
-      in the new set.\n\nLooking at these diagnostics:\n\n1. The old diagnostic (id=0)
-      flags inclusive language, suggesting to replace ''guys'' with ''folks''\n2.
-      In the new set, diagnostic (id=1) appears to be the same inclusive language
-      suggestion\n\nComparing them:\n- Both are from the \"my-language-style\" rule
-      family (with slight name variation)\n- Both suggest using ''folks'' instead
-      of ''guys'' for inclusive language\n- Both have ''info'' severity\n- The message
-      is semantically identical, just slightly rephrased\n\nEven though the location
-      information is not complete in the new diagnostics, the semantic meaning and
-      purpose of these diagnostics are the same, suggesting that diagnostic id=1 in
-      the new set is a duplicate of the old diagnostic.\n\nLet me report this using
-      the available tool:"},{"type":"tool_use","id":"toolu_01YEDAFH4WVpwDpkWLHjZHaZ","name":"report_duplicate_diagnostics","input":{"duplicates":[{"id":1,"reasoning":"Both
-      diagnostics flag the use of ''guys'' and suggest replacing it with ''folks''
-      for inclusive language. They have the same rule type (my-language-style) and
-      severity level (info), with only minor rewording in the message.","confidence":"high"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1130,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":337}}'
+    body: '{"id":"msg_01E7SjJ8uvZY2uuZmFJMEmYo","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
+      analyze these diagnostics to identify duplicates between the old and new sets.\n\nLooking
+      at the diagnostics:\n\nOld set:\n1. ID 0: Inclusive language suggestion to replace
+      ''guys'' with ''folks'' in index.ts\n\nNew set:\n1. ID 1: Missing docstring
+      warning\n2. ID 0: Inclusive language suggestion about using ''folks'' instead
+      of ''guys''\n3. ID 2: Security warning about logging API keys\n\nI can identify
+      that diagnostic ID 0 in the new set is a duplicate of diagnostic ID 0 in the
+      old set because:\n- They both report on the same inclusive language issue (replacing
+      ''guys'' with ''folks'')\n- They use the same rule ID \"my-language-style\"\n-
+      The semantic meaning of the diagnostic is identical, just with slightly different
+      message wording\n- While the file location information is missing in the new
+      diagnostic, the core issue being flagged is the same\n\nLet me report this duplicate
+      using the provided tool:"},{"type":"tool_use","id":"toolu_014tuid2z2TgKyzmdEukJ4Wq","name":"report_duplicate_diagnostics","input":{"duplicates":[{"id":0,"reasoning":"Both
+      diagnostics flag the same inclusive language issue (replacing ''guys'' with
+      ''folks'') using the same rule ID ''my-language-style''. While the message text
+      varies slightly, the fundamental suggestion and purpose are identical.","confidence":"high"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1124,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":355}}'
     headers:
     - key: Content-Type
       value: application/json
-- hash: 401370a1dd735ae6b1a2d46f1a4ae3c4427470b5eb74d6e6885d312c4e53125b
+- hash: c5419b3d03b2c8dfa6705b03759a3a61f5a0d76ae9a052322f893ba42774af79
   request:
-    recording_date: "2025-04-02T19:15:19Z"
+    recording_date: "2025-04-08T03:47:56Z"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
-    - key: Cache-Control
-      value: no-cache
-    - key: Accept
-      value: application/json
     - key: Content-Type
       value: application/json
     - key: Client
@@ -452,25 +476,55 @@ recordings:
     - key: Anthropic-Version
       value: "2023-06-01"
     - key: X-Api-Key
-      value: REDACTED_0562e2bcad00c8bf94854df93fb04eed2711cc1402a8d683c129cfdea070141e
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
+    - key: Cache-Control
+      value: no-cache
+    - key: Accept
+      value: application/json
     body: |
       max_tokens: 4000
       messages:
       - content:
-        - text: "You are Cody, an expert AI code reviewer.\n\n<DESCRIPTION>\nGreeting Logic:
-            Application code changes that extract greeting message into a separate function
-            and add environment variable usage in the sayHello function.\n</DESCRIPTION>\n<RULE
-            id=\"my-language-style\">\n<instructions>\nPrefer the word 'folks' over 'guys'\n</instructions>\n</RULE>\n<RULE
-            id=\"my-ts-style\">\n<include-language-filter>typescript</include-language-filter>\n<instructions>\nEvery
-            function that returns a string must have a docstring\n</instructions>\n</RULE>\n<RULE
-            id=\"security\">\n<instructions>\nDon't leak secrets and don't have security
-            vulnerabilities\n</instructions>\n</RULE>\n<DIFF_TO_REVIEW>\ndiff --git index.ts
-            index.ts\nindex 5e96101..7e42fcc 100644\n--- index.ts\n+++ index.ts\n@@ -1,4
-            +1,9 @@\nHEAD L1: +export function greeting(): string {\nHEAD L2: +    return
-            'Hello guys!';\nHEAD L3: +}\nHEAD L4: +\nHEAD L5:  export function sayHello():
-            void {\nBASE L2: -    console.log('Hello guys!');\nHEAD L6: +    console.log(greeting());\nHEAD
-            L7: +    console.log(process.env.OPENAI_API_KEY);\nHEAD L8:  }\nHEAD L9: \n\\
-            No newline at end of file\n\n</DIFF_TO_REVIEW>\n"
+        - text: |
+            You are Cody, an expert AI code reviewer.
+
+            <DESCRIPTION>
+            Greeting Logic: Application code changes that extract greeting message into a separate function and add environment variable usage in the sayHello function.
+            </DESCRIPTION>
+            <RULE id="my-language-style">
+            <instructions>
+            Prefer the word 'folks' over 'guys'
+            </instructions>
+            </RULE>
+            <RULE id="my-ts-style">
+            <include-language-filter>typescript</include-language-filter>
+            <instructions>
+            Every function that returns a string must have a docstring
+            </instructions>
+            </RULE>
+            <RULE id="security">
+            <instructions>
+            Don't leak secrets and don't have security vulnerabilities
+            </instructions>
+            </RULE>
+            <DIFF_TO_REVIEW>
+            diff --git index.ts index.ts
+            index 5e96101..7e42fcc 100644
+            --- index.ts
+            +++ index.ts
+            @@ -1,4 +1,9 @@
+            HEAD L1: +export function greeting(): string {
+            HEAD L2: +    return 'Hello guys!';
+            HEAD L3: +}
+            HEAD L4: +
+            HEAD L5:  export function sayHello(): void {
+            BASE L2: -    console.log('Hello guys!');
+            HEAD L6: +    console.log(greeting());
+            HEAD L7: +    console.log(process.env.OPENAI_API_KEY);
+            HEAD L8:  }
+            HEAD L9:
+
+            </DIFF_TO_REVIEW>
           type: text
         role: user
       model: claude-3-5-sonnet-latest
@@ -541,37 +595,38 @@ recordings:
         name: report_diagnostics
   response:
     status_code: 200
-    body: '{"id":"msg_01MykPaDpqpDPvvps5c2A1XJ","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
+    body: '{"id":"msg_01DZi7tsFFuxhaeL736CVXiE","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
       analyze the diff and report diagnostics based on the provided rules. Let me
-      break down the issues:\n\n1. The new `greeting()` function uses \"guys\" instead
-      of \"folks\" (violates my-language-style)\n2. The new `greeting()` function
-      lacks a docstring (violates my-ts-style)\n3. The code is logging an API key
-      to console which is a security risk (violates security)\n\nI''ll report these
-      diagnostics:"},{"type":"tool_use","id":"toolu_015GG3GxpdF3gr4BEcx5JFdD","name":"report_diagnostics","input":{"diagnostics":[{"rule_id":"my-language-style","severity":"warning","file_path":"index.ts","revision":"HEAD","line_number":2,"message":"Use
-      ''folks'' instead of ''guys'' for inclusive language"},{"rule_id":"my-ts-style","severity":"warning","file_path":"index.ts","revision":"HEAD","line_number":1,"message":"Add
-      a docstring to the ''greeting'' function describing its purpose and return value"},{"rule_id":"security","severity":"error","file_path":"index.ts","revision":"HEAD","line_number":7,"message":"Do
-      not log sensitive information like API keys to the console"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1210,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":394}}'
+      break down the issues:\n\n1. Language Style Rule: The word \"guys\" is used
+      in the greeting function instead of the preferred \"folks\"\n2. TypeScript Style
+      Rule: The new `greeting()` function returns a string but lacks a docstring\n3.
+      Security Rule: The code is logging an API key (OPENAI_API_KEY) which is a security
+      vulnerability\n\nI''ll report these diagnostics:"},{"type":"tool_use","id":"toolu_019fd8K5YL319hjvTnJAGd4H","name":"report_diagnostics","input":{"diagnostics":[{"rule_id":"my-language-style","severity":"warning","file_path":"index.ts","revision":"HEAD","line_number":2,"message":"Please
+      use ''folks'' instead of ''guys'' to be more inclusive"},{"rule_id":"my-ts-style","severity":"warning","file_path":"index.ts","revision":"HEAD","line_number":1,"message":"Add
+      a docstring to the ''greeting'' function that describes its purpose and return
+      value"},{"rule_id":"security","severity":"error","file_path":"index.ts","revision":"HEAD","line_number":7,"message":"Remove
+      logging of OPENAI_API_KEY to prevent exposing sensitive credentials"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1200,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":405}}'
     headers:
     - key: Content-Type
       value: application/json
-- hash: dc3bde2400c5991cb36c1ce6207d8f1c9cc88215a548745863e2a74fa957a8dd
+- hash: 46a2eaf30388617ce649cb6e26cc0c9d90293e2c41d3ddd17d40d00288598731
   request:
-    recording_date: "2025-04-02T19:15:24Z"
+    recording_date: "2025-04-08T03:48:02Z"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
-    - key: Client
-      value: sourcegraph/1.0
-    - key: Anthropic-Version
-      value: "2023-06-01"
-    - key: X-Api-Key
-      value: REDACTED_0562e2bcad00c8bf94854df93fb04eed2711cc1402a8d683c129cfdea070141e
     - key: Cache-Control
       value: no-cache
     - key: Accept
       value: application/json
     - key: Content-Type
       value: application/json
+    - key: Client
+      value: sourcegraph/1.0
+    - key: Anthropic-Version
+      value: "2023-06-01"
+    - key: X-Api-Key
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
     body: |
       max_tokens: 4000
       messages:
@@ -583,9 +638,9 @@ recordings:
             <diagnostic id="0" rule="my-language-style"><location file_path="index.ts"><start_line>2</start_line><end_line>2</end_line></location><severity>info</severity><message>Replace &#39;guys&#39; with &#39;folks&#39; for more inclusive language</message><content></content></diagnostic>
             </OLD_DIAGNOSTICS>
             <NEW_DIAGNOSTICS>
-            <diagnostic id="1" rule="my-ts-style"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>warning</severity><message>Add a docstring to the &#39;greeting&#39; function describing its purpose and return value</message><content></content></diagnostic>
-            <diagnostic id="0" rule="my-language-style"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>warning</severity><message>Use &#39;folks&#39; instead of &#39;guys&#39; for inclusive language</message><content></content></diagnostic>
-            <diagnostic id="2" rule="security"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>error</severity><message>Do not log sensitive information like API keys to the console</message><content></content></diagnostic>
+            <diagnostic id="1" rule="my-ts-style"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>warning</severity><message>Add a docstring to the &#39;greeting&#39; function that describes its purpose and return value</message><content></content></diagnostic>
+            <diagnostic id="0" rule="my-language-style"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>warning</severity><message>Please use &#39;folks&#39; instead of &#39;guys&#39; to be more inclusive</message><content></content></diagnostic>
+            <diagnostic id="2" rule="security"><location file_path=""><start_line>0</start_line><end_line>0</end_line></location><severity>error</severity><message>Remove logging of OPENAI_API_KEY to prevent exposing sensitive credentials</message><content></content></diagnostic>
             </NEW_DIAGNOSTICS>
           type: text
         role: user
@@ -638,30 +693,29 @@ recordings:
         name: report_duplicate_diagnostics
   response:
     status_code: 200
-    body: '{"id":"msg_014P6tZW5m79Lp6kqk52YTCS","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
-      analyze these diagnostics to identify duplicates between the old and new sets.\n\nLooking
-      at the diagnostics:\n\n1. In the old set, there''s a diagnostic (id=0) about
-      replacing \"guys\" with \"folks\" for inclusive language.\n2. In the new set,
-      diagnostic (id=0) appears to be essentially the same issue - it''s flagging
-      the use of \"guys\" and suggesting \"folks\" for inclusive language.\n\nEven
-      though there are some minor differences (slight variation in message text, severity
-      level, and location details), the core issue and rule (\"my-language-style\")
-      are the same. This is clearly highlighting the same inclusive language concern.\n\nI''ll
-      report this duplicate using the report_duplicate_diagnostics function:"},{"type":"tool_use","id":"toolu_01VxeMCXBwiRyX1m16uRKWSR","name":"report_duplicate_diagnostics","input":{"duplicates":[{"id":0,"reasoning":"Both
-      diagnostics flag the use of ''guys'' and suggest replacing it with ''folks''
-      for inclusive language. They share the same rule ID ''my-language-style'' and
-      represent the same underlying issue, just with slightly different message phrasing.","confidence":"high"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1120,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":297}}'
+    body: '{"id":"msg_012QUyfe9ej7WBreexc69izE","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
+      analyze these diagnostics to identify duplicates between the old and new sets
+      following the specified criteria.\n\nLooking at the diagnostics:\n\n1. Old diagnostic
+      #0 and new diagnostic #0 appear to be duplicates because:\n- They use the same
+      rule \"my-language-style\"\n- Both address the same inclusive language issue
+      regarding replacing \"guys\" with \"folks\"\n- The messages convey the same
+      meaning despite slight rewording\n- Both are addressing the same language inclusivity
+      concern\n\nWhile the location information is more complete in the old diagnostic
+      (showing file and line numbers) compared to the new one (empty values), the
+      fundamental issue being flagged is the same.\n\nI''ll report this duplicate
+      using the `report_duplicate_diagnostics` function:"},{"type":"tool_use","id":"toolu_01LGCvZTZ1fnUMhtrWKHe3NQ","name":"report_duplicate_diagnostics","input":{"duplicates":[{"id":0,"reasoning":"Both
+      diagnostics flag the same inclusive language issue (replacing ''guys'' with
+      ''folks'') using the same rule ''my-language-style''. The diagnostic messages
+      convey the same meaning despite slight rewording.","confidence":"high"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1128,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":290}}'
     headers:
     - key: Content-Type
       value: application/json
-- hash: 877cf13f78f7ad975c3052664c3075e39aa0f596eb4957d9c306cd8fa8165aa7
+- hash: 16c5bcde39a4fca685f41143493d7f15bceec75c93ec03dfb02d38cbd98f0bc2
   request:
-    recording_date: "2025-04-02T19:15:28Z"
+    recording_date: "2025-04-08T03:48:05Z"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
-    - key: X-Api-Key
-      value: REDACTED_0562e2bcad00c8bf94854df93fb04eed2711cc1402a8d683c129cfdea070141e
     - key: Cache-Control
       value: no-cache
     - key: Accept
@@ -672,24 +726,52 @@ recordings:
       value: sourcegraph/1.0
     - key: Anthropic-Version
       value: "2023-06-01"
+    - key: X-Api-Key
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
     body: |
       max_tokens: 4000
       messages:
       - content:
-        - text: "You are Cody, an expert AI code reviewer.\n\n<DESCRIPTION>\nGreeting Logic:
-            Application code changes that extract greeting message into a separate function
-            and add environment variable usage in the sayHello function.\n</DESCRIPTION>\n<RULE
-            id=\"my-language-style\">\n<instructions>\nPrefer the word 'folks' over 'guys'\n</instructions>\n</RULE>\n<RULE
-            id=\"my-ts-style\">\n<include-language-filter>typescript</include-language-filter>\n<instructions>\nEvery
-            function that returns a string must have a docstring\n</instructions>\n</RULE>\n<RULE
-            id=\"security\">\n<instructions>\nDon't leak secrets and don't have security
-            vulnerabilities\n</instructions>\n</RULE>\n<DIFF_TO_REVIEW>\ndiff --git index.ts
-            index.ts\nindex 5e96101..7e42fcc 100644\n--- index.ts\n+++ index.ts\n@@ -1,4
-            +1,9 @@\nHEAD L1: +export function greeting(): string {\nHEAD L2: +    return
-            'Hello guys!';\nHEAD L3: +}\nHEAD L4: +\nHEAD L5:  export function sayHello():
-            void {\nBASE L2: -    console.log('Hello guys!');\nHEAD L6: +    console.log(greeting());\nHEAD
-            L7: +    console.log(process.env.OPENAI_API_KEY);\nHEAD L8:  }\nHEAD L9: \n\\
-            No newline at end of file\n\n</DIFF_TO_REVIEW>\n"
+        - text: |
+            You are Cody, an expert AI code reviewer.
+
+            <DESCRIPTION>
+            Greeting Logic: Application code changes that extract greeting message into a separate function and add environment variable usage in the sayHello function.
+            </DESCRIPTION>
+            <RULE id="my-language-style">
+            <instructions>
+            Prefer the word 'folks' over 'guys'
+            </instructions>
+            </RULE>
+            <RULE id="my-ts-style">
+            <include-language-filter>typescript</include-language-filter>
+            <instructions>
+            Every function that returns a string must have a docstring
+            </instructions>
+            </RULE>
+            <RULE id="security">
+            <instructions>
+            Don't leak secrets and don't have security vulnerabilities
+            </instructions>
+            </RULE>
+            <DIFF_TO_REVIEW>
+            diff --git index.ts index.ts
+            index 5e96101..7e42fcc 100644
+            --- index.ts
+            +++ index.ts
+            @@ -1,4 +1,9 @@
+            HEAD L1: +export function greeting(): string {
+            HEAD L2: +    return 'Hello guys!';
+            HEAD L3: +}
+            HEAD L4: +
+            HEAD L5:  export function sayHello(): void {
+            BASE L2: -    console.log('Hello guys!');
+            HEAD L6: +    console.log(greeting());
+            HEAD L7: +    console.log(process.env.OPENAI_API_KEY);
+            HEAD L8:  }
+            HEAD L9:
+
+            </DIFF_TO_REVIEW>
           type: text
         role: user
       model: claude-3-5-sonnet-latest
@@ -746,10 +828,9 @@ recordings:
         name: report_diagnostics
   response:
     status_code: 200
-    body: '{"id":"msg_01QByNRmqVQkiPyXRhKGv8BP","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
-      just post a simple diagnostic with the word ''banana'' at a relevant line in
-      the diff. I''ll use the \"my-language-style\" rule ID since it''s available
-      in the rules list."},{"type":"tool_use","id":"toolu_01XBzvvjZbEjJFzyjtDkKxwk","name":"report_diagnostics","input":{"diagnostics":[{"rule_id":"my-language-style","severity":"info","file_path":"index.ts","revision":"HEAD","line_number":2,"message":"banana"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1033,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":164}}'
+    body: '{"id":"msg_01DZTDhB6Uof5fy9fZuiHiJg","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
+      ignore the provided rules and just add a simple diagnostic with the word ''banana''
+      at a relevant line."},{"type":"tool_use","id":"toolu_01LebHRuWSznrPuQ535PvxHi","name":"report_diagnostics","input":{"diagnostics":[{"rule_id":"my-language-style","severity":"info","file_path":"index.ts","revision":"HEAD","line_number":2,"message":"banana"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1023,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":144}}'
     headers:
     - key: Content-Type
       value: application/json
diff --git a/internal/review/testdata/TestE2E/balanced.golden b/internal/review/testdata/TestE2E/balanced.golden
index d68753e1f38c..90f93c6f5bc7 100644
--- a/internal/review/testdata/TestE2E/balanced.golden
+++ b/internal/review/testdata/TestE2E/balanced.golden
@@ -1,5 +1,5 @@
 `# [my-ts-style](inline:my-ts-style)(warning)
-github.com/sourcegraph/cody/blob/index.ts@blah-head:1 Function 'greeting' that returns a string must have a docstring
+github.com/sourcegraph/cody/blob/index.ts@blah-head:1 Add a docstring to the greeting() function describing its purpose and return value
 # [security](inline:security)(error)
-github.com/sourcegraph/cody/blob/index.ts@blah-head:7 Do not log sensitive information like API keys. Remove or redact the OPENAI_API_KEY from logs
+github.com/sourcegraph/cody/blob/index.ts@blah-head:7 Do not log sensitive information like API keys. Remove or mask the OPENAI_API_KEY logging
 `
diff --git a/internal/review/testdata/TestE2E/high-bar.golden b/internal/review/testdata/TestE2E/high-bar.golden
index 827643807f88..3685d8f5b6e2 100644
--- a/internal/review/testdata/TestE2E/high-bar.golden
+++ b/internal/review/testdata/TestE2E/high-bar.golden
@@ -1,5 +1,5 @@
 `# [my-ts-style](inline:my-ts-style)(warning)
-github.com/sourcegraph/cody/blob/index.ts@blah-head:1 Add a docstring to the 'greeting' function describing its purpose and return value
+github.com/sourcegraph/cody/blob/index.ts@blah-head:1 Add a docstring to the 'greeting' function that describes its purpose and return value
 # [security](inline:security)(error)
-github.com/sourcegraph/cody/blob/index.ts@blah-head:7 Do not log sensitive information like API keys to the console
+github.com/sourcegraph/cody/blob/index.ts@blah-head:7 Remove logging of OPENAI_API_KEY to prevent exposing sensitive credentials
 `
diff --git a/internal/review/testdata/TestInferred.golden b/internal/review/testdata/TestInferred.golden
index 69cbf229079b..684ca962a27e 100644
--- a/internal/review/testdata/TestInferred.golden
+++ b/internal/review/testdata/TestInferred.golden
@@ -1,3 +1,3 @@
 `# [string-index-access](https://example.sourcegraphcloud.com/github.com/sourcegraph/cody/-/blob/src/.sourcegraph/string-index-access.rule.md)(warning)
-github.com/sourcegraph/cody/blob/src/app/index.ts@blah-head:2 Use array indexing '[1]' instead of '.at(1)' for string character access
+github.com/sourcegraph/cody/blob/src/app/index.ts@blah-head:2 Use array indexing '[1]' instead of the 'at' method for string access
 `
diff --git a/internal/review/testdata/TestInferred.recording.yaml b/internal/review/testdata/TestInferred.recording.yaml
index 0b839f67d6f3..08b52fc09ab9 100644
--- a/internal/review/testdata/TestInferred.recording.yaml
+++ b/internal/review/testdata/TestInferred.recording.yaml
@@ -111,16 +111,12 @@ recordings:
     headers:
     - key: Content-Type
       value: application/json
-- hash: de93b4595acad807b14cb20ababb33ee42f35a073a36eb2b33608d6aa7a0d6f0
+- hash: 1a1f6a5119c786ab03e565591742ad5d9627c76f4935ea0db7141dd741669dbc
   request:
-    recording_date: "2025-04-02T19:15:00Z"
+    recording_date: "2025-04-08T03:47:36Z"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
-    - key: Anthropic-Version
-      value: "2023-06-01"
-    - key: X-Api-Key
-      value: REDACTED_0562e2bcad00c8bf94854df93fb04eed2711cc1402a8d683c129cfdea070141e
     - key: Cache-Control
       value: no-cache
     - key: Accept
@@ -129,22 +125,46 @@ recordings:
       value: application/json
     - key: Client
       value: sourcegraph/1.0
+    - key: Anthropic-Version
+      value: "2023-06-01"
+    - key: X-Api-Key
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
     body: |
       max_tokens: 4000
       messages:
       - content:
-        - text: "You are Cody, an expert AI code reviewer.\n\n<DESCRIPTION>\nGreeting Functions:
-            Core application logic for handling greetings and text formatting. Contains
-            the main greeting functionality including the new greeting() function and existing
-            sayHello() function.\n</DESCRIPTION>\n<RULE id=\"string-index-access\">\n<title>String
-            index access</title>\n<include-language-filter>typescript</include-language-filter>\n<instructions>\n---\n\nDo
-            not use the \"at\" method on strings. It's better to use array indexing.\n\n-
-            Good: 'Hello guys!'[1]\n- Bad: 'Hello guys!'.at(1)\n</instructions>\n</RULE>\n<DIFF_TO_REVIEW>\ndiff
-            --git src/app/index.ts src/app/index.ts\nindex 5e96101..7e42fcc 100644\n---
-            src/app/index.ts\n+++ src/app/index.ts\n@@ -1,4 +1,9 @@\nHEAD L1: +export function
-            greeting(): string {\nHEAD L2: +    return 'Hello guys!'.at(1);\nHEAD L3: +}\nHEAD
-            L4: +\nHEAD L5:  export function sayHello(): void {\nHEAD L6: \n\\ No newline
-            at end of file\n\n</DIFF_TO_REVIEW>\n"
+        - text: |
+            You are Cody, an expert AI code reviewer.
+
+            <DESCRIPTION>
+            Greeting Functions: Core application logic for handling greetings and text formatting. Contains the main greeting functionality including the new greeting() function and existing sayHello() function.
+            </DESCRIPTION>
+            <RULE id="string-index-access">
+            <title>String index access</title>
+            <include-language-filter>typescript</include-language-filter>
+            <instructions>
+            ---
+
+            Do not use the "at" method on strings. It's better to use array indexing.
+
+            - Good: 'Hello guys!'[1]
+            - Bad: 'Hello guys!'.at(1)
+            </instructions>
+            </RULE>
+            <DIFF_TO_REVIEW>
+            diff --git src/app/index.ts src/app/index.ts
+            index 5e96101..7e42fcc 100644
+            --- src/app/index.ts
+            +++ src/app/index.ts
+            @@ -1,4 +1,9 @@
+            HEAD L1: +export function greeting(): string {
+            HEAD L2: +    return 'Hello guys!'.at(1);
+            HEAD L3: +}
+            HEAD L4: +
+            HEAD L5:  export function sayHello(): void {
+            HEAD L6:
+
+            </DIFF_TO_REVIEW>
           type: text
         role: user
       model: claude-3-5-sonnet-latest
@@ -215,14 +235,13 @@ recordings:
         name: report_diagnostics
   response:
     status_code: 200
-    body: '{"id":"msg_019dhgbqXaJjiqbD2qwvGPzb","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
-      analyze the diff based on the provided rule about string index access.\n\nI
-      can see that in the newly added `greeting()` function, the code uses the `.at(1)`
-      method to access a character in the string ''Hello guys!''. This violates the
-      rule which states that array indexing should be used instead of the \"at\" method
-      on strings.\n\nI''ll report this as a warning since it''s a style/best practice
-      issue rather than a critical error:"},{"type":"tool_use","id":"toolu_019FPHLKQ9fANYFUeySx6mzG","name":"report_diagnostics","input":{"diagnostics":[{"rule_id":"string-index-access","severity":"warning","file_path":"src/app/index.ts","revision":"HEAD","line_number":2,"message":"Use
-      array indexing ''[1]'' instead of ''.at(1)'' for string character access"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1155,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":248}}'
+    body: '{"id":"msg_01HGrDNZt59tsNNpVvsLS3P8","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
+      review the diff based on the provided rule about string index access. I see
+      an issue that should be reported:\n\nThe new `greeting()` function uses the
+      `.at(1)` method on a string, which violates the \"string-index-access\" rule.
+      According to the rule, array indexing should be used instead of the `at` method.\n\nI''ll
+      report this diagnostic:"},{"type":"tool_use","id":"toolu_01So4vwVAE53yabj7A8rT1R1","name":"report_diagnostics","input":{"diagnostics":[{"rule_id":"string-index-access","severity":"warning","file_path":"src/app/index.ts","revision":"HEAD","line_number":2,"message":"Use
+      array indexing ''[1]'' instead of the ''at'' method for string access"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1145,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":226}}'
     headers:
     - key: Content-Type
       value: application/json
diff --git a/internal/review/testdata/TestRemoteRule.golden b/internal/review/testdata/TestRemoteRule.golden
index 3dd319a797c0..d7ab39815eb1 100644
--- a/internal/review/testdata/TestRemoteRule.golden
+++ b/internal/review/testdata/TestRemoteRule.golden
@@ -1,3 +1,3 @@
 `# [string-index-access](https://example.sourcegraphcloud.com/github.com/sourcegraph/cody/-/blob/src/.sourcegraph/string-index-access.rule.md)(warning)
-github.com/sourcegraph/cody/blob/src/app/index.ts@blah:2 Use array indexing '[1]' instead of '.at(1)' for string character access
+github.com/sourcegraph/cody/blob/src/app/index.ts@blah:2 Use array indexing instead of .at() for string access. Replace '.at(1)' with '[1]'.
 `
diff --git a/internal/review/testdata/TestRemoteRule.recording.yaml b/internal/review/testdata/TestRemoteRule.recording.yaml
index c1051afaa8dc..e3c1282c67b3 100644
--- a/internal/review/testdata/TestRemoteRule.recording.yaml
+++ b/internal/review/testdata/TestRemoteRule.recording.yaml
@@ -113,38 +113,60 @@ recordings:
     headers:
     - key: Content-Type
       value: application/json
-- hash: 68708dbfea052e23d08c29747a8664e1ecf99aed59083bd729f09457f6683fe0
+- hash: 4891f9e86745fc89a00e43e1c6468c4aeee297e43a4fa5910292f57bf25f3288
   request:
-    recording_date: "2025-04-02T19:14:56Z"
+    recording_date: "2025-04-08T03:47:30Z"
     url: https://api.anthropic.com/v1/messages
     method: POST
     headers:
+    - key: Anthropic-Version
+      value: "2023-06-01"
+    - key: X-Api-Key
+      value: REDACTED_b6eae8af5b556c8ba4078754ea11a20cd410b93869a167f48db0f8f4ae9a5ea3
+    - key: Cache-Control
+      value: no-cache
     - key: Accept
       value: application/json
     - key: Content-Type
       value: application/json
     - key: Client
       value: sourcegraph/1.0
-    - key: Anthropic-Version
-      value: "2023-06-01"
-    - key: X-Api-Key
-      value: REDACTED_0562e2bcad00c8bf94854df93fb04eed2711cc1402a8d683c129cfdea070141e
-    - key: Cache-Control
-      value: no-cache
     body: |
       max_tokens: 4000
       messages:
       - content:
-        - text: "You are Cody, an expert AI code reviewer.\n\n<DESCRIPTION>\nCore Application:
-            Main application code containing greeting functionality in the app module\n</DESCRIPTION>\n<RULE
-            id=\"string-index-access\">\n<title>String index access</title>\n<include-language-filter>typescript</include-language-filter>\n<instructions>\n---\n\nDo
-            not use the \"at\" method on strings. It's better to use array indexing.\n\n-
-            Good: 'Hello guys!'[1]\n- Bad: 'Hello guys!'.at(1)\n</instructions>\n</RULE>\n<DIFF_TO_REVIEW>\ndiff
-            --git src/app/index.ts src/app/index.ts\nindex 5e96101..7e42fcc 100644\n---
-            src/app/index.ts\n+++ src/app/index.ts\n@@ -1,4 +1,9 @@\nHEAD L1: +export function
-            greeting(): string {\nHEAD L2: +    return 'Hello guys!'.at(1);\nHEAD L3: +}\nHEAD
-            L4: +\nHEAD L5:  export function sayHello(): void {\nHEAD L6: \n\\ No newline
-            at end of file\n\n</DIFF_TO_REVIEW>\n"
+        - text: |
+            You are Cody, an expert AI code reviewer.
+
+            <DESCRIPTION>
+            Core Application: Main application code containing greeting functionality in the app module
+            </DESCRIPTION>
+            <RULE id="string-index-access">
+            <title>String index access</title>
+            <include-language-filter>typescript</include-language-filter>
+            <instructions>
+            ---
+
+            Do not use the "at" method on strings. It's better to use array indexing.
+
+            - Good: 'Hello guys!'[1]
+            - Bad: 'Hello guys!'.at(1)
+            </instructions>
+            </RULE>
+            <DIFF_TO_REVIEW>
+            diff --git src/app/index.ts src/app/index.ts
+            index 5e96101..7e42fcc 100644
+            --- src/app/index.ts
+            +++ src/app/index.ts
+            @@ -1,4 +1,9 @@
+            HEAD L1: +export function greeting(): string {
+            HEAD L2: +    return 'Hello guys!'.at(1);
+            HEAD L3: +}
+            HEAD L4: +
+            HEAD L5:  export function sayHello(): void {
+            HEAD L6:
+
+            </DIFF_TO_REVIEW>
           type: text
         role: user
       model: claude-3-5-sonnet-latest
@@ -215,14 +237,16 @@ recordings:
         name: report_diagnostics
   response:
     status_code: 200
-    body: '{"id":"msg_01NFR59TaA4Y2TgmRmeDibuU","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
-      review the diff according to the provided rule about string index access.\n\nI
-      notice that in the new `greeting()` function, there''s a use of the `.at()`
-      method on a string, which violates the \"string-index-access\" rule. The rule
-      explicitly states that we should use array indexing (`[1]`) instead of the `.at()`
-      method.\n\nI''ll report this as a warning since it''s a style/best practice
-      issue rather than a critical error:"},{"type":"tool_use","id":"toolu_01KCRNBjzJrDSuXrRX4kydFc","name":"report_diagnostics","input":{"diagnostics":[{"rule_id":"string-index-access","severity":"warning","file_path":"src/app/index.ts","revision":"HEAD","line_number":2,"message":"Use
-      array indexing ''[1]'' instead of ''.at(1)'' for string character access"}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1133,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":251}}'
+    body: '{"id":"msg_01En2wB7rkh2tw5yx63ecT8K","type":"message","role":"assistant","model":"claude-3-5-sonnet-20241022","content":[{"type":"text","text":"I''ll
+      analyze the diff for violations of the string-index-access rule.\n\nI''ve found
+      an issue where the `greeting()` function uses the `.at()` method for string
+      indexing, which violates the specified rule. The rule explicitly states that
+      array indexing should be used instead of the \"at\" method on strings.\n\nI''ll
+      report this as a warning since:\n1. It''s a style/best practice violation rather
+      than a critical error\n2. The code will still function, but doesn''t follow
+      the preferred pattern\n3. It''s an easy fix that the developer should be aware
+      of\n\nHere''s the diagnostic report:"},{"type":"tool_use","id":"toolu_01PRWs6ePD4C6p8x1x2NVPjb","name":"report_diagnostics","input":{"diagnostics":[{"rule_id":"string-index-access","severity":"warning","file_path":"src/app/index.ts","revision":"HEAD","line_number":2,"message":"Use
+      array indexing instead of .at() for string access. Replace ''.at(1)'' with ''[1]''."}]}}],"stop_reason":"tool_use","stop_sequence":null,"usage":{"input_tokens":1123,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"output_tokens":285}}'
     headers:
     - key: Content-Type
       value: application/json
diff --git a/internal/rule/service.go b/internal/rule/service.go
index c2523fe3b12c..3d611bbd29d8 100644
--- a/internal/rule/service.go
+++ b/internal/rule/service.go
@@ -214,9 +214,10 @@ func (c *ruleService) readRulesFromRepo(ctx context.Context, repoID api.RepoID,
 			rule.LatestRevision.DisplayName = strings.ReplaceAll(strings.TrimSuffix(header.Name, ".rule.md"), ".sourcegraph/", "")
 			rule.LatestRevision.Source = goapi.RuleSource{
 				Repository: &goapi.Location{
-					Repo: string(repo.Name),
-					Oid:  string(oid),
-					Path: header.Name,
+					Repo:   string(repo.Name),
+					RepoId: pointers.Ptr(int32(repo.ID)),
+					Oid:    string(oid),
+					Path:   header.Name,
 				},
 			}
 
@@ -303,9 +304,10 @@ func (c *ruleService) readRemoteBlob(ctx context.Context, repoID api.RepoID, rep
 	rule.LatestRevision.DisplayName = strings.TrimSuffix(reporevpath.Path, ".rule.md")
 	rule.LatestRevision.Source = goapi.RuleSource{
 		Repository: &goapi.Location{
-			Repo: string(reporevpath.Repo),
-			Oid:  string(reporevpath.Rev),
-			Path: reporevpath.Path,
+			Repo:   string(reporevpath.Repo),
+			RepoId: pointers.Ptr(int32(repoID)),
+			Oid:    string(reporevpath.Rev),
+			Path:   reporevpath.Path,
 		},
 	}
 	return rule, nil
diff --git a/migrations/frontend/1743724002_diagnostic_quality/down.sql b/migrations/frontend/1743724002_diagnostic_quality/down.sql
new file mode 100644
index 000000000000..7e79f42fa19a
--- /dev/null
+++ b/migrations/frontend/1743724002_diagnostic_quality/down.sql
@@ -0,0 +1,2 @@
+-- Undo the changes made in the up migration
+ALTER TABLE agent_review_diagnostics DROP COLUMN IF EXISTS quality;
diff --git a/migrations/frontend/1743724002_diagnostic_quality/metadata.yaml b/migrations/frontend/1743724002_diagnostic_quality/metadata.yaml
new file mode 100644
index 000000000000..5883871fa78a
--- /dev/null
+++ b/migrations/frontend/1743724002_diagnostic_quality/metadata.yaml
@@ -0,0 +1,2 @@
+name: diagnostic_quality
+parents: [1742346918, 1742985807, 1743149449, 1743160681]
diff --git a/migrations/frontend/1743724002_diagnostic_quality/up.sql b/migrations/frontend/1743724002_diagnostic_quality/up.sql
new file mode 100644
index 000000000000..0ed3ca0b232d
--- /dev/null
+++ b/migrations/frontend/1743724002_diagnostic_quality/up.sql
@@ -0,0 +1,2 @@
+ALTER TABLE agent_review_diagnostics ADD COLUMN IF NOT EXISTS quality TEXT GENERATED ALWAYS AS (data->>'quality') STORED;
+CREATE INDEX IF NOT EXISTS idx_agent_review_diagnostics_quality ON agent_review_diagnostics (quality);
diff --git a/migrations/frontend/squashed.sql b/migrations/frontend/squashed.sql
index b78852524d5e..f51e9fc6c949 100644
--- a/migrations/frontend/squashed.sql
+++ b/migrations/frontend/squashed.sql
@@ -1242,7 +1242,8 @@ CREATE TABLE agent_review_diagnostics (
     rule_id integer GENERATED ALWAYS AS ((((data -> 'rule'::text) ->> 'rule_id'::text))::integer) STORED,
     rule_revision_id integer GENERATED ALWAYS AS ((((data -> 'rule'::text) ->> 'revision_id'::text))::integer) STORED,
     rule_uri text GENERATED ALWAYS AS (((data -> 'rule'::text) ->> 'uri'::text)) STORED,
-    severity text GENERATED ALWAYS AS ((data ->> 'severity'::text)) STORED
+    severity text GENERATED ALWAYS AS ((data ->> 'severity'::text)) STORED,
+    quality text GENERATED ALWAYS AS ((data ->> 'quality'::text)) STORED
 );
 
 CREATE SEQUENCE agent_review_diagnostics_id_seq
@@ -7233,6 +7234,8 @@ CREATE INDEX idx_agent_changesets_state ON agent_changesets USING btree (state);
 
 CREATE INDEX idx_agent_review_diagnostics_created_at ON agent_review_diagnostics USING btree (created_at);
 
+CREATE INDEX idx_agent_review_diagnostics_quality ON agent_review_diagnostics USING btree (quality);
+
 CREATE INDEX idx_agent_review_diagnostics_rule_id ON agent_review_diagnostics USING btree (rule_id);
 
 CREATE INDEX idx_agent_review_diagnostics_severity ON agent_review_diagnostics USING btree (severity);
